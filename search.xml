<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[「BZOJ 4521」「CQOI2016」手机号码]]></title>
    <url>%2Fproblems%2Fbzoj-4521%2F</url>
    <content type="text"><![CDATA[Description现在需要找一些 $11$ 位的手机号码（不含前导零），要出现至少 $3$ 个相邻的相同数字，且不能同时出现 $4$ 和 $8$ 。问区间 $[l,r]\ (10^{10} \leq l \leq r &lt; 10^{11})$ 中有多少符合上述条件的手机号码。 Source[BZOJ]4521 Solution考虑用 记忆化搜索 实现 数位DP 。 用 $f_{pos,pre1,pre2,four,eight,isThree}$ 表示 当前到了第 $12 - pos$ 位，前一位数是 $pre1$，前一位数的前一位数是 $pre2$，是否存在 $4$，是否存在 $8$，是否存在 $3$ 位数连续 的电话号码个数。因为固定 $11$ 位，只需要保证第 $1$ 位非零，所以不需要判断前导零。还有一个细节，当 $l = 10^{10}$ 时，$l - 1$ 会变成 $10$ 位数，显然不符合题意，这时计算就会出错，所以需要特判。具体实现详见代码，时间复杂度为 $O(\lg^3n)$ 。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 10, len = 1; while (y &lt;= x) &#123; y *= 10; ++len; &#125; while (len--) &#123; y /= 10; putchar(x / y + 48); x %= y; &#125;&#125;const int MAXN = 11;LL l, r, f[MAXN + 5][MAXN + 5][MAXN + 5][2][2][2];inline LL dfs(int *num, int pos, int pre1, int pre2, bool four, bool eight, bool isThree, bool lim) &#123; //当前到了第 12 - pos 位，前一位数是 pre1，前一位数的前一位数是 pre2， //four 表示是否出现过 4，eight 表示是否出现过 8，isThree 表示是否有 3 位数连续，lim 表示当前位是否受限制 //固定 11 位，不需要判断前导零，只需要保证开头（第 1 位）不为 0 if (four &amp;&amp; eight) return 0;//不能同时有 4 和 8 if (!pos) return isThree;//搜完了，如果有三个以上连续的，返回 1 if (!lim &amp;&amp; ~f[pos][pre1][pre2][four][eight][isThree]) return f[pos][pre1][pre2][four][eight][isThree];//返回已记录的值 LL res = 0, maxNum = lim ? num[pos] : 9;//当前位最大值 for (int i = (pos == 11); i &lt;= maxNum; ++i)//第一位不能为 0 res += dfs(num, pos - 1, i, pre1, four || (i == 4), eight || (i == 8), isThree || (pre1 == pre2 &amp;&amp; i == pre2), lim &amp;&amp; (i == maxNum)); //搜索下一位，判断是否有 4，是否有 8 以及 是否存在 3 个数连续 if (!lim) f[pos][pre1][pre2][four][eight][isThree] = res;//存下当前状态的值 return res;&#125;inline LL solve(LL x) &#123; int len = 0, num[MAXN + 5]; for (; x; x /= 10) num[++len] = x % 10; memset(f, -1, sizeof (f));//初始化 return len == 11 ? dfs(num, len, 10, 10, 0, 0, 0, 1) : 0;//特判长度是否为 11 //第 1 位受到限制。前 2 位不能为 0 ~ 9，否则会影响检查是否存在 3 位数连续&#125;int main() &#123; read(l), read(r); write(solve(r) - solve(l - 1)); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>动态规划</tag>
        <tag>数位DP</tag>
        <tag>搜索</tag>
        <tag>CQOI</tag>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P4124」「CQOI2016」手机号码]]></title>
    <url>%2Fproblems%2Fluogu-p4124%2F</url>
    <content type="text"><![CDATA[Description现在需要找一些 $11$ 位的手机号码（不含前导零），要出现至少 $3$ 个相邻的相同数字，且不能同时出现 $4$ 和 $8$ 。问区间 $[l,r]\ (10^{10} \leq l \leq r &lt; 10^{11})$ 中有多少符合上述条件的手机号码。 Source[Luogu]P4124 Solution考虑用 记忆化搜索 实现 数位DP 。 用 $f_{pos,pre1,pre2,four,eight,isThree}$ 表示 当前到了第 $12 - pos$ 位，前一位数是 $pre1$，前一位数的前一位数是 $pre2$，是否存在 $4$，是否存在 $8$，是否存在 $3$ 位数连续 的电话号码个数。因为固定 $11$ 位，只需要保证第 $1$ 位非零，所以不需要判断前导零。还有一个细节，当 $l = 10^{10}$ 时，$l - 1$ 会变成 $10$ 位数，显然不符合题意，这时计算就会出错，所以需要特判。具体实现详见代码，时间复杂度为 $O(\lg^3n)$ 。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 10, len = 1; while (y &lt;= x) &#123; y *= 10; ++len; &#125; while (len--) &#123; y /= 10; putchar(x / y + 48); x %= y; &#125;&#125;const int MAXN = 11;LL l, r, f[MAXN + 5][MAXN + 5][MAXN + 5][2][2][2];inline LL dfs(int *num, int pos, int pre1, int pre2, bool four, bool eight, bool isThree, bool lim) &#123; //当前到了第 12 - pos 位，前一位数是 pre1，前一位数的前一位数是 pre2， //four 表示是否出现过 4，eight 表示是否出现过 8，isThree 表示是否有 3 位数连续，lim 表示当前位是否受限制 //固定 11 位，不需要判断前导零，只需要保证开头（第 1 位）不为 0 if (four &amp;&amp; eight) return 0;//不能同时有 4 和 8 if (!pos) return isThree;//搜完了，如果有三个以上连续的，返回 1 if (!lim &amp;&amp; ~f[pos][pre1][pre2][four][eight][isThree]) return f[pos][pre1][pre2][four][eight][isThree];//返回已记录的值 LL res = 0, maxNum = lim ? num[pos] : 9;//当前位最大值 for (int i = (pos == 11); i &lt;= maxNum; ++i)//第一位不能为 0 res += dfs(num, pos - 1, i, pre1, four || (i == 4), eight || (i == 8), isThree || (pre1 == pre2 &amp;&amp; i == pre2), lim &amp;&amp; (i == maxNum)); //搜索下一位，判断是否有 4，是否有 8 以及 是否存在 3 个数连续 if (!lim) f[pos][pre1][pre2][four][eight][isThree] = res;//存下当前状态的值 return res;&#125;inline LL solve(LL x) &#123; int len = 0, num[MAXN + 5]; for (; x; x /= 10) num[++len] = x % 10; memset(f, -1, sizeof (f));//初始化 return len == 11 ? dfs(num, len, 10, 10, 0, 0, 0, 1) : 0;//特判长度是否为 11 //第 1 位受到限制。前 2 位不能为 0 ~ 9，否则会影响检查是否存在 3 位数连续&#125;int main() &#123; read(l), read(r); write(solve(r) - solve(l - 1)); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>动态规划</tag>
        <tag>数位DP</tag>
        <tag>搜索</tag>
        <tag>CQOI</tag>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 1833」「ZJOI2010」count 数字计数]]></title>
    <url>%2Fproblems%2Fbzoj-1833%2F</url>
    <content type="text"><![CDATA[Description给定两个正整数 $l,r\ (1 \leq l \leq r \leq 10^{12})$，求区间 $[l,r]$ 里的所有整数中，每个数码 $0 \sim 9$ 各出现了几次。 Source[BZOJ]1833 Solution考虑 数位DP 。 用 $f_{pos,cnt}$ 表示当前到了第 $len - pos + 1$ 位，有 $cnt$ 个数码 $digit$ 的数中，共有多少个数码 $digit$ 。 分别计算 $0 \sim 9$ 每一个数码，注意判前导零（前导零不算数码 $0$），具体实现详见代码。时间复杂度为 $O(10\lg^2n)$ 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1, len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 12;LL l, r, f[MAXN + 5][MAXN + 5];LL dfs(int *num, int pos, LL cnt, int digit, bool lead, bool lim) &#123; //pos 表示当前是第 len - pos + 1 位，cnt 表示前 len - pos + 1 位中数码 digit 的数量， //digit 表示当前要求的数码，lead 表示是否有前导零，lim 表示当前数位是否受到限制 if (!pos) return cnt;//若搜完最后一位，则返回数码数量 if (!lead &amp;&amp; !lim &amp;&amp; ~f[pos][cnt]) return f[pos][cnt];//返回已记录的值 LL res = 0; int maxNum = lim ? num[pos] : 9;//当前数位最大值 for (int i = 0; i &lt;= maxNum; ++i) res += dfs(num, pos - 1, cnt + ((i == digit) &amp;&amp; !(lead &amp;&amp; !i)), digit, lead &amp;&amp; !i, lim &amp;&amp; i == maxNum); //查找下一位。如果第 i 位的数码是所要求的数码，且该数码不是前导零，那么统计数量 + 1 if (!lead &amp;&amp; !lim) f[pos][cnt] = res;//记录该状态的值 return res;&#125;inline LL solve(LL x, int digit) &#123; if (x &lt; 0) return 0;//l = 0 时 x = -1，特判 int len = 0, num[MAXN + 5]; for (; x; x /= 10) num[++len] = x % 10; memset(f, -1, sizeof (f));//初始化 return dfs(num, len, 0, digit, 1, 1);//注意第一位算 有前导零 且 数位受限制 &#125;int main() &#123; read(l), read(r); for (int i = 0; i &lt;= 9; ++i) &#123; write(solve(r, i) - solve(l - 1, i)); putchar(' '); &#125; putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>2010</tag>
        <tag>动态规划</tag>
        <tag>数位DP</tag>
        <tag>搜索</tag>
        <tag>ZJOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2602」「ZJOI2010」数字计数]]></title>
    <url>%2Fproblems%2Fluogu-p2602%2F</url>
    <content type="text"><![CDATA[Description给定两个正整数 $l,r\ (1 \leq l \leq r \leq 10^{12})$，求区间 $[l,r]$ 里的所有整数中，每个数码 $0 \sim 9$ 各出现了几次。 Source[Luogu]P2602 Solution考虑 数位DP 。 用 $f_{pos,cnt}​$ 表示当前到了第 $len - pos + 1​$ 位，有 $cnt​$ 个数码 $digit​$ 的数中，共有多少个数码 $digit​$ 。 分别计算 $0 \sim 9$ 每一个数码，注意判前导零（前导零不算数码 $0$），具体实现详见代码。时间复杂度为 $O(10\lg^2n)$ 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1, len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 12;LL l, r, f[MAXN + 5][MAXN + 5];LL dfs(int *num, int pos, LL cnt, int digit, bool lead, bool lim) &#123; //pos 表示当前是第 len - pos + 1 位，cnt 表示前 len - pos + 1 位中数码 digit 的数量， //digit 表示当前要求的数码，lead 表示是否有前导零，lim 表示当前数位是否受到限制 if (!pos) return cnt;//若搜完最后一位，则返回数码数量 if (!lead &amp;&amp; !lim &amp;&amp; ~f[pos][cnt]) return f[pos][cnt];//返回已记录的值 LL res = 0; int maxNum = lim ? num[pos] : 9;//当前数位最大值 for (int i = 0; i &lt;= maxNum; ++i) res += dfs(num, pos - 1, cnt + ((i == digit) &amp;&amp; !(lead &amp;&amp; !i)), digit, lead &amp;&amp; !i, lim &amp;&amp; i == maxNum); //查找下一位。如果第 i 位的数码是所要求的数码，且该数码不是前导零，那么统计数量 + 1 if (!lead &amp;&amp; !lim) f[pos][cnt] = res;//记录该状态的值 return res;&#125;inline LL solve(LL x, int digit) &#123; if (x &lt; 0) return 0;//l = 0 时 x = -1，特判 int len = 0, num[MAXN + 5]; for (; x; x /= 10) num[++len] = x % 10; memset(f, -1, sizeof (f));//初始化 return dfs(num, len, 0, digit, 1, 1);//注意第一位算 有前导零 且 数位受限制 &#125;int main() &#123; read(l), read(r); for (int i = 0; i &lt;= 9; ++i) &#123; write(solve(r, i) - solve(l - 1, i)); putchar(' '); &#125; putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>2010</tag>
        <tag>动态规划</tag>
        <tag>数位DP</tag>
        <tag>搜索</tag>
        <tag>ZJOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 1799」「AHOI2009」self 同类分布]]></title>
    <url>%2Fproblems%2Fbzoj-1799%2F</url>
    <content type="text"><![CDATA[Description给定 $l$ 和 $r\ \left( 1 \leq l \leq r \leq 10^{18} \right)$，求区间 $[l,r]$ 中各位数字之和能整除原数的数的个数。 Source[BZOJ]1799 Solution考虑 数位DP 。 用 $f_{pos,sum,now}$ 表示当前到了第 $len - pos + 1$ 位，这些数位的和是 $sum$，模 $mod$ 的值为 $now$ 的数的个数。 可以枚举 所有数位的和 的值，这个值显然不会超过 $9\lg n$（这个值在每一位都是 $9$ 时最大）。我们把这个值当做模数 $mod$，当前数每增加一位时，我们统计各个数位的和 $sum$，并将新的数对 $mod$ 取模。当搜到最后一位时，如果模数为 $0$，那么满足条件整除；如果 $sum = mod$，那么满足 此时所有数位的和 = 枚举的所有数位的和 。如果上述两个条件都满足，则说明这个数符合题意。同时因为只需要统计 各个数位和 以及 数对 $mod$ 取模的值，所以不需要判前导零。具体实现过程详见代码，时间复杂度为 $O(9^3n\lg^3 n)$ 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1, len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 18, MAXM = MAXN * 9;LL l, r, f[MAXN + 5][MAXM + 5][MAXM + 5];LL dfs(int *num, int pos, int sum, int now, int mod, bool lim) &#123; //pos 表示当前是第 len - pos + 1 位，sum 表示此时所有数位的和， //now 表示当前的数对 mod 取模后的值，mod 表示枚举的所有数位的和，lim 表示当前数位是否受到限制 if (!pos) return !now &amp;&amp; sum == mod;//如果 能够整除 且 此时所有数位的和 = 枚举的所有数位的和，返回 1 if (!lim &amp;&amp; ~f[pos][sum][now]) return f[pos][sum][now];//返回已记录的值 LL res = 0; int maxNum = lim ? num[pos] : 9;//当前数位最大值 for (int i = 0; i &lt;= maxNum; ++i) res += dfs(num, pos - 1, sum + i, (now * 10 + i) % mod, mod, lim &amp;&amp; i == maxNum);//查找下一位 if (!lim) f[pos][sum][now] = res;//记录该状态的值 return res;&#125;inline LL solve(LL x) &#123; int len = 0, num[MAXN + 5]; for (; x; x /= 10) num[++len] = x % 10; LL res = 0; for (int i = 1; i &lt;= 9 * len; ++i) &#123;//枚举所有数位的和，最大不会超过 9 * 数位长度（每一位都是 9） memset(f, -1, sizeof (f));//初始化 res += dfs(num, len, 0, 0, i, 1);//设所有数位的和为 i，累加答案，且注意第一位会受限 &#125; return res;&#125;int main() &#123; read(l), read(r); write(solve(r) - solve(l - 1)); putchar('\n'); return 0;&#125; ​]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>2009</tag>
        <tag>动态规划</tag>
        <tag>数位DP</tag>
        <tag>搜索</tag>
        <tag>AHOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P4127」「AHOI2009」同类分布]]></title>
    <url>%2Fproblems%2Fluogu-p4127%2F</url>
    <content type="text"><![CDATA[Description给定 $l$ 和 $r\ \left( 1 \leq l \leq r \leq 10^{18} \right)$，求区间 $[l,r]$ 中各位数字之和能整除原数的数的个数。 Source[Luogu]P4127 Solution考虑 数位DP 。 用 $f_{pos,sum,now}$ 表示当前到了第 $len - pos + 1$ 位，这些数位的和是 $sum$，模 $mod$ 的值为 $now$ 的数的个数。 可以枚举 所有数位的和 的值，这个值显然不会超过 $9\lg n$（这个值在每一位都是 $9$ 时最大）。我们把这个值当做模数 $mod$，当前数每增加一位时，我们统计各个数位的和 $sum$，并将新的数对 $mod$ 取模。当搜到最后一位时，如果模数为 $0$，那么满足条件整除；如果 $sum = mod$，那么满足 此时所有数位的和 = 枚举的所有数位的和 。如果上述两个条件都满足，则说明这个数符合题意。同时因为只需要统计 各个数位和 以及 数对 $mod$ 取模的值，所以不需要判前导零。具体实现过程详见代码，时间复杂度为 $O(9^3n\lg^3 n)$ 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1, len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 18, MAXM = MAXN * 9;LL l, r, f[MAXN + 5][MAXM + 5][MAXM + 5];LL dfs(int *num, int pos, int sum, int now, int mod, bool lim) &#123; //pos 表示当前是第 len - pos + 1 位，sum 表示此时所有数位的和， //now 表示当前的数对 mod 取模后的值，mod 表示枚举的所有数位的和，lim 表示当前数位是否受到限制 if (!pos) return !now &amp;&amp; sum == mod;//如果 能够整除 且 此时所有数位的和 = 枚举的所有数位的和，返回 1 if (!lim &amp;&amp; ~f[pos][sum][now]) return f[pos][sum][now];//返回已记录的值 LL res = 0; int maxNum = lim ? num[pos] : 9;//当前数位最大值 for (int i = 0; i &lt;= maxNum; ++i) res += dfs(num, pos - 1, sum + i, (now * 10 + i) % mod, mod, lim &amp;&amp; i == maxNum);//查找下一位 if (!lim) f[pos][sum][now] = res;//记录该状态的值 return res;&#125;inline LL solve(LL x) &#123; int len = 0, num[MAXN + 5]; for (; x; x /= 10) num[++len] = x % 10; LL res = 0; for (int i = 1; i &lt;= 9 * len; ++i) &#123;//枚举所有数位的和，最大不会超过 9 * 数位长度（每一位都是 9） memset(f, -1, sizeof (f));//初始化 res += dfs(num, len, 0, 0, i, 1);//设所有数位的和为 i，累加答案，且注意第一位会受限 &#125; return res;&#125;int main() &#123; read(l), read(r); write(solve(r) - solve(l - 1)); putchar('\n'); return 0;&#125; ​]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>2009</tag>
        <tag>动态规划</tag>
        <tag>数位DP</tag>
        <tag>搜索</tag>
        <tag>AHOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 1026」「SCOI2009」windy数]]></title>
    <url>%2Fproblems%2Fbzoj-1026%2F</url>
    <content type="text"><![CDATA[Description给定 $l$ 和 $r\ \left( 1 \leq l \leq r \leq 2 \times 10^9 \right)$，求区间 $[l,r]$ 有多少个 不含前导零且相邻两个数字之差至少为 $2$ 的正整数（即 $\rm{windy}$ 数）。 Source[BZOJ]1026 Solution数位DP 入门题。 用 $f_{pos,pre}$ 表示当前到了第 $len - pos + 1$ 位，上一位是 $pre$ 的 $\rm{windy}$ 数个数。 考虑用 记忆化搜索 实现 数位DP 。枚举每一位，保证当前位与上一位的差大于等于 $2$ 。注意判断是否有前导零，如果有或者刚开始搜，就把上一位设为 $11$（因为 $0 \sim 9$ 与 $11$ 的差都大于等于 $2$，保证下一位没有限制），具体实现详见代码。时间复杂度为 $O(\lg^2 n)$ 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1, len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 10;int l, r, f[MAXN + 5][MAXN + 5];int dfs(int *num, int pos, int pre, bool lead, bool lim) &#123; //pos 表示当前是第 len - pos + 1 位，pre 表示上一个数，lead 表示是否有前导零，lim 表示当前数位是否受到限制 if (!pos) return 1;//搜完了 if (!lim &amp;&amp; !lead &amp;&amp; ~f[pos][pre]) return f[pos][pre];//返回该状态已记录的值 int res = 0, maxNum = lim ? num[pos] : 9;//如果有限制，当前位则为 0 ~ 当前位的值，否则为 0 ~ 9 for (int i = 0; i &lt;= maxNum; ++i) &#123; if (abs(i - pre) &lt; 2) continue;//相邻数位之差不能小于 2（题目要求） if (lead &amp;&amp; !i) res += dfs(num, pos - 1, 11, 1, lim &amp;&amp; i == maxNum);//如果前面全是前导零，第一位仍设为 11 else res += dfs(num, pos - 1, i, 0, lim &amp;&amp; i == maxNum);//否则设当前位为 i，枚举下一位 &#125; if (!lim &amp;&amp; !lead) f[pos][pre] = res;//如果没有前导 0 且 最高位无限制，则存下这个状态的值 return res;&#125;//记忆化搜索 实现 数位DP inline int solve(int x) &#123; int len = 0, num[MAXN + 5]; for (; x; x /= 10) num[++len] = x % 10; memset(f, -1, sizeof (f));//初始化为 -1 return dfs(num, len, 11, 1, 1);//从 11 开始可以保证数字第一位没有限制 &#125;int main() &#123; read(l), read(r); write(solve(r) - solve(l - 1)); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>2009</tag>
        <tag>动态规划</tag>
        <tag>SCOI</tag>
        <tag>数位DP</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2657」「SCOI2009」windy数]]></title>
    <url>%2Fproblems%2Fluogu-p2657%2F</url>
    <content type="text"><![CDATA[Description给定 $l$ 和 $r\ \left( 1 \leq l \leq r \leq 2 \times 10^9 \right)$，求区间 $[l,r]$ 有多少个 不含前导零且相邻两个数字之差至少为 $2$ 的正整数（即 $\rm{windy}$ 数）。 Source[Luogu]P2657 Solution数位DP 入门题。 用 $f_{pos,pre}$ 表示当前到了第 $len - pos + 1$ 位，上一位是 $pre$ 的 $\rm{windy}$ 数个数。 考虑用 记忆化搜索 实现 数位DP 。枚举每一位，保证当前位与上一位的差大于等于 $2$ 。注意判断是否有前导零，如果有或者刚开始搜，就把上一位设为 $11$（因为 $0 \sim 9$ 与 $11$ 的差都大于等于 $2$，保证下一位没有限制），具体实现详见代码。时间复杂度为 $O(\lg^2 n)​$ 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1, len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 10;int l, r, f[MAXN + 5][MAXN + 5];int dfs(int *num, int pos, int pre, bool lead, bool lim) &#123; //pos 表示当前是第 len - pos + 1 位，pre 表示上一个数，lead 表示是否有前导零，lim 表示当前数位是否受到限制 if (!pos) return 1;//搜完了 if (!lim &amp;&amp; !lead &amp;&amp; ~f[pos][pre]) return f[pos][pre];//返回该状态已记录的值 int res = 0, maxNum = lim ? num[pos] : 9;//如果有限制，当前位则为 0 ~ 当前位的值，否则为 0 ~ 9 for (int i = 0; i &lt;= maxNum; ++i) &#123; if (abs(i - pre) &lt; 2) continue;//相邻数位之差不能小于 2（题目要求） if (lead &amp;&amp; !i) res += dfs(num, pos - 1, 11, 1, lim &amp;&amp; i == maxNum);//如果前面全是前导零，第一位仍设为 11 else res += dfs(num, pos - 1, i, 0, lim &amp;&amp; i == maxNum);//否则设当前位为 i，枚举下一位 &#125; if (!lim &amp;&amp; !lead) f[pos][pre] = res;//如果没有前导 0 且 最高位无限制，则存下这个状态的值 return res;&#125;//记忆化搜索 实现 数位DP inline int solve(int x) &#123; int len = 0, num[MAXN + 5]; for (; x; x /= 10) num[++len] = x % 10; memset(f, -1, sizeof (f));//初始化为 -1 return dfs(num, len, 11, 1, 1);//从 11 开始可以保证数字第一位没有限制 &#125;int main() &#123; read(l), read(r); write(solve(r) - solve(l - 1)); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>2009</tag>
        <tag>动态规划</tag>
        <tag>SCOI</tag>
        <tag>数位DP</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 1087」「SCOI2005」互不侵犯King]]></title>
    <url>%2Fproblems%2Fbzoj-1087%2F</url>
    <content type="text"><![CDATA[Description在 $n \times n\ (1 \leq n \leq 9)$ 的棋盘上放置 $m\ (0 \leq m \leq n \times n)$ 个国王，每个国王都能攻击周围的 $8$ 个格子，求使它们无法互相攻击的方案数。 Source[BZOJ]1087 Solution状压DP 入门题，当然也可以打表（滑稽 如何 状态压缩？ 考虑把每一行的状态用一个 二进制数 来表示。若这个数的某一位为 $1​$，则代表这个位置上放了国王，$0​$ 反之。 状态： 用 $f_{i,j,k}$ 表示第 $i$ 行是第 $j$ 个状态，前 $i$ 行（包括第 $i$ 行）共放了 $k$ 个国王的方案数。 初始： \large {\begin{aligned} & f_{1,i,cnt_i} = 1 && \left( 当且仅当第\ i\ 个状态合法 \right) \end{aligned}}其中 $cnt_i$ 表示第 $i$ 个状态国王的个数。若在第 $1$ 行状态合法，则此状态的方案数为 $1$ 。 转移： \large {\begin{aligned} & f_{i,k,l} = f_{i, k, l} + f_{i - 1, j, l - cnt_k} & \left( cnt_k \leq l \leq m \right) \end{aligned}}其中 $cnt_k​$ 表示第 $k​$ 个状态国王的个数。若第 $i - 1​$ 行是 第 $j​$ 个状态，第 $i​$ 行是 第 $k​$ 个状态，枚举 第 $j​$ 个状态 和 第 $k​$ 个状态，如果这两个状态合法，且 第 $k​$ 个状态 能够放在 第 $j​$ 个状态 的下一行（两个状态的国王保持和平），就可以转移。假设在前 $i​$ 行共放了 $l​$ 个国王，那么前 $i - 1​$ 行就放了 $l - cnt_k​$ 个国王，显然这个方案是成立的，所以累加更新这个状态的方案数。 怎么判断 两个状态合法 且 上下两行国王和平 呢？这就要用到 状态压缩 时常用的位运算了。 若第 $i$ 个状态为 $state_i$，且 $state_i\&amp; \left( state_i &lt;&lt; 1 \right) &gt; 0​$，则说明存在相邻的国王互相攻击，该行状态不合法。 若第 $i$ 个状态为 $state_i$，第 $j$ 个状态为 $state_j$，且 $state_i\&amp; state_j &gt; 0 $，则说明存在上下国王互相攻击。 若第 $i​$ 个状态为 $state_i​$，第 $j​$ 个状态为 $state_j​$，且 $state_i\&amp; \left(state_j &lt;&lt; 1\right) &gt; 0​$，则说明存在左上与右下的国王互相攻击。 若第 $i​$ 个状态为 $state_i​$，第 $j​$ 个状态为 $state_j​$，且 $\left(state_i &lt;&lt; 1\right) \&amp; state_j &gt; 0​$，则说明存在右上与左下的国王互相攻击。 答案： \large { \sum\limits_{i=1}^{tot} f_{n,i,m} }其中 $tot$ 表示合法的状态总数。答案即为：最后一行状态合法，前 $n$ 行共放了 $m$ 个国王的方案数总和。 一行里所有的状态共 $2^n​$ 个（考虑每一位是 $0​$ 还是 $1​$），所以时间复杂度为 $O(nm2^{2n})​$，可能会超时。但很容易发现，在一行里有很多状态本来就是不合法的，比如 $n = 4​$ 时 $0110​$ 这个状态，实际有用的状态远不及 $2^n​$ 个。因此我们考虑先用搜索预处理出所有合法的状态，再进行转移，这样效率能高很多。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1, len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 9, MAXM = 1 &lt;&lt; 9;//2的9次方 int n, m, tot, state[MAXM + 5], cnt[MAXM + 5];LL ans, f[MAXN + 5][MAXM + 5][MAXN * MAXN + 5];void dfs(int x, int now, int king, bool pre) &#123; //x 表示已经搜到第 x 位，now 表示当前状态，king 表示当前国王数量（1 的数量），pre 表示上一位是什么 if (king &gt; m) return;//国王数不能超过 m if (x &gt; n) &#123; state[++tot] = now; cnt[tot] = king;//存下 这个状态 和 这个状态对应国王的数量 return; &#125; if (!pre) dfs(x + 1, now &lt;&lt; 1 | 1, king + 1, 1);//把 now 的第 x 位变成 1 //如果上一位是 1，显然这一位不能放 1 dfs(x + 1, now &lt;&lt; 1, king, 0);//把 now 的第 x 位变成 0&#125;int main() &#123; read(n), read(m); dfs(1, 0, 0, 0);//预处理一行里的合法状态 for (int i = 1; i &lt;= tot; ++i) f[1][i][cnt[i]] = 1;//初始 for (int i = 2; i &lt;= n; ++i) for (int j = 1; j &lt;= tot; ++j) for (int k = 1; k &lt;= tot; ++k) &#123; if ((state[j] &amp; state[k]) || ((state[j] &lt;&lt; 1) &amp; state[k]) || (state[j] &amp; (state[k] &lt;&lt; 1))) continue; //判断第 k 个状态放在第 j 个状态下面一行是否合法，且不需要考虑同一行国王相邻的情况 for (int l = cnt[k]; l &lt;= m; ++l) f[i][k][l] += f[i - 1][j][l - cnt[k]];//转移 &#125; for (int i = 1; i &lt;= tot; ++i) ans += f[n][i][m];//累加放完第 n 行，共 m 个国王的所有状态 write(ans); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>动态规划</tag>
        <tag>SCOI</tag>
        <tag>搜索</tag>
        <tag>2005</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P1896」「SCOI2005」互不侵犯]]></title>
    <url>%2Fproblems%2Fluogu-p1896%2F</url>
    <content type="text"><![CDATA[Description在 $n \times n\ (1 \leq n \leq 9)$ 的棋盘上放置 $m\ (0 \leq m \leq n \times n)$ 个国王，每个国王都能攻击周围的 $8$ 个格子，求使它们无法互相攻击的方案数。 Source[Luogu]P1896 Solution状压DP 入门题，当然也可以打表（滑稽 如何 状态压缩？ 考虑把每一行的状态用一个 二进制数 来表示。若这个数的某一位为 $1​$，则代表这个位置上放了国王，$0​$ 反之。 状态： 用 $f_{i,j,k}$ 表示第 $i$ 行是第 $j$ 个状态，前 $i$ 行（包括第 $i$ 行）共放了 $k$ 个国王的方案数。 初始： \large {\begin{aligned} & f_{1,i,cnt_i} = 1 && \left( 当且仅当第\ i\ 个状态合法 \right) \end{aligned}}其中 $cnt_i$ 表示第 $i$ 个状态国王的个数。若在第 $1$ 行状态合法，则此状态的方案数为 $1$ 。 转移： \large {\begin{aligned} & f_{i,k,l} = f_{i, k, l} + f_{i - 1, j, l - cnt_k} & \left( cnt_k \leq l \leq m \right) \end{aligned}}其中 $cnt_k​$ 表示第 $k​$ 个状态国王的个数。若第 $i - 1​$ 行是 第 $j​$ 个状态，第 $i​$ 行是 第 $k​$ 个状态，枚举 第 $j​$ 个状态 和 第 $k​$ 个状态，如果这两个状态合法，且 第 $k​$ 个状态 能够放在 第 $j​$ 个状态 的下一行（两个状态的国王保持和平），就可以转移。假设在前 $i​$ 行共放了 $l​$ 个国王，那么前 $i - 1​$ 行就放了 $l - cnt_k​$ 个国王，显然这个方案是成立的，所以累加更新这个状态的方案数。 怎么判断 两个状态合法 且 上下两行国王和平 呢？这就要用到 状态压缩 时常用的位运算了。 若第 $i$ 个状态为 $state_i$，且 $state_i\&amp; \left( state_i &lt;&lt; 1 \right) &gt; 0​$，则说明存在相邻的国王互相攻击，该行状态不合法。 若第 $i$ 个状态为 $state_i$，第 $j$ 个状态为 $state_j$，且 $state_i\&amp; state_j &gt; 0 $，则说明存在上下国王互相攻击。 若第 $i​$ 个状态为 $state_i​$，第 $j​$ 个状态为 $state_j​$，且 $state_i\&amp; \left(state_j &lt;&lt; 1\right) &gt; 0​$，则说明存在左上与右下的国王互相攻击。 若第 $i​$ 个状态为 $state_i​$，第 $j​$ 个状态为 $state_j​$，且 $\left(state_i &lt;&lt; 1\right) \&amp; state_j &gt; 0​$，则说明存在右上与左下的国王互相攻击。 答案： \large { \sum\limits_{i=1}^{tot} f_{n,i,m} }其中 $tot$ 表示合法的状态总数。答案即为：最后一行状态合法，前 $n$ 行共放了 $m$ 个国王的方案数总和。 一行里所有的状态共 $2^n​$ 个（考虑每一位是 $0​$ 还是 $1​$），所以时间复杂度为 $O(nm2^{2n})​$，可能会超时。但很容易发现，在一行里有很多状态本来就是不合法的，比如 $n = 4​$ 时 $0110​$ 这个状态，实际有用的状态远不及 $2^n​$ 个。因此我们考虑先用搜索预处理出所有合法的状态，再进行转移，这样效率能高很多。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1, len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 9, MAXM = 1 &lt;&lt; 9;//2的9次方 int n, m, tot, state[MAXM + 5], cnt[MAXM + 5];LL ans, f[MAXN + 5][MAXM + 5][MAXN * MAXN + 5];void dfs(int x, int now, int king, bool pre) &#123; //x 表示已经搜到第 x 位，now 表示当前状态，king 表示当前国王数量（1 的数量），pre 表示上一位是什么 if (king &gt; m) return;//国王数不能超过 m if (x &gt; n) &#123; state[++tot] = now; cnt[tot] = king;//存下 这个状态 和 这个状态对应国王的数量 return; &#125; if (!pre) dfs(x + 1, now &lt;&lt; 1 | 1, king + 1, 1);//把 now 的第 x 位变成 1 //如果上一位是 1，显然这一位不能放 1 dfs(x + 1, now &lt;&lt; 1, king, 0);//把 now 的第 x 位变成 0&#125;int main() &#123; read(n), read(m); dfs(1, 0, 0, 0);//预处理一行里的合法状态 for (int i = 1; i &lt;= tot; ++i) f[1][i][cnt[i]] = 1;//初始 for (int i = 2; i &lt;= n; ++i) for (int j = 1; j &lt;= tot; ++j) for (int k = 1; k &lt;= tot; ++k) &#123; if ((state[j] &amp; state[k]) || ((state[j] &lt;&lt; 1) &amp; state[k]) || (state[j] &amp; (state[k] &lt;&lt; 1))) continue; //判断第 k 个状态放在第 j 个状态下面一行是否合法，且不需要考虑同一行国王相邻的情况 for (int l = cnt[k]; l &lt;= m; ++l) f[i][k][l] += f[i - 1][j][l - cnt[k]];//转移 &#125; for (int i = 1; i &lt;= tot; ++i) ans += f[n][i][m];//累加放完第 n 行，共 m 个国王的所有状态 write(ans); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>动态规划</tag>
        <tag>SCOI</tag>
        <tag>搜索</tag>
        <tag>2005</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 3566」「SHOI2014」概率充电器]]></title>
    <url>%2Fproblems%2Fbzoj-3566%2F</url>
    <content type="text"><![CDATA[Description给定一棵 $n$ 个点的树，每个节点都有一个充电元件，第 $i$ 条边有 $p_i \%$ 的概率导电，第 $i$ 个点有 $q_i \%$ 的概率充电。求期望通电的元件个数，保留 $6$ 位小数。 Source[BZOJ]3566 Solution首先根据 期望 的性质： \large { E(A + B) = E(A) + E(B) }得到 \large {\begin{aligned} E\left( \sum\limits_{i=1}^n i \right) = \sum\limits_{i=1}^nE(i) = \sum\limits_{i=1}^n p_ix_i \end{aligned}}因为每个充电元件的贡献都是 $1$（即 $x_i = 1$），所以问题就是求所有元件充电的概率总和： \large { \sum\limits_{i=1}^n p_i }其中 $p_i$ 是元件 $i$ 通电的概率。这个东西怎么求呢？尝试 树形DP 。 状态： 用 $p_u$ 表示元件 $u$ 通电的概率。 转移： 考虑节点 $u$ 通电的 $3$ 种可能： 节点 $u$ 自己充电； 子树里有一个节点充电并传导到节点 $u$； 子树外有一个节点充电并传导到节点 $u​$ 。 节点 $u$ 自己充电很好实现，因为节点 $u$ 通电的初始概率就是读入进来的 $p_u$ 。 但是后两种似乎很难同时实现，干脆分两次 $\rm{dfs}​$ 解决。 对于第一次 $\rm{dfs}​$，我们先考虑第二种可能，有以下方程 \large {\begin{aligned} & p_u = p_u \cup \left( p_v \times q_{u \rightarrow v} \right) & \left( v \in son_u\right) \end{aligned}}其中 $q_{u \rightarrow v}​$ 表示边 $u \rightarrow v​$ 导电的概率。节点 $u​$ 通电的概率就是 节点 $u​$ 自己发电 与 子节点 $v​$ 通电后经过边 $u \rightarrow v​$ 传导到 $u​$ 的并集，换句话说，就是上述两种情况至少发生一种的概率。两个概率的并怎么求呢？有如下公式 \large { \begin{aligned} P\left( A \cup B \right) &= P\left( A \right) + P\left( B \right) - P\left( A \cap B \right)\\ &= P\left( A \right) + P\left( B \right) - P\left( A \right) \times P\left( B \right) \end{aligned} }很好证明，因为 $A$ 和 $B$ 至少发生一种，分 $3$ 种情况讨论（都运用了 乘法原理）： $A​$ 发生 $B​$ 不发生，概率为 $P\left(A \right) \times \left( 1 - P \left( B\right) \right)​$； $B$ 发生 $A$ 不发生，概率为 $P\left(B \right) \times \left( 1 - P \left( A\right) \right)$ ； $A​$ 与 $B​$ 同时发生，概率为 $P \left( A\right) \times P \left( B\right)​$ 。 根据 加法原理，把上述值加起来即能得证。这样我们就处理好了子树里节点导电的情况。 对于第二次 $\rm{dfs}​$，我们再考虑第三种可能，有以下方程 \large {\begin{aligned} & p_v = p_v \cup \left( \frac{p_u - p_v \times q_{u \rightarrow v}}{1 - p_v \times q_{u \rightarrow v}} \times q_{u \rightarrow v} \right) & \left( v \in son_u\right) \end{aligned}}其中 $q_{u \rightarrow v}$ 表示边 $u \rightarrow v$ 导电的概率。显然根节点（$root$）通电的概率已知（不可能有第三种可能），考虑通过父节点 $u$ 状态确定子节点 $v$ 。 $p_v$ 的值一定为 当前 $p_v$ 的值（自己和子树内的通电概率） 和 子树外节点通电传导给 $v$ 的并。其中 $v$ 子树里的节点通电传导给 $u$ 的概率为 $p_v \times q_{u \rightarrow v}$，这个值与子节点 $v$ 的 子树外节点通电传导给 $u$ 的概率 的并是 $p_u$ 。而现在要求 子树外节点通电传导给 $u$ 的概率 。 这个问题可以转化为——若已知 $P \left( B\right),P \left( C\right)$ 的值，且 $P\left( A \cup B \right) = P \left ( C\right)$，怎么求 $P \left( A \right)$？ 用刚才的公式倒推即可： \large { P \left( A \cup B\right) = P \left( C \right) } \large { P\left( A \right) + P\left( B \right) - P\left( A \right) \times P\left( B \right) = P\left( C \right) } \large { P\left( A \right) - P\left( A \right) \times P\left( B \right) = P\left( C \right) -P\left( B \right) } \large { P\left( A \right) \times \left( 1 - P\left( B \right) \right) = P\left( C \right) -P\left( B \right) } \large {\begin{aligned} & P\left( A \right) = \frac{P\left( C \right) -P\left( B \right)}{1 - P\left( B \right)} & \left( P \left( B \right) \neq 1 \right) \end{aligned} }根据这个式子求出 子树外节点通电传导给 $u$ 的概率，乘上 $q_{u \rightarrow v}$ 就是 子树外节点通电传导给 $v$ 的概率 了，再求 $p_v$ 与它的并，就是这个状态的值。值得注意的是，如果上述式子中的 $P\left( B \right) = 1$（即 $p_v \times q_{u \rightarrow v} = 1$），显然是不能直接除的，但因为 $0 \leq p_v,q_{u \rightarrow v} \leq 1$，所以 $p_v = q_{u \rightarrow v} = 1$，在这种情况下可以直接跳过，不进行转移（$p_v$ 一定通电）。最后把所有节点通电的概率加起来即为答案。 与第一次 $\rm{dfs}$ 不同的是：第一次是由子树合并答案，需要递归到底，返回时再转移；第二次是由父节点更新答案，遍历完整棵树即可。时间复杂度为 $O(n)​$ 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;const int MAXN = 5e5, MAXM = 5e5;const double eps = 1e-7;int n, tot, head[MAXN + 5];double ans, p[MAXN + 5], x[MAXN + 5];struct Edge &#123; int next, to; double dis;&#125; e[(MAXM &lt;&lt; 1) + 5];inline void addEdge(int u, int v, double w) &#123; e[++tot] = (Edge) &#123; head[u], v, w &#125;; head[u] = tot;&#125;inline double cup(double a, double b) &#123;//求两个概率的并 a∪b return a + b - a * b;&#125;inline double calc(double a, double b) &#123;//已知 P(b) 以及 P(a)∪P(b)，求 P(a) return (a - b) / (1.0 - b);&#125;void dfsUp(int u, int fa) &#123;//第一次 dfs，子树内节点传导电 for (int v, i = head[u]; v = e[i].to, i; i = e[i].next) &#123; if (v == fa) continue; dfsUp(v, u);//递归到底层 double q = e[i].dis; p[u] = cup(p[u], p[v] * q);//转移 &#125;&#125;void dfsDown(int u, int fa) &#123;//第二次 dfs，子树外节点传导电 ans += p[u];//累加答案 for (int v, i = head[u]; v = e[i].to, i; i = e[i].next) &#123; if (v == fa) continue; double q = e[i].dis; if (fabs(p[v] * q - 1.0) &lt; eps) &#123; dfsDown(v, u); continue;//跳过并向下搜 &#125; p[v] = cup(p[v], calc(p[u], p[v] * q) * q);//转移 dfsDown(v, u);//遍历整棵树 &#125;&#125;int main() &#123; read(n); for (int i = 1; i &lt; n; ++i) &#123; int u, v; double w; read(u), read(v), read(w); w *= 0.01;//q% addEdge(u, v, w), addEdge(v, u, w);//连无向边 &#125; for (int i = 1; i &lt;= n; ++i) &#123; read(p[i]); p[i] *= 0.01;//初始概率 为 节点自己充电的概率 &#125; dfsUp(1, 0); dfsDown(1, 0);//根节点为 1 printf("%.6lf\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>动态规划</tag>
        <tag>SHOI</tag>
        <tag>2014</tag>
        <tag>概率期望</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P4284」「SHOI2014」概率充电器]]></title>
    <url>%2Fproblems%2Fluogu-p4284%2F</url>
    <content type="text"><![CDATA[Description给定一棵 $n$ 个点的树，每个节点都有一个充电元件，第 $i$ 条边有 $p_i \%$ 的概率导电，第 $i$ 个点有 $q_i \%$ 的概率充电。求期望通电的元件个数，保留 $6$ 位小数。 Source[Luogu]P4284 Solution首先根据 期望 的性质： \large { E(A + B) = E(A) + E(B) }得到 \large {\begin{aligned} E\left( \sum\limits_{i=1}^n i \right) = \sum\limits_{i=1}^nE(i) = \sum\limits_{i=1}^n p_ix_i \end{aligned}}因为每个充电元件的贡献都是 $1$（即 $x_i = 1$），所以问题就是求所有元件充电的概率总和： \large { \sum\limits_{i=1}^n p_i }其中 $p_i$ 是元件 $i$ 通电的概率。这个东西怎么求呢？尝试 树形DP 。 状态： 用 $p_u$ 表示元件 $u$ 通电的概率。 转移： 考虑节点 $u$ 通电的 $3$ 种可能： 节点 $u$ 自己充电； 子树里有一个节点充电并传导到节点 $u$； 子树外有一个节点充电并传导到节点 $u​$ 。 节点 $u$ 自己充电很好实现，因为节点 $u$ 通电的初始概率就是读入进来的 $p_u$ 。 但是后两种似乎很难同时实现，干脆分两次 $\rm{dfs}​$ 解决。 对于第一次 $\rm{dfs}​$，我们先考虑第二种可能，有以下方程 \large {\begin{aligned} & p_u = p_u \cup \left( p_v \times q_{u \rightarrow v} \right) & \left( v \in son_u\right) \end{aligned}}其中 $q_{u \rightarrow v}​$ 表示边 $u \rightarrow v​$ 导电的概率。节点 $u​$ 通电的概率就是 节点 $u​$ 自己发电 与 子节点 $v​$ 通电后经过边 $u \rightarrow v​$ 传导到 $u​$ 的并集，换句话说，就是上述两种情况至少发生一种的概率。两个概率的并怎么求呢？有如下公式 \large { \begin{aligned} P\left( A \cup B \right) &= P\left( A \right) + P\left( B \right) - P\left( A \cap B \right)\\ &= P\left( A \right) + P\left( B \right) - P\left( A \right) \times P\left( B \right) \end{aligned} }很好证明，因为 $A$ 和 $B$ 至少发生一种，分 $3$ 种情况讨论（都运用了 乘法原理）： $A​$ 发生 $B​$ 不发生，概率为 $P\left(A \right) \times \left( 1 - P \left( B\right) \right)​$； $B$ 发生 $A$ 不发生，概率为 $P\left(B \right) \times \left( 1 - P \left( A\right) \right)$ ； $A​$ 与 $B​$ 同时发生，概率为 $P \left( A\right) \times P \left( B\right)​$ 。 根据 加法原理，把上述值加起来即能得证。这样我们就处理好了子树里节点导电的情况。 对于第二次 $\rm{dfs}​$，我们再考虑第三种可能，有以下方程 \large {\begin{aligned} & p_v = p_v \cup \left( \frac{p_u - p_v \times q_{u \rightarrow v}}{1 - p_v \times q_{u \rightarrow v}} \times q_{u \rightarrow v} \right) & \left( v \in son_u\right) \end{aligned}}其中 $q_{u \rightarrow v}$ 表示边 $u \rightarrow v$ 导电的概率。显然根节点（$root$）通电的概率已知（不可能有第三种可能），考虑通过父节点 $u$ 状态确定子节点 $v$ 。 $p_v$ 的值一定为 当前 $p_v$ 的值（自己和子树内的通电概率） 和 子树外节点通电传导给 $v$ 的并。其中 $v$ 子树里的节点通电传导给 $u$ 的概率为 $p_v \times q_{u \rightarrow v}$，这个值与子节点 $v$ 的 子树外节点通电传导给 $u$ 的概率 的并是 $p_u$ 。而现在要求 子树外节点通电传导给 $u$ 的概率 。 这个问题可以转化为——若已知 $P \left( B\right),P \left( C\right)$ 的值，且 $P\left( A \cup B \right) = P \left ( C\right)$，怎么求 $P \left( A \right)$？ 用刚才的公式倒推即可： \large { P \left( A \cup B\right) = P \left( C \right) } \large { P\left( A \right) + P\left( B \right) - P\left( A \right) \times P\left( B \right) = P\left( C \right) } \large { P\left( A \right) - P\left( A \right) \times P\left( B \right) = P\left( C \right) -P\left( B \right) } \large { P\left( A \right) \times \left( 1 - P\left( B \right) \right) = P\left( C \right) -P\left( B \right) } \large {\begin{aligned} & P\left( A \right) = \frac{P\left( C \right) -P\left( B \right)}{1 - P\left( B \right)} & \left( P \left( B \right) \neq 1 \right) \end{aligned} }根据这个式子求出 子树外节点通电传导给 $u$ 的概率，乘上 $q_{u \rightarrow v}$ 就是 子树外节点通电传导给 $v$ 的概率 了，再求 $p_v$ 与它的并，就是这个状态的值。值得注意的是，如果上述式子中的 $P\left( B \right) = 1$（即 $p_v \times q_{u \rightarrow v} = 1$），显然是不能直接除的，但因为 $0 \leq p_v,q_{u \rightarrow v} \leq 1$，所以 $p_v = q_{u \rightarrow v} = 1$，在这种情况下可以直接跳过，不进行转移（$p_v$ 一定通电）。最后把所有节点通电的概率加起来即为答案。 与第一次 $\rm{dfs}$ 不同的是：第一次是由子树合并答案，需要递归到底，返回时再转移；第二次是由父节点更新答案，遍历完整棵树即可。时间复杂度为 $O(n)​$ 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;const int MAXN = 5e5, MAXM = 5e5;const double eps = 1e-7;int n, tot, head[MAXN + 5];double ans, p[MAXN + 5], x[MAXN + 5];struct Edge &#123; int next, to; double dis;&#125; e[(MAXM &lt;&lt; 1) + 5];inline void addEdge(int u, int v, double w) &#123; e[++tot] = (Edge) &#123; head[u], v, w &#125;; head[u] = tot;&#125;inline double cup(double a, double b) &#123;//求两个概率的并 a∪b return a + b - a * b;&#125;inline double calc(double a, double b) &#123;//已知 P(b) 以及 P(a)∪P(b)，求 P(a) return (a - b) / (1.0 - b);&#125;void dfsUp(int u, int fa) &#123;//第一次 dfs，子树内节点传导电 for (int v, i = head[u]; v = e[i].to, i; i = e[i].next) &#123; if (v == fa) continue; dfsUp(v, u);//递归到底层 double q = e[i].dis; p[u] = cup(p[u], p[v] * q);//转移 &#125;&#125;void dfsDown(int u, int fa) &#123;//第二次 dfs，子树外节点传导电 ans += p[u];//累加答案 for (int v, i = head[u]; v = e[i].to, i; i = e[i].next) &#123; if (v == fa) continue; double q = e[i].dis; if (fabs(p[v] * q - 1.0) &lt; eps) &#123; dfsDown(v, u); continue;//跳过并向下搜 &#125; p[v] = cup(p[v], calc(p[u], p[v] * q) * q);//转移 dfsDown(v, u);//遍历整棵树 &#125;&#125;int main() &#123; read(n); for (int i = 1; i &lt; n; ++i) &#123; int u, v; double w; read(u), read(v), read(w); w *= 0.01;//q% addEdge(u, v, w), addEdge(v, u, w);//连无向边 &#125; for (int i = 1; i &lt;= n; ++i) &#123; read(p[i]); p[i] *= 0.01;//初始概率 为 节点自己充电的概率 &#125; dfsUp(1, 0); dfsDown(1, 0);//根节点为 1 printf("%.6lf\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>动态规划</tag>
        <tag>SHOI</tag>
        <tag>2014</tag>
        <tag>概率期望</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P1122」最大子树和]]></title>
    <url>%2Fproblems%2Fluogu-p1122%2F</url>
    <content type="text"><![CDATA[Description给定一棵 $n\ (1 \leq n \leq 16000)$ 个点的树，节点 $i$ 的点权为 $val_i\ \left( \left | \sum\limits_{i=1}^n val_i \right | \leq 2^{31}-1 \right)$，现在要从中找到一个联通分量，使它们的点权和最大， 求这个最大值。 Source[Luogu]P1122 Solution看到这种求最大值的题目，很容易想到 树形DP 。 状态： 用 $f_u$ 表示在节点 $u$ 的子树中，包括 $u$ 的联通分量的最大点权和。 初始： \large { f_u = val_u }由状态可知，$f_u$ 一定取了节点 $u$，所以最小值为 $val_u$ 。 转移： \large { f_u = \max \left( f_u, f_u + f_v \right) }如果加上包括子节点 $v$ 的联通分量后，比原来的值大，显然加上更优。 答案： \large {\begin{aligned} & \max \begin{Bmatrix} f_u \end{Bmatrix} & \left( 1 \leq u \leq n \right) \end{aligned}}不能判断 $f_{root}$（$root$ 表示根节点）就是答案，因为最优答案不一定取根节点，可能取其它节点（不选根节点）的方案更优，所以要取最大值。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1, len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 16000, MAXM = 16000;int n, tot, ans, val[MAXN + 5], head[MAXN + 5], f[MAXN + 5];struct Edge &#123; int next, to;&#125; e[(MAXM &lt;&lt; 1) + 5];inline void addEdge(int u, int v) &#123; e[++tot] = (Edge) &#123; head[u], v &#125;; head[u] = tot;&#125;void dfs(int u, int fa) &#123; f[u] = val[u];//初始 for (int v, i = head[u]; v = e[i].to, i; i = e[i].next) &#123; if (v == fa) continue; dfs(v, u); f[u] = max(f[u], f[u] + f[v]);//转移 &#125; ans = max(ans, f[u]);//取最大值 &#125;int main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) read(val[i]); for (int i = 1; i &lt; n; ++i) &#123; int u, v; read(u), read(v); addEdge(u, v), addEdge(v, u);//无向边 &#125; dfs(1, 0);//假设根节点为 1 write(ans); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>动态规划</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2016」战略游戏]]></title>
    <url>%2Fproblems%2Fluogu-p2016%2F</url>
    <content type="text"><![CDATA[Description给定一棵 $n\ (1 \leq n \leq 1500)$ 个点的树，编号为 $0 \sim n - 1$，现在需要从中选择若干个点，每个点可以覆盖所有连向它的边，求覆盖所有边至少需要几个点。 Source[Luogu]P2016 Solution考虑用 树形DP 求解。 状态： 用 $f_{0,u}$ 表示在节点 $u$ 的子树中，覆盖所有边但不选节点 $u$ 最少需要几个点； 用 $f_{1,u}$ 表示在节点 $u$ 的子树中，覆盖所有边且选了节点 $u$ 最少需要几个点。 初始： 无 转移： \large { f_{0,u} = \sum\limits_{v \in son_u} f_{1,v} }若不选节点 $u$，则节点 $u$ 的儿子 $v$ 必须选，这样才能覆盖到边 $u \rightarrow v$ 。 \large { f_{1,u} = \sum\limits_{v \in son_u} \min \left(f_{0, v} , f_{1, v} \right) + 1 }若选节点 $u$，则边 $u \rightarrow v$ 一定能被覆盖，节点 $v$ 可选可不选，显然取节点 $v$ 选 和 不选 的较小值更优，并加上 $1$（算上节点 $u$）。 答案： \large{\begin{aligned} &\min \left(f_{0,root},f_{1,root} \right) && (root\ 表示根节点) \end{aligned}}考虑在根节点的子树中（整棵树），根节点 选 或 不选，取较小值即是答案。因为本题没有给出根节点，所以直接设 $1​$ 号节点为根，连无向边即可。 时间复杂度为 $O(n)$ 。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1, len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1500, MAXM = 1500;int n, tot, head[MAXN + 5], f[2][MAXN + 5];struct Edge &#123; int next, to;&#125; e[(MAXM &lt;&lt; 1) + 5];inline void addEdge(int u, int v) &#123; e[++tot] = (Edge) &#123; head[u], v &#125;; head[u] = tot;&#125;void dfs(int u, int fa) &#123; f[1][u] = 1; for (int v, i = head[u]; v = e[i].to, i; i = e[i].next) &#123; if (v == fa) continue; dfs(v, u); f[0][u] += f[1][v]; f[1][u] += min(f[0][v], f[1][v]);//转移 &#125;&#125;int main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) &#123; int u, v, k; read(u); ++u;//习惯点的编号从 1 开始 for (read(k); k; --k) &#123; read(v); ++v; addEdge(u, v), addEdge(v, u);//连无向边 &#125; &#125; dfs(1, 0);//设根节点为 1 号节点 write(min(f[0][1], f[1][1])); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>动态规划</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2014」选课]]></title>
    <url>%2Funcategorized%2Fluogu-p2014%2F</url>
    <content type="text"><![CDATA[Description现在有 $n\ (1\leq n \leq 300)$ 个点，其中节点 $i\ (1 \leq i \leq n)$ 的父节点为 $k_i\ (0\leq k_i \leq n)$，权值为 $s_i\ (1 \leq s_i \leq 20)$，$k_i = 0$ 表示这个点没有父节点。现在需要从中选择 $m\ (1 \leq m \leq 300)$ 个点，你能选择一个点当且仅当 这个点的所有祖先节点已选 或 这个点没有父节点，求这些点的最大点权和。 Source[Luogu]P2014 Solution不止一个点没有父节点，说明这道题的图是一个 森林（由很多树组成）。一种经典的解决方法是，我们把每棵树的根连向一个虚拟节点—— $0$ 号节点（即 $k_i = 0$ 时依然连边）。我们把 $0$ 号节点看作必选的点，也就是说，一共要选 $m + 1​$ 个点。这样就把一个森林转化成了一棵树。 这是一个有树形依赖的背包问题，所以考虑在转化后的树上做 树形DP（树形背包）。 状态： 用 $f_{u,j,k}$ 表示从 $u$ 的前 $j$ 个子节点的子树中选出 $k$ 个点的最大点权和。 初始： \large { f_{u, 0, 1} = s_u }从节点 $u$ 的前 $0$ 个子节点中选出 $1$ 个点的答案为 $s_u$（根据题目中的条件：只有选了节点 $u​$ 才能继续选其子树中的点）。 转移： \large { f_{u,j,k} = \max \begin{Bmatrix} f_{u, j - 1, k - l} + f_{v, sum_v, l} \end{Bmatrix}\\[2ex] \left( 0 \leq l \leq \min\left(k - 1,size_v \right), v \in son_u \right) }其中 $v​$ 是 $u​$ 的第 $j​$ 个子节点，$sum_v​$ 表示 $v​$ 的子节点个数，$size_v​$ 表示 $v​$ 的子树大小。在 $u​$ 的子树中，从 $u​$ 的前 $j​$ 个子节点的子树中选出 $k​$ 个点时，可以先从前 $j - 1​$ 个子节点的子树中选择 $k - l​$ 个点，然后在第 $j​$ 个子节点 $v​$ 的子树中选择 $l​$ 个点，枚举 $l​$，取最大值即是该状态的答案。 答案： \large{\begin{aligned} &f_{root,sum_{root},m + 1} && (root\ 表示根节点) \end{aligned}}答案为在根节点的子树中，从根节点的所有儿子（$sum_{root}$，即根节点的儿子个数）中选出 $m + 1$ 个点的最大点权和。此题中根节点为 $0​$ 号节点（虚点）。 然而 $3$ 维的空间可能会开不下，考虑如何优化空间复杂度。 很容易发现，$u$ 是从子节点 $v$ 的状态合并而来的，所以在处理 $u$ 之前 $v$ 的状态都是已知的（即 $f_{v,sum_v,l}$ 已知）。同时状态转移与 $k$ 枚举的顺序无关，因为枚举 $k$ 时 $j - 1$ 的所有状态都已经求出来了。除此之外，状态 $k - l$ 一直在 $l$ 的前面，因此我们考虑压掉 $j​$ 这一维。 状态： 用 $f_{u,j}$ 表示在 $u$ 的子树中，选出 $j$ 个点的最大点权和。 初始： \large { f_{u,1} = s_u }转移： \large { f_{u,j} = \max \begin{Bmatrix} f_{u, j - k} + f_{v, k} \end{Bmatrix}\\[2ex] \left( 0 \leq k \leq \min\left(j - 1,size_v \right), v \in son_u \right) }$size_v$ 表示 $v$ 的子树大小。注意 $j$ 应该倒叙枚举，这样做的实质是：$f_{u,j-k}$ 仍然是上一次转移的状态（还没被更新），即 $f_{u-1,j-k}$ 。 答案： \large{\begin{aligned} &f_{root,m + 1} && (root\ 表示根节点) \end{aligned}}时间复杂度不是很好证明，应该为 $O(nm)$ 。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1, len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 300, MAXM = 300;int n, m, tot, k, s[MAXN + 5], head[MAXN + 5], size[MAXN + 5], f[MAXN + 5][MAXN + 5];struct Edge &#123; int next, to;&#125; e[(MAXM &lt;&lt; 1) + 5];inline void addEdge(int u, int v) &#123; e[++tot] = (Edge) &#123; head[u], v &#125;; head[u] = tot;&#125;void dfs(int u, int depth) &#123; if (depth &gt; m) return;//小优化：所选的点一定在前 m 层（节点 0 算第 0 层） size[u] = 1; f[u][1] = s[u];//初始 for (int v, i = head[u]; v = e[i].to, i; i = e[i].next) &#123; dfs(v, depth + 1); size[u] += size[v];//节点 u 的子树大小 for (int j = min(m + 1, size[u]); j; --j)//注意压维后要倒序枚举 for (int k = 0; k &lt;= min(j - 1, size[v]); ++k) f[u][j] = max(f[u][j], f[u][j - k] + f[v][k]);//转移 &#125;&#125;int main() &#123; read(n), read(m); for (int i = 1; i &lt;= n; ++i) &#123; read(k), read(s[i]); addEdge(k, i);//k 是 i 的父节点，连一条有向边 k -&gt; i &#125; dfs(0, 0);//根节点是 0 write(f[0][m + 1]);//答案 putchar('\n'); return 0;&#125;]]></content>
      <tags>
        <tag>Luogu</tag>
        <tag>动态规划</tag>
        <tag>树形DP</tag>
        <tag>背包问题</tag>
        <tag>CTSC</tag>
        <tag>1997</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2458」「SDOI2006」保安站岗]]></title>
    <url>%2Fproblems%2Fluogu-p2458%2F</url>
    <content type="text"><![CDATA[Description给定一棵 $n\ (1 \leq n \leq 1500)$ 个节点的树，点 $i\ (1 \leq i \leq n)$ 的花费是 $val_i\ (1 \leq val_i \leq 10^4)$，现在需要从中选择若干个点，这些点能够覆盖与它们相连的点，求覆盖树上所有点的最小代价是多少。 Source[Luogu]P2458 Solution考虑 树形DP 。 状态： 用 $f_{0,u}​$ 表示在节点 $u​$ 的子树中，所有点都已经被覆盖，其中节点 $u​$ 被自己覆盖的最小代价； 用 $f_{1,u}$ 表示在节点 $u$ 的子树中，所有点都已经被覆盖，其中节点 $u​$ 被它儿子覆盖的最小代价； 用 $f_{2,u}​$ 表示在节点 $u​$ 的子树中，除节点 $u​$ 外的点都已经被覆盖，其中节点 $u​$ 将被它父亲覆盖的最小代价。 初始： 无 转移： \large { f_{0,u} = val_u + \sum\limits_{v \in son_u} \min \begin{Bmatrix} f_{0,v},f_{1,v},f_{2,v} \end{Bmatrix} }若节点 $u$ 被自己覆盖，则至少要花费 $val_u$ 的代价，同时子节点 $v$ 的状态不需要考虑，因为无论怎样 $v$ 都会被 $u$ 覆盖，所以还需要加上 子节点所有状态的最小值 。 \large {f_{1,u}=\left\{\begin{matrix}\begin{aligned} &\sum\limits_{v \in son_u} \min \left(f_{0,v}, f_{1,v}\right) \\[2ex] &\sum\limits_{v \in son_u} \min \left(f_{0,v}, f_{1,v}\right) + \min \begin{Bmatrix} f_{0,v} - f_{1,v} \end{Bmatrix} & (\operatorname{if} \ \forall f_{0,v} > f_{1,v}) \end{aligned}\end{matrix}\right.}若节点 $u$ 被它儿子覆盖，则子节点 $v$ 不可能被它的父节点 $u$ 覆盖，因此需要取子节点 被自己覆盖 和 被其儿子 覆盖的较小值。但是所取的子节点肯定不能全部被自己的儿子覆盖，否则节点 $u$ 将不会被覆盖。因此如果所有的 $f_{1,v}$ 都比 $f_{0,v}$ 更优，那么需要从中挑出一个 $f_{1,v}$，把它变成 $f_{0,v}$，这样才能满足 $u$ 被 $v$ 覆盖。为了让变化所花费的代价更小，我们需要找到 $f_{0,v}$ 与 $f_{1,v}$ 的最小差值，加上原来的代价即可。 \large { f_{2,u} = \sum\limits_{v \in son_u} \min \left( f_{0,v}, f_{1,v} \right) }若节点 $u$ 被它父亲覆盖，则子节点 $v$ 不可能被它的父节点 $u$ 覆盖，所以只需要加上子节点 被自己覆盖 和 被其儿子 覆盖的较小值即可。 答案： \large{\begin{aligned} &\min \left(f_{0,root},f_{1,root} \right) && (root\ 表示根节点) \end{aligned}}因为根节点没有父亲，所以不需要考虑根节点被父亲覆盖的情况，答案应该取根节点 被自己覆盖 和 被儿子覆盖 的较小值。因为本题是棵无根树，所以直接设 $1$ 号节点为根，连无向边即可。 时间复杂度为 $O(n)$ 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1, len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1500, MAXM = 1500;int n, m, tot, val[MAXN + 5], head[MAXN + 5], f[3][MAXN + 5];struct Edge &#123; int next, to;&#125; e[(MAXM &lt;&lt; 1) + 5];inline void addEdge(int u, int v) &#123; e[++tot] = (Edge) &#123; head[u], v &#125;; head[u] = tot;&#125;void dfs(int u, int fa) &#123; f[0][u] = val[u]; bool flag = 1; int minn = 0x7fffffff; for (int v, i = head[u]; v = e[i].to, i; i = e[i].next) &#123; if (v == fa) continue; dfs(v, u); f[0][u] += min(f[0][v], min(f[1][v], f[2][v])); f[1][u] += min(f[0][v], f[1][v]); f[2][u] += min(f[0][v], f[1][v]);//转移 if (f[0][v] &lt;= f[1][v]) flag = 0;//检查是否所有的 f[0][v] 都大于 f[1][v] if (flag) minn = min(minn, f[0][v] - f[1][v]);//如果是，记录最小其差值 &#125; if (flag) f[1][u] += minn;//如果全部选择了 f[1][v]，还要加上最小差值 &#125;int main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) &#123; int u, v; read(u), read(val[u]), read(m);//注意读入的是节点 u 的点权而不是 i 的点权 for (int j = 1; j &lt;= m; ++j) &#123; read(v); addEdge(u, v), addEdge(v, u); &#125;//连无向边 &#125; dfs(1, 0);//以 1 号节点作为根节点 write(min(f[0][1], f[1][1])); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>SDOI</tag>
        <tag>动态规划</tag>
        <tag>树形DP</tag>
        <tag>2006</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P1352」没有上司的舞会]]></title>
    <url>%2Fproblems%2Fluogu-p1352%2F</url>
    <content type="text"><![CDATA[Description给定一棵 $n\ (1 \leq n \leq 6 \times 10^3)$ 个点的树，点 $i\ (1 \leq i \leq n)$ 的点权为 $r_i\ (-128 \leq r_i \leq 127)$ 。现在需要从中选取若干个点，使这些点的点权和最大，但规定子节点和父节点不能同时选，求最大点权和。 Source[Luogu]P1352 Solution考虑 树形DP 。 状态： 用 $f_{0,u}$ 表示在节点 $u$ 的子树中，不取 $u$ 的最大点权和； 用 $f_{1,u}$ 表示在节点 $u$ 的子树中，取了 $u$ 的最大点权和。 初始： 无 转移： \large{ f_{0,u} = \sum\limits_{v \in son_u} \max \left( f_{0,v}, f_{1,v}\right) }当不取节点 $u$ 时，$u$ 的子节点取和不取都可以，显然取其中较大的更优，所以 $f_{0,u}$ 应当等于 所有子节点 取 与 不取 的 较大值 之和。 \large{ f_{1,u} = r_u + \sum\limits_{v \in son_u} f_{0,v} }当取节点 $u$ 时，$f_{1,u}$ 的最小值为 节点 $u$ 的点权，同时 $u$ 的子节点只能不取，所以 $f_{1,u}​$ 还应当加上 所有子节点不取 的和。 答案： \large{\begin{aligned} &\max \left(f_{0,root},f_{1,root} \right) && (root\ 表示根节点) \end{aligned}}答案是在根节点的子树中，取 和 不取 根节点的较大值。 时间复杂度为 $O(n)$ 。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1, len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 6000;int n, l, k, tot, root, r[MAXN + 5], cnt[MAXN + 5], head[MAXN + 5], f[2][MAXN + 5];struct Edge &#123; int next, to;&#125; e[(MAXN &lt;&lt; 1) + 5];inline void addEdge(int u, int v) &#123; e[++tot] = (Edge) &#123; head[u], v &#125;; head[u] = tot;&#125;void dfs(int u) &#123; f[1][u] = r[u]; for (int v, i = head[u]; v = e[i].to, i; i = e[i].next) &#123; dfs(v); f[0][u] += max(f[0][v], f[1][v]); f[1][u] += f[0][v]; &#125;//转移 &#125;int main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) read(r[i]); for (int i = 1; i &lt; n; ++i) &#123; read(l), read(k);//k 是 l 的上司 addEdge(k, l);//连一条有向边 k -&gt; l ++cnt[l];//l 的上司数量 &#125; for (int i = 1; i &lt;= n; ++i) if (!cnt[i]) &#123; root = i; break; &#125;//找根节点（没有父亲的节点） dfs(root); write(max(f[0][root], f[1][root]));//答案 putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>动态规划</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LaTeX/MathJax 字体美化]]></title>
    <url>%2Fothers%2Flatex-mathjax-gong-shi-zi-ti-mei-hua%2F</url>
    <content type="text"><![CDATA[前言本文主要介绍 $\LaTeX$，$\text{MathJax}$ 语法的字体美化，包括 字体种类，字体大小，字体特效，字体颜色 等。 字体种类设置统一表示方法：\字体种类{文本} 字体种类 表示方法 预览 默认字体 ABCDEFGHIJKLMNOPQRSTUVWXYZ $ABCDEFGHIJKLMNOPQRSTUVWXYZ$ abcdefghijklmnopqrstuvwxyz $abcdefghijklmnopqrstuvwxyz$ 数学斜体 \mit{ABCDEFGHIJKLMNOPQRSTUVWXYZ} $\mit{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ \mit{abcdefghijklmnopqrstuvwxyz} $\mit{abcdefghijklmnopqrstuvwxyz}$ 意大利体 \it{ABCDEFGHIJKLMNOPQRSTUVWXYZ} $\it{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ \it{abcdefghijklmnopqrstuvwxyz} $\it{abcdefghijklmnopqrstuvwxyz}$ 罗马体 \rm{ABCDEFGHIJKLMNOPQRSTUVWXYZ} $\rm{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ \rm{abcdefghijklmnopqrstuvwxyz} $\rm{abcdefghijklmnopqrstuvwxyz}$ 花体 \cal{ABCDEFGHIJKLMNOPQRSTUVWXYZ} $\cal{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ \cal{abcdefghijklmnopqrstuvwxyz} $\cal{abcdefghijklmnopqrstuvwxyz}$ 打字机体 \tt{ABCDEFGHIJKLMNOPQRSTUVWXYZ} $\tt{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ \tt{abcdefghijklmnopqrstuvwxyz} $\tt{abcdefghijklmnopqrstuvwxyz}$ 粗体 \bf{ABCDEFGHIJKLMNOPQRSTUVWXYZ} $\bf{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ \bf{abcdefghijklmnopqrstuvwxyz} $\bf{abcdefghijklmnopqrstuvwxyz}$ 黑板粗体 \Bbb{ABCDEFGHIJKLMNOPQRSTUVWXYZ} $\Bbb{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ \Bbb{abcdefghijklmnopqrstuvwxyz} $\Bbb{abcdefghijklmnopqrstuvwxyz}$ 等线体 \sf{ABCDEFGHIJKLMNOPQRSTUVWXYZ} $\sf{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ \sf{abcdefghijklmnopqrstuvwxyz} $\sf{abcdefghijklmnopqrstuvwxyz}$ 旧德式体 \frak{ABCDEFGHIJKLMNOPQRSTUVWXYZ} $\frak{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ \frak{abcdefghijklmnopqrstuvwxyz} $\frak{abcdefghijklmnopqrstuvwxyz}$ 手写体 \scr{ABCDEFGHIJKLMNOPQRSTUVWXYZ} $\scr{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ \scr{abcdefghijklmnopqrstuvwxyz} $\scr{abcdefghijklmnopqrstuvwxyz}$ 字体大小设置统一表示方法：\字体大小{文本} 字体大小 字宽(pt) 表示方法 预览 小初 $36$ pts \Huge{小初字体(36pts)} $\Huge{小初字体(36pts)}$ 一号 $27.5$ pts \huge{一号字体(27.5pts)} $\huge{一号字体(27.5pts)}$ 二号 $21$ pts \LARGE{二号字体(21pts)} $\LARGE{二号字体(21pts)}$ 三号 $15.75$ pts \Large{三号字体(15.75pts)} $\Large{三号字体(15.75pts)}$ 四号 $13.75$ pts \large{四号字体(13.75pts)} $\large{四号字体(13.75pts)}$ 小四 $12$ pts \normalsize{小四字体(12pts)} $\normalsize{小四字体(12pts)}$ 默认 $12$ pts 默认字体(12pts) $默认字体(12pts)$ 五号 $10.5$ pts \small{五号字体(10.5pts)} $\small{五号字体(10.5pts)}$ 六号 $7.875$ pts \scriptsize{六号字体(7.875pts)} $\scriptsize{六号字体(7.875pts)}$ 七号 $5.25$ pts \tiny{七号字体(5.25pts)} $\tiny{七号字体(5.25pts)}$ 字体特效设置 字体特效 表示方法 预览 加粗 \bf{加粗} $\bf{加粗}$ 下划线 \underline{下划线}​ $\underline{下划线}$ 使用前声名删除线 \require{enclose} $\require{enclose}$ 删除线 \enclose{horizontalstrike}{删除线} $\enclose{horizontalstrike}{删除线}$ \enclose{verticalstrike}{删\\除\\线} $\enclose{verticalstrike}{删\\除\\线}$ \enclose{updiagonalstrike}{删除线} $\enclose{updiagonalstrike}{删除线}$ \enclose{downdiagonalstrike}{删除线} $\enclose{downdiagonalstrike}{删除线}$ \enclose{updiagonalstrike,downdiagonalstrike}{删除线} $\enclose{updiagonalstrike,downdiagonalstrike}{删除线}$ \enclose{horizontalstrike,verticalstrike}{\;\ 删\\删除线\\\;\ 线} $\enclose{horizontalstrike,verticalstrike}{\; 删\\删除线\\\; 线}$ \enclose{updiagonalstrike,downdiagonalstrike,horizontalstrike,verticalstrike}{删除线} $\enclose{updiagonalstrike,downdiagonalstrike,horizontalstrike,verticalstrike}{删除线}$ 补充：删除线可以多种形式搭配使用 字体颜色设置统一表示方法：\color{颜色}{文本} 颜色 表示方法 预览 黑色(black) \color{black}{黑色(\text{black})} $\color{black}{黑色(\text{black})}$ 红色(red) \color{red}{红色(\text{red})} $\color{red}{红色(\text{red})}$ 黄色(yellow) \color{yellow}{黄色(\text{yellow})} $\color{yellow}{黄色(\text{yellow})}$ 蓝色(blue) \color{blue}{蓝色(\text{blue})} $\color{blue}{蓝色(\text{blue})}$ 灰色(grey) \color{grey}{灰色(\text{grey})} $\color{grey}{灰色(\text{grey})}$ 白色(white) \color{white}{白色(\text{white})} $\color{white}{白色(\text{white})}$ 绿色(green) \color{green}{绿色(\text{green})} $\color{green}{绿色(\text{green})}$ 紫色(green) \color{purple}{紫色(\text{purple})} $\color{purple}{紫色(\text{purple})}$ 紫红色(maroon) \color{maroon}{紫红色(\text{maroon})} $\color{maroon}{紫红色(\text{maroon})}$ 橄榄绿(olive) \color{olive}{橄榄绿(\text{olive})} $\color{olive}{橄榄绿(\text{olive})}$ 蓝绿色(teal) \color{teal}{蓝绿色(\text{teal})} $\color{teal}{蓝绿色(\text{teal})}$ 银色(silver) \color{silver}{银色(\text{silver})} $\color{silver}{银色(\text{silver})}$ 浅绿色(lime) \color{lime}{浅绿色(\text{lime})} $\color{lime}{浅绿色(\text{lime})}$ 藏青色(navy) \color{navy}{藏青色(\text{navy})} $\color{navy}{藏青色(\text{navy})}$]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
        <tag>MathJax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 3884」上帝与集合的正确用法]]></title>
    <url>%2Fproblems%2Fbzoj-3884%2F</url>
    <content type="text"><![CDATA[Description给定 $T\ (T\leq 10^3)$ 组数据，每组数据包含一个正整数 $p\ (1 \leq p \leq 10^7)$，求 $2^{2^{2 \cdots}}(无限个 2) \bmod p$ 的值。 Source[BZOJ]3884 Solution 前置知识： 常见积性函数 - 欧拉函数 - 线性筛求欧拉函数 常用的质数相关定理 - 扩展欧拉定理 在此题中，指数 $b = 2^{2^{2\cdots}}$ 一定满足 $b \geq \varphi(p)​$，所以我们通过 扩展欧拉定理： \begin{aligned} a^b &\equiv a^{b \bmod \varphi(p) + \varphi(p)} \pmod p & b \geq \varphi(p)\\ \end{aligned}得到 2^{2^{2\cdots} } \bmod p=2^{\left(2^{2 \cdots} \bmod \varphi(p)+\varphi(p)\right)} \bmod p设 $f(p) = 2^{2^{2\cdots}} \bmod p​$，则有 f(p)=2^{f(\varphi(p)) + \varphi(p)}\bmod p我们就成功地化简了问题——把求 $f(p)$ 转化为求 $f(\varphi(p))$ 。 这个式子可以一直递归下去，直到 $p = 1​$ 时返回 $f(1)=2^{2^{2 \cdots}} \bmod \varphi(1) = 0​$ 。总时间复杂度为 $O(p + T\log^2 p)​$ 。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1, len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1e6, MAXP = 1e7;int t, p, cnt, prime[MAXN + 5], phi[MAXP + 5];bool isNotPrime[MAXP + 5];inline void getPhi(int n) &#123; phi[1] = 1; isNotPrime[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; if (!isNotPrime[i]) &#123; prime[++cnt] = i; phi[i] = i - 1; &#125; for (int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n; ++j) &#123; isNotPrime[i * prime[j]] = 1; if (i % prime[j] == 0) &#123; phi[i * prime[j]] = phi[i] * prime[j]; break; &#125; else phi[i * prime[j]] = phi[i] * (prime[j] - 1); &#125; &#125;&#125;//线性筛求 φ(1) ~ φ(n) inline int quickPow(int x, int p, int mod) &#123; int res = 1; for (; p; p &gt;&gt;= 1, x = (LL) x * x % mod) if (p &amp; 1) res = (LL) res * x % mod; return res;&#125;//快速幂 int f(int p) &#123; if (p == 1) return 0;//f(1) = 0 return quickPow(2, f(phi[p]) + phi[p], p);&#125;//递归求解 int main() &#123; getPhi(MAXP); for (read(t); t; --t) &#123; read(p); write(f(p));//答案为 f(p) putchar('\n'); &#125; return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>数论数学</tag>
        <tag>欧拉定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P4139」上帝与集合的正确用法]]></title>
    <url>%2Fproblems%2Fluogu-p4139%2F</url>
    <content type="text"><![CDATA[Description给定 $T\ (T\leq 10^3)$ 组数据，每组数据包含一个正整数 $p\ (1 \leq p \leq 10^7)$，求 $2^{2^{2 \cdots}}(无限个 2) \bmod p$ 的值。 Source[Luogu]P4139 Solution 前置知识： 常见积性函数 - 欧拉函数 - 线性筛求欧拉函数 常用的质数相关定理 - 扩展欧拉定理 在此题中，指数 $b = 2^{2^{2\cdots}}$ 一定满足 $b \geq \varphi(p)​$，所以我们通过 扩展欧拉定理： \begin{aligned} a^b &\equiv a^{b \bmod \varphi(p) + \varphi(p)} \pmod p & b \geq \varphi(p)\\ \end{aligned}得到 2^{2^{2\cdots} } \bmod p=2^{\left(2^{2 \cdots} \bmod \varphi(p)+\varphi(p)\right)} \bmod p设 $f(p) = 2^{2^{2\cdots}} \bmod p​$，则有 f(p)=2^{f(\varphi(p)) + \varphi(p)}\bmod p我们就成功地化简了问题——把求 $f(p)$ 转化为求 $f(\varphi(p))$ 。 这个式子可以一直递归下去，直到 $p = 1​$ 时返回 $f(1)=2^{2^{2 \cdots}} \bmod \varphi(1) = 0​$ 。总时间复杂度为 $O(p + T\log^2 p)​$ 。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1, len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1e6, MAXP = 1e7;int t, p, cnt, prime[MAXN + 5], phi[MAXP + 5];bool isNotPrime[MAXP + 5];inline void getPhi(int n) &#123; phi[1] = 1; isNotPrime[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; if (!isNotPrime[i]) &#123; prime[++cnt] = i; phi[i] = i - 1; &#125; for (int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n; ++j) &#123; isNotPrime[i * prime[j]] = 1; if (i % prime[j] == 0) &#123; phi[i * prime[j]] = phi[i] * prime[j]; break; &#125; else phi[i * prime[j]] = phi[i] * (prime[j] - 1); &#125; &#125;&#125;//线性筛求 φ(1) ~ φ(n) inline int quickPow(int x, int p, int mod) &#123; int res = 1; for (; p; p &gt;&gt;= 1, x = (LL) x * x % mod) if (p &amp; 1) res = (LL) res * x % mod; return res;&#125;//快速幂 int f(int p) &#123; if (p == 1) return 0;//f(1) = 0 return quickPow(2, f(phi[p]) + phi[p], p);&#125;//递归求解 int main() &#123; getPhi(MAXP); for (read(t); t; --t) &#123; read(p); write(f(p));//答案为 f(p) putchar('\n'); &#125; return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>数论数学</tag>
        <tag>欧拉定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 1407」「NOI2002」Savage]]></title>
    <url>%2Fproblems%2Fbzoj-1407%2F</url>
    <content type="text"><![CDATA[Descripion岛上有 $m$ 个洞穴，顺时针编号为 $1 \sim m$ 。岛上有 $n\ (1 \leq n \leq 15)$ 个野人分别住在 $c_1,c_2,\ldots,c_n\ (1 \leq c_i \leq 100)$ 中。以后每年，第 $i$ 个野人会沿顺时针向前走 $p_i\ (1 \leq p_i \leq 100)$ 个洞住下来，其中第 $i$ 个野人可以生存 $l_i$ 年。没有 $2$ 个野人能在有生之年生存在同一个洞穴中，求洞穴个数 $m\ (m \leq 10^6)$ 的最小值。 Source[BZOJ]1407 Solution 前置知识： 扩展欧几里得(exgcd)算法 对于 野人 $i$ 和 野人 $j$ $(i \neq j)$，假设经过 $x$ 天之后他们会在同一个洞穴相遇，那么可以得出方程： c_i + p_ix \equiv c_j + p_jx \pmod m化简方程，得到 (p_i - p_j)x \equiv c_j - c_i \pmod m这个方程等价于 (p_i - p_j)x + m \times y = c_j - c_i显然我们可以用 exgcd(扩展欧几里得) 算法求出方程 $(p_i - p_j)x + m \times y = \gcd(p_i-p_j,m)​$ 的一个解 $x’​$ 。 如果 $\gcd(p_i-p_j,m) \nmid c_j-c_i$，说明 $x$ 无解，野人 $i,j​$ 永远不会相遇。 若有解，我们求出 $x$ 的最小正整数解，即 x = \left( x' \times \frac{c_j - c_i}{\gcd(p_i-p_j,m)} \bmod \frac{m}{\gcd(p_i-p_j,m)} + \frac{m}{\gcd(p_i-p_j,m)} \right) \bmod \frac{m}{\gcd(p_i-p_j,m)}如果 $x &gt; \min(l_i,l_j)$，说明在他们相遇之前，$i, j$ 中会有至少一个野人死亡，所以也是可行的。 如果 $x \leq \min(l_i,l_j)​$，说明 野人 $i,j​$ 会在死亡前相遇，这个 $m​$ 不可行。 我们只需要枚举每一个可能的 $m$（题目保证 $m \leq 10^6$），枚举每一对野人 $(i,j)$，用 exgcd 求解 $x$ 并判断这个 $m$ 是否满足要求。还有一些小细节：用 exgcd 时必须保证 $p_i \geq p_j$，因为 $\gcd$ 只对 非负整数 有意义。总时间复杂度为 $O( n^2m\log p_i)​$ 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1, len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 15, MAXM = 1e6;int n, maxn, c[MAXN + 5], p[MAXN + 5], l[MAXN + 5];int exGcd(int a, int b, int &amp;x, int &amp;y) &#123; if (b == 0) &#123; x = 1, y = 0; return a; &#125; int d = exGcd(b, a % b, y, x); y -= a / b * x; return d;&#125;inline bool judge(int m) &#123;//判断这个 m 是否可行 for (int i = 1; i &lt; n; ++i) for (int j = i + 1; j &lt;= n; ++j) &#123;//枚举每一对野人 int pi = p[i], pj = p[j], ci = c[i], cj = c[j], x, y, d; if (pi &lt; pj) &#123; swap(pi, pj); swap(ci, cj); &#125; //如果 pi &lt; pj，不满足 gcd 要求，交换 d = exGcd(pi - pj, m, x, y);//d = gcd(pi - pj, m) if ((cj - ci) % d != 0) continue;//x 无解，野人 i,j 不可能相遇 int p = m / d; x *= (cj - ci) / d; x = (x % p + p) % p;//x 的最小整数解 if (x &lt;= min(l[i], l[j])) return 0;//这个 m 不符合题意 &#125; return 1;&#125;int main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) &#123; read(c[i]), read(p[i]), read(l[i]); maxn = max(maxn, c[i]);//已有洞穴中的编号最大的洞穴 &#125; for (int i = maxn; i &lt;= MAXM; ++i)//枚举洞穴个数，注意最小值为编号最大的洞穴 if (judge(i)) &#123; write(i); putchar('\n'); return 0; &#125; return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>数论数学</tag>
        <tag>NOI</tag>
        <tag>2002</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2421」「NOI2002」荒岛野人]]></title>
    <url>%2Fproblems%2Fluogu-p2421%2F</url>
    <content type="text"><![CDATA[Descripion岛上有 $m$ 个洞穴，顺时针编号为 $1 \sim m$ 。岛上有 $n\ (1 \leq n \leq 15)$ 个野人分别住在 $c_1,c_2,\ldots,c_n\ (1 \leq c_i \leq 100)$ 中。以后每年，第 $i$ 个野人会沿顺时针向前走 $p_i\ (1 \leq p_i \leq 100)$ 个洞住下来，其中第 $i$ 个野人可以生存 $l_i$ 年。没有 $2$ 个野人能在有生之年生存在同一个洞穴中，求洞穴个数 $m\ (m \leq 10^6)$ 的最小值。 Source[Luogu]P2421 Solution 前置知识： 扩展欧几里得(exgcd)算法 对于 野人 $i$ 和 野人 $j$ $(i \neq j)$，假设经过 $x$ 天之后他们会在同一个洞穴相遇，那么可以得出方程： c_i + p_ix \equiv c_j + p_jx \pmod m化简方程，得到 (p_i - p_j)x \equiv c_j - c_i \pmod m这个方程等价于 (p_i - p_j)x + m \times y = c_j - c_i显然我们可以用 exgcd(扩展欧几里得) 算法求出方程 $(p_i - p_j)x + m \times y = \gcd(p_i-p_j,m)​$ 的一个解 $x’​$ 。 如果 $\gcd(p_i-p_j,m) \nmid c_j-c_i$，说明 $x$ 无解，野人 $i,j​$ 永远不会相遇。 若有解，我们求出 $x$ 的最小正整数解，即 x = \left( x' \times \frac{c_j - c_i}{\gcd(p_i-p_j,m)} \bmod \frac{m}{\gcd(p_i-p_j,m)} + \frac{m}{\gcd(p_i-p_j,m)} \right) \bmod \frac{m}{\gcd(p_i-p_j,m)}如果 $x &gt; \min(l_i,l_j)$，说明在他们相遇之前，$i, j$ 中会有至少一个野人死亡，所以也是可行的。 如果 $x \leq \min(l_i,l_j)​$，说明 野人 $i,j​$ 会在死亡前相遇，这个 $m​$ 不可行。 我们只需要枚举每一个可能的 $m$（题目保证 $m \leq 10^6$），枚举每一对野人 $(i,j)$，用 exgcd 求解 $x$ 并判断这个 $m$ 是否满足要求。还有一些小细节：用 exgcd 时必须保证 $p_i \geq p_j$，因为 $\gcd$ 只对 非负整数 有意义。总时间复杂度为 $O( n^2m\log p_i)​$ 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1, len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 15, MAXM = 1e6;int n, maxn, c[MAXN + 5], p[MAXN + 5], l[MAXN + 5];int exGcd(int a, int b, int &amp;x, int &amp;y) &#123; if (b == 0) &#123; x = 1, y = 0; return a; &#125; int d = exGcd(b, a % b, y, x); y -= a / b * x; return d;&#125;inline bool judge(int m) &#123;//判断这个 m 是否可行 for (int i = 1; i &lt; n; ++i) for (int j = i + 1; j &lt;= n; ++j) &#123;//枚举每一对野人 int pi = p[i], pj = p[j], ci = c[i], cj = c[j], x, y, d; if (pi &lt; pj) &#123; swap(pi, pj); swap(ci, cj); &#125; //如果 pi &lt; pj，不满足 gcd 要求，交换 d = exGcd(pi - pj, m, x, y);//d = gcd(pi - pj, m) if ((cj - ci) % d != 0) continue;//x 无解，野人 i,j 不可能相遇 int p = m / d; x *= (cj - ci) / d; x = (x % p + p) % p;//x 的最小整数解 if (x &lt;= min(l[i], l[j])) return 0;//这个 m 不符合题意 &#125; return 1;&#125;int main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) &#123; read(c[i]), read(p[i]), read(l[i]); maxn = max(maxn, c[i]);//已有洞穴中的编号最大的洞穴 &#125; for (int i = maxn; i &lt;= MAXM; ++i)//枚举洞穴个数，注意最小值为编号最大的洞穴 if (judge(i)) &#123; write(i); putchar('\n'); return 0; &#125; return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>数论数学</tag>
        <tag>NOI</tag>
        <tag>2002</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 338D」GCD Table]]></title>
    <url>%2Fproblems%2Fcodeforces-338d%2F</url>
    <content type="text"><![CDATA[Description给定一个 $n \times m\ (1 \leq n,m \leq 10^{12})​$ 的表 格，其中 第 $i​$ 行，第 $j​$ 列 的元素是 $\gcd(i,j)​$ 。现在有一个长度为 $k\ (1\leq k \leq 10^4)​$ 的序列 $a\ (1 \leq a_i \leq 10^{12})​$，询问在表格内是否存在 $x,y\ (1 \leq x \leq n,1 \leq y \leq m - k +1)$，满足对于任意一个 $l$， 都有 $\gcd(x,y+l-1) = a_l\ (1 \leq l \leq k)​$（即这个序列在表格的某一行中出现过）。 Source[Luogu]CF338D [Codeforces]338D Solution 前置知识： 扩展中国剩余定理(exCRT) 由题意得 \left\{\begin{matrix} \begin{aligned} \gcd(x,y)&=a_1\\[1ex] \gcd(x,y+1)&=a_2\\[1ex] \gcd(x,y+2)&=a_3\\[1ex] &\cdots\\[1ex] \gcd(x,y + k - 1) &= a_k \end{aligned} \end{matrix}\right.显然对于所有的 $a_i\ (1 \leq i \leq k)$ 都满足 $a_i \mid x$，所以 ${\rm lcm}\begin{Bmatrix}a_1,a_2,a_3,\ldots,a_k\end{Bmatrix} \mid x$ 。假设 $x = k \times lcm$（$k$ 是正整数），那么 $\gcd(k \times lcm,y+i-1) = a_i$，也就是说要限制 $\gcd\left( k \times \frac{lcm}{a_i},\frac{y+i-1}{a_i} \right) = 1$ 。取 $k = 1$ 时，对该式子的影响最小，由此能够得到 $x={\rm lcm}\begin{Bmatrix}a_1,a_2,a_3,\ldots,a_k\end{Bmatrix}$ 。 至于 $y​$ 呢？由上述方程组能够得到 \left\{\begin{matrix} \begin{aligned} a_1 &\mid y\\[1ex] a_2 &\mid y + 1\\[1ex] a_3 &\mid y + 2\\[1ex] &\cdots\\[1ex] a_k &\mid y + k - 1 \end{aligned} \end{matrix}\right.\\[10ex] \Leftrightarrow \left\{\begin{matrix} \begin{aligned} y &\equiv 0 \pmod {a_1}\\[1ex] y + 1 &\equiv 0 \pmod {a_2}\\[1ex] y + 2 &\equiv 0 \pmod {a_3}\\[1ex] &\cdots\\[1ex] y + k-1&\equiv 0 \pmod {a_k} \end{aligned} \end{matrix}\right.根据同余式的性质，化简该方程组，得到 \left\{\begin{matrix} \begin{aligned} y &\equiv 0 \pmod {a_1}\\[1ex] y &\equiv -1 \pmod {a_2}\\[1ex] y &\equiv -2 \pmod {a_3}\\[1ex] &\cdots\\[1ex] y &\equiv 1-k \pmod {a_k} \end{aligned} \end{matrix}\right.这是一个线性同余方程组，且模数不一定两两互质，所以能用 扩展中国剩余定理(exCRT) 求出 $y​$ 的最小正整数解。 难道只需要考虑 $y$ 的最小正整数解吗？实际上 $y + k \times {\rm lcm}\begin{Bmatrix}a_1,a_2,a_3,\ldots,a_k\end{Bmatrix}$ 都是这个方程组的解，但因为 $\gcd(lcm, y) = \gcd(lcm,y + lcm) =\gcd(lcm,y +k\times lcm)$（原理：更相减损法），所以没必要尝试。 求出了 $x​$ 和 $y​$ 还没有结束，因为只满足 $a_i \mid x​$ 和 $a_i \mid y + i -1\ (1 \leq i \leq k)​$，可能会出现 $\gcd(x,y+i-1)\neq a_i​$（即 $\gcd \left( \frac{x}{a_i},\frac{y+i-1}{a_i} \right) \neq 1​$）的情况，所以要验证该解是否成立。总时间复杂度为 $O(k \log a_i)​$ 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1, len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1e4;int k;LL ans, n, m, a[MAXN + 5], b[MAXN + 5];inline LL slowMul(LL x, LL p, LL mod) &#123; LL res = 0; for (; p; p &gt;&gt;= 1, x = (x + x) % mod) if (p &amp; 1) res = (res + x) % mod; return res;&#125;LL gcd(LL a, LL b) &#123; return !b ? a : gcd(b, a % b); &#125;LL exGcd(LL a, LL b, LL &amp;x, LL &amp;y) &#123; if (!b) &#123; x = 1, y = 0; return a; &#125; LL d = exGcd(b, a % b, y, x); y -= a / b * x; return d;&#125;inline LL exCrt(LL *a, LL *b, LL &amp;lcm) &#123;//求解 ans ≡ a[i] (mod b[i]) LL res = a[1]; lcm = b[1];//第一个方程的解 for (int i = 2; i &lt;= k; ++i) &#123; LL x, y, c = ((a[i] - res) % b[i] + b[i]) % b[i], d = exGcd(lcm, b[i], x, y), m = b[i] / d; if (c % d) return -1;//无解 x = slowMul(x, c / d, m); res += lcm * x; lcm *= m; if (lcm &gt; n) return -1;//如果 lcm&#123;a[i]&#125; 比 n 大，肯定找不到合适的 x 满足题意 res = (res + lcm) % lcm; &#125; return res == 0 ? lcm : res;//y 的值不能为 0，所以最小正整数解为 lcm&#125;int main() &#123; read(n), read(m), read(k); for (int i = 1; i &lt;= k; ++i) &#123; read(a[i]); b[i] = ((1 - i) % a[i] + a[i]) % a[i]; &#125;//y ≡ 1 - i (mod a[i]) LL x, y = exCrt(b, a, x);//同余的数是 b[i]，模数是 a[i] if (y == -1 || y &gt; m - k + 1) &#123;//y 无解 或 超出表格 puts("NO"); return 0; &#125; for (int i = 1; i &lt;= k; ++i) if (gcd(x, y + i - 1) != a[i]) &#123; puts("NO"); return 0; &#125;//验证该解是否成立 puts("YES"); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>数论数学</tag>
        <tag>中国剩余定理</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 1477」青蛙的约会]]></title>
    <url>%2Fproblems%2Fbzoj-1477%2F</url>
    <content type="text"><![CDATA[Descripion环形数轴长 $L\ (0 &lt; L &lt; 2.1 \times 10^9)$ 米（单位长度 $1$ 米），上面有两只青蛙，向正方向跳跃，出发点分别为 $x$ 和 $y\ (0 &lt; x \neq y &lt; 2 \times 10^9)$，一次分别能跳 $m$ 米 和 $n$ 米 $(0 &lt; m,n &lt; 2 \times 10^9)$，两只青蛙跳一次所花的时间相同，求最少跳几次才能相遇。若永远不能相遇，输出 Impossible 。 Source[BZOJ]1477 Solution 前置知识： 扩展欧几里得(exgcd)算法 假设两只青蛙跳 $a$ 步能够相遇，则有方程 x + am \equiv y + an \pmod L根据同余式的性质，化简得到 (m-n)a \equiv y - x \pmod L这个方程等价于 (m - n)a + L \times b = y - x我们只有 $a​$ 和 $b​$ 未知，其它量都已知，这不就是一个形如 $ax + by = c​$ 的 不定方程 吗？ 我们可以用 exgcd（扩展欧几里得） 算法求出方程 $(m-n)a + L \times b = \gcd(m - n, L)$ 中 $a$ 的一个解 ${a}’​$ 。 值得注意的是，$\gcd$ 只对 非负整数 有意义。所以一定要保证 $m \geq n$，若 $m &lt; n$，则在 exgcd 前交换两只青蛙的信息即可。 如果方程 $(m - n)a + L \times b = y - x​$ 有解，则一定满足 $y - x \mid \gcd(m - n, L)​$，否则无解（输出 Impossible）。 若方程有解，则 $a$ 实际的解为 ${a}’ \times \frac{y-x}{\gcd(m - n, L)}$，可这只是这个不定方程的特解，不一定是最小正整数解。 我们让 $L = \frac{L}{\gcd(m - n, L)}$，最小正整数解即为 $\left( a \bmod L + L\right) \bmod L$ 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1, len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;LL exGcd(LL a, LL b, LL &amp;x, LL &amp;y) &#123; if (!b) &#123; x = 1, y = 0; return a; &#125; LL d = exGcd(b, a % b, y, x); y -= a / b * x; return d;&#125;LL x, y, m, n, l, d, a, b;int main() &#123; read(x), read(y), read(m), read(n), read(l); if (m &lt; n) &#123; swap(m, n); swap(x, y); &#125;//m &lt; n，则交换两只青蛙的信息 d = exGcd(m - n, l, a, b);//扩展欧几里得求解不定方程，其中 d = gcd(m - n, L) if ((y - x) % d == 0) &#123; a *= (y - x) / d;//a 实际的解 l /= d; write((a % l + l) % l); putchar('\n'); &#125; else puts("Impossible");//无解 return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>数论数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P1516」青蛙的约会]]></title>
    <url>%2Fproblems%2Fluogu-p1516%2F</url>
    <content type="text"><![CDATA[Descripion环形数轴长 $L\ (0 &lt; L &lt; 2.1 \times 10^9)$ 米（单位长度 $1$ 米），上面有两只青蛙，向正方向跳跃，出发点分别为 $x$ 和 $y\ (0 &lt; x \neq y &lt; 2 \times 10^9)$，一次分别能跳 $m$ 米 和 $n$ 米 $(0 &lt; m,n &lt; 2 \times 10^9)$，两只青蛙跳一次所花的时间相同，求最少跳几次才能相遇。若永远不能相遇，输出 Impossible 。 Source[Luogu]P1516 Solution 前置知识： 扩展欧几里得(exgcd)算法 假设两只青蛙跳 $a$ 步能够相遇，则有方程 x + am \equiv y + an \pmod L根据同余式的性质，化简得到 (m-n)a \equiv y - x \pmod L这个方程等价于 (m - n)a + L \times b = y - x我们只有 $a​$ 和 $b​$ 未知，其它量都已知，这不就是一个形如 $ax + by = c​$ 的 不定方程 吗？ 我们可以用 exgcd（扩展欧几里得） 算法求出方程 $(m-n)a + L \times b = \gcd(m - n, L)$ 中 $a$ 的一个解 ${a}’​$ 。 值得注意的是，$\gcd$ 只对 非负整数 有意义。所以一定要保证 $m \geq n$，若 $m &lt; n$，则在 exgcd 前交换两只青蛙的信息即可。 如果方程 $(m - n)a + L \times b = y - x​$ 有解，则一定满足 $y - x \mid \gcd(m - n, L)​$，否则无解（输出 Impossible）。 若方程有解，则 $a$ 实际的解为 ${a}’ \times \frac{y-x}{\gcd(m - n, L)}$，可这只是这个不定方程的特解，不一定是最小正整数解。 我们让 $L = \frac{L}{\gcd(m - n, L)}$，最小正整数解即为 $\left( a \bmod L + L\right) \bmod L$ 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1, len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;LL exGcd(LL a, LL b, LL &amp;x, LL &amp;y) &#123; if (!b) &#123; x = 1, y = 0; return a; &#125; LL d = exGcd(b, a % b, y, x); y -= a / b * x; return d;&#125;LL x, y, m, n, l, d, a, b;int main() &#123; read(x), read(y), read(m), read(n), read(l); if (m &lt; n) &#123; swap(m, n); swap(x, y); &#125;//m &lt; n，则交换两只青蛙的信息 d = exGcd(m - n, l, a, b);//扩展欧几里得求解不定方程，其中 d = gcd(m - n, L) if ((y - x) % d == 0) &#123; a *= (y - x) / d;//a 实际的解 l /= d; write((a % l + l) % l); putchar('\n'); &#125; else puts("Impossible");//无解 return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>数论数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 2705」「SDOI2012」Longge的问题]]></title>
    <url>%2Fproblems%2Fbzoj-2705%2F</url>
    <content type="text"><![CDATA[Descrption给定一个正整数 $n\ (0 &lt; n \leq 2^{32})$，求 $\sum\limits_{i=1}^{n}\gcd(i,n)​$ 。 Source[BZOJ]2705 Solution 前置知识： 常见积性函数 - 欧拉函数 - 求一个数的欧拉函数值 假设 $\gcd(i,n) = d\ (1 \leq i \leq n) $，则 $\gcd(\frac{i}{d},\frac{n}{d}) = 1​$ 。 因为 $d \mid n$，所以 $d$ 一定是 $n$ 的因数。对于某一个 $d$，我们设 $i = d \times x\ (\frac{1}{d} \leq x \leq \frac{n}{d})$，则 \gcd(\frac{i}{d},\frac{n}{d}) = \gcd(x,\frac{n}{d}) = 1有多少个符合条件的 $x$ 与 $\frac{n}{d}$ 互质呢？显然有 $\varphi(\frac{n}{d})$ 个。而 $d$ 是一个定值，所以也同样有 $\varphi(\frac{n}{d})$ 个 $i$ 满足 $\gcd(i,n) = d$，这个 $d$ 所产生的贡献即为 $\varphi(\frac{n}{d}) \times d$ 。枚举每一个因数 $d$，把它们的贡献加起来就能得到答案，即 \sum\limits_{d \mid n} \left[ \varphi \left(\frac{n}{d} \right) \times d \right]枚举因数 $d$，只需要 $O(\sqrt n)$ 的时间复杂度。$n$ 最大为 $2^{32}$，肯定不能 $O(n)$ 预处理出 $\varphi(1) \sim \varphi(n)$，所以可以用 $O(\sqrt n)$ 的时间复杂度求出一个数的欧拉函数值。总时间复杂度为 $O(n\ 的因数个数 \times \sqrt n)$ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1, len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;inline LL getPhi(LL n) &#123; LL res = n; for (LL i = 2; i * i &lt;= n; ++i) if (n % i == 0) &#123; res -= res / i; for (; n % i == 0; n /= i); &#125; if (n &gt; 1) res -= res / n; return res;&#125;//求一个数的欧拉函数值 LL ans, n;int main() &#123; read(n); for (LL i = 1; i * i &lt;= n; ++i)//枚举 n 的约数 d if (n % i == 0) &#123; LL d1 = i, d2 = n / i;//得到因数 i 和 n / i ans += d1 * getPhi(n / d1); if (d1 != d2) ans += d2 * getPhi(n / d2);//d1 = d2 时只能加一次答案 &#125; write(ans); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>SDOI</tag>
        <tag>数论数学</tag>
        <tag>2012</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2303」「SDOI2012」Longge的问题]]></title>
    <url>%2Fproblems%2Fluogu-p2303%2F</url>
    <content type="text"><![CDATA[Descrption给定一个正整数 $n\ (0 &lt; n \leq 2^{32})$，求 $\sum\limits_{i=1}^{n}\gcd(i,n)​$ 。 Source[Luogu]P2303 Solution 前置知识： 常见积性函数 - 欧拉函数 - 求一个数的欧拉函数值 假设 $\gcd(i,n) = d\ (1 \leq i \leq n) $，则 $\gcd(\frac{i}{d},\frac{n}{d}) = 1​$ 。 因为 $d \mid n$，所以 $d$ 一定是 $n$ 的因数。对于某一个 $d$，我们设 $i = d \times x\ (\frac{1}{d} \leq x \leq \frac{n}{d})$，则 \gcd(\frac{i}{d},\frac{n}{d}) = \gcd(x,\frac{n}{d}) = 1有多少个符合条件的 $x$ 与 $\frac{n}{d}$ 互质呢？显然有 $\varphi(\frac{n}{d})$ 个。而 $d$ 是一个定值，所以也同样有 $\varphi(\frac{n}{d})$ 个 $i$ 满足 $\gcd(i,n) = d$，这个 $d$ 所产生的贡献即为 $\varphi(\frac{n}{d}) \times d$ 。枚举每一个因数 $d$，把它们的贡献加起来就能得到答案，即 \sum\limits_{d \mid n} \left[ \varphi \left(\frac{n}{d} \right) \times d \right]枚举因数 $d$，只需要 $O(\sqrt n)$ 的时间复杂度。$n$ 最大为 $2^{32}$，肯定不能 $O(n)$ 预处理出 $\varphi(1) \sim \varphi(n)$，所以可以用 $O(\sqrt n)$ 的时间复杂度求出一个数的欧拉函数值。总时间复杂度为 $O(n\ 的因数个数 \times \sqrt n)$ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1, len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;inline LL getPhi(LL n) &#123; LL res = n; for (LL i = 2; i * i &lt;= n; ++i) if (n % i == 0) &#123; res -= res / i; for (; n % i == 0; n /= i); &#125; if (n &gt; 1) res -= res / n; return res;&#125;//求一个数的欧拉函数值 LL ans, n;int main() &#123; read(n); for (LL i = 1; i * i &lt;= n; ++i)//枚举 n 的约数 d if (n % i == 0) &#123; LL d1 = i, d2 = n / i;//得到因数 i 和 n / i ans += d1 * getPhi(n / d1); if (d1 != d2) ans += d2 * getPhi(n / d2);//d1 = d2 时只能加一次答案 &#125; write(ans); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>SDOI</tag>
        <tag>数论数学</tag>
        <tag>2012</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 2818」Gcd]]></title>
    <url>%2Fproblems%2Fbzoj-2818%2F</url>
    <content type="text"><![CDATA[Description给定一个整数 $n\ (1 \leq n \leq 10^7)​$，求满足 $\gcd(x,y)\ (1 \leq x, y \leq n)​$ 为质数的数对 $(x,y)​$ 的个数。 Source[BZOJ]2818 Solution 前置知识： 常见积性函数 - 欧拉函数 - 线性筛求欧拉函数 如果 $\gcd(x,y) = 1$，那么 $\gcd(x \times p, y \times p) = p$，只需要满足 $p$ 是质数，就能符合题意。显然我们只需要找满足 $\gcd(x,y) = 1$ 的 $(x,y)$ 的对数，$\gcd(x,y) = 1$ 等价于 $x$ 与 $y$ 互质，很容易联想到 欧拉函数 。 假设 $x \leq y \leq n$，若 $\gcd(x,y) = 1$，则 $x$ 的取值有 $\varphi(y)$ 种，而 $y$ 的值可以取 $1 \sim n$，所以 $(x,y)$ 共 $\sum\limits_{i=1}^{n}\varphi(i)$ 对。在这道题中，还是假设 $x \leq y\leq n $，若 $\gcd(x \times p, y \times p) = p$，$p$ 是质数，则 $y \times p$ 一定不大于 $n$，也就是说，$y \leq \left \lfloor \frac{n}{p} \right \rfloor$ 。因为同时需要满足 $\gcd(x,y) = 1$，所以此时 $(x,y)$ 的对数为 $\sum\limits_{i=1}^{\left \lfloor \frac{n}{p} \right \rfloor}\varphi(i)$，而 $p$ 可以是 $n$ 以内的任何一个质数，因此我们需要枚举每一个 $p$，最后答案为 $\sum\limits_{p \in prime}^{n}\sum\limits_{i=1}^{\left \lfloor \frac{n}{p} \right \rfloor}\varphi(i)$ 。注意这是在 $x \leq y$ 条件下的答案，$\gcd(x,y)$ 与 $\gcd(y,x)$ 算不同的答案，计入答案时要乘 $2$，其中 $\gcd(1 \times p,1\times p)$ 被算了 $2$ 遍，所以还要减 $1$，即 \sum\limits_{p \in prime}^{n}\left [\left( 2\sum\limits_{i=1}^{\left \lfloor \frac{n}{p} \right \rfloor}\varphi(i)\right ) -1\right ]因为要多次求 $\sum\limits_{i=1}^{\left \lfloor \frac{n}{p} \right \rfloor}\varphi(i)$，我们可以预处理出 $\varphi(1) \sim \varphi(n)$ 的 前缀和，整道题的时间复杂度为 $O(n)​$ 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1, len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1e7, MAXP = 1e6;int n, cnt, prime[MAXP], phi[MAXN];LL ans, pre[MAXN + 5];bool isNotPrime[MAXN + 5];inline void getPhi(int n) &#123; isNotPrime[1] = 1; phi[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; if (!isNotPrime[i]) &#123; prime[++cnt] = i; phi[i] = i - 1; &#125; for (int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n; ++j) &#123; isNotPrime[i * prime[j]] = 1; if (i % prime[j] == 0) &#123; phi[i * prime[j]] = phi[i] * prime[j]; break; &#125; else phi[i * prime[j]] = phi[i] * (prime[j] - 1); &#125; &#125;&#125;int main() &#123; read(n); getPhi(n);//线性筛求 n 以内的质数 和 欧拉函数 for (int i = 1; i &lt;= n; ++i) pre[i] = pre[i - 1] + phi[i];//预处理欧拉函数前缀和 for (int i = 1; i &lt;= cnt; ++i)//枚举 gcd(x * prime[i], y * prime[i]) = prime[i] ans += (LL) pre[n / prime[i]] * 2 - 1;//gcd(1 * prime[i], 1 * prime[i]) 算了 2 遍，要减 1 write(ans); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>数论数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2568」GCD]]></title>
    <url>%2Fproblems%2Fluogu-p2568%2F</url>
    <content type="text"><![CDATA[Description给定一个整数 $n\ (1 \leq n \leq 10^7)​$，求满足 $\gcd(x,y)\ (1 \leq x, y \leq n)​$ 为质数的数对 $(x,y)​$ 的个数。 Source[Luogu]P2568 Solution 前置知识： 常见积性函数 - 欧拉函数 - 线性筛求欧拉函数 如果 $\gcd(x,y) = 1$，那么 $\gcd(x \times p, y \times p) = p$，只需要满足 $p$ 是质数，就能符合题意。显然我们只需要找满足 $\gcd(x,y) = 1$ 的 $(x,y)$ 的对数，$\gcd(x,y) = 1$ 等价于 $x$ 与 $y$ 互质，很容易联想到 欧拉函数 。 假设 $x \leq y \leq n$，若 $\gcd(x,y) = 1$，则 $x$ 的取值有 $\varphi(y)$ 种，而 $y$ 的值可以取 $1 \sim n$，所以 $(x,y)$ 共 $\sum\limits_{i=1}^{n}\varphi(i)$ 对。在这道题中，还是假设 $x \leq y\leq n $，若 $\gcd(x \times p, y \times p) = p$，$p$ 是质数，则 $y \times p$ 一定不大于 $n$，也就是说，$y \leq \left \lfloor \frac{n}{p} \right \rfloor$ 。因为同时需要满足 $\gcd(x,y) = 1$，所以此时 $(x,y)$ 的对数为 $\sum\limits_{i=1}^{\left \lfloor \frac{n}{p} \right \rfloor}\varphi(i)$，而 $p$ 可以是 $n$ 以内的任何一个质数，因此我们需要枚举每一个 $p$，最后答案为 $\sum\limits_{p \in prime}^{n}\sum\limits_{i=1}^{\left \lfloor \frac{n}{p} \right \rfloor}\varphi(i)$ 。注意这是在 $x \leq y$ 条件下的答案，$\gcd(x,y)$ 与 $\gcd(y,x)$ 算不同的答案，计入答案时要乘 $2$，其中 $\gcd(1 \times p,1\times p)$ 被算了 $2$ 遍，所以还要减 $1$，即 \sum\limits_{p \in prime}^{n}\left [\left( 2\sum\limits_{i=1}^{\left \lfloor \frac{n}{p} \right \rfloor}\varphi(i)\right ) -1\right ]因为要多次求 $\sum\limits_{i=1}^{\left \lfloor \frac{n}{p} \right \rfloor}\varphi(i)$，我们可以预处理出 $\varphi(1) \sim \varphi(n)$ 的 前缀和，整道题的时间复杂度为 $O(n)​$ 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1, len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1e7, MAXP = 1e6;int n, cnt, prime[MAXP], phi[MAXN];LL ans, pre[MAXN + 5];bool isNotPrime[MAXN + 5];inline void getPhi(int n) &#123; isNotPrime[1] = 1; phi[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; if (!isNotPrime[i]) &#123; prime[++cnt] = i; phi[i] = i - 1; &#125; for (int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n; ++j) &#123; isNotPrime[i * prime[j]] = 1; if (i % prime[j] == 0) &#123; phi[i * prime[j]] = phi[i] * prime[j]; break; &#125; else phi[i * prime[j]] = phi[i] * (prime[j] - 1); &#125; &#125;&#125;int main() &#123; read(n); getPhi(n);//线性筛求 n 以内的质数 和 欧拉函数 for (int i = 1; i &lt;= n; ++i) pre[i] = pre[i - 1] + phi[i];//预处理欧拉函数前缀和 for (int i = 1; i &lt;= cnt; ++i)//枚举 gcd(x * prime[i], y * prime[i]) = prime[i] ans += (LL) pre[n / prime[i]] * 2 - 1;//gcd(1 * prime[i], 1 * prime[i]) 算了 2 遍，要减 1 write(ans); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>数论数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 24D」Broken robot]]></title>
    <url>%2Fproblems%2Fcodeforces-24d%2F</url>
    <content type="text"><![CDATA[Description现在有一个机器人，最初站在 $n \times m\ (1 \leq n,m\leq 1000)$ 矩阵中的 $(x,y)\ (1 \leq x \leq n, 1\leq y \leq m)$ 位置。每次它会等概率的选择 原地不动，向左移动，向右移动，向下移动 四种操作。当然，机器人在第 $1$ 列时不会选择向左移动，第 $m$ 列时不会选择向右移动。求机器人到达第 $n$ 行的期望步数，至少精确到 $10^{-4}$ 。 Source[Luogu]CF24D [Codeforces]24D Solution 前置知识： 高斯(Gauss)消元 求期望步数，很容易想到 期望DP 。我们用 $f_{i,j}$ 表示从 $(i,j)$ 走到最后一行的期望步数，那么初始状态就是 $f_{n,i} = 0\ (1 \leq i \leq m)$（从最后一行走到最后一行的期望步数为 $0$），要求的答案就是 $f_{x,y}$（根据状态即能得到），状态转移方程如下（分 $3$ 种情况讨论）： \large{f_{i,j}=\left\{\begin{matrix} \frac{1}{3}\left ( f_{i,j} + f_{i,j+1} + f_{i+1,j} \right )+1& (j=1)\\[2ex] \frac{1}{4}\left ( f_{i,j} + f_{i,j+1} + f_{i,j-1} + f_{i+1,j} \right )+1& (1< j< m) \\[2ex] \frac{1}{3}\left ( f_{i,j} + f_{i,j-1} + f_{i+1,j} \right )+1& (j=m) \\ \end{matrix}\right.}值得注意的是：$m = 1​$ 时比较特殊，因为不能向左和向右移动，此时 \large{f_{i,j}=\frac{1}{2} \left( f_{i,j} + f_{i+1,j} \right) + 1}这个转移方程是倒推的，并且有后效性，所以不能直接转移。在求 $f_{i,j}​$ 时，$f_{i+1,j}​$ 是 已知 的，而 $f_{i,j-1},f_{i,j},f_{i,j+1}​$ 都是 未知 的，我们把未知量移到左边，把已知量移到右边，可以得到： \large{\left\{\begin{matrix} -\frac{2}{3}f_{i,j}+\frac{1}{3}f_{i,j+1}=-\frac{1}{3}f_{i+1,j}-1 & (j=1)\\[2ex] \frac{1}{4}f_{i,j-1}-\frac{3}{4}f_{i,j}+\frac{1}{4}f_{i,j+1}=-\frac{1}{4}f_{i+1,j}-1& (1 < j < m)\\[2ex] \frac{1}{3}f_{i,j-1}-\frac{2}{3}f_{i,j}=-\frac{1}{3}f_{i+1,j}-1 & (j=m)\\ \end{matrix}\right.}同理，$m = 1​$ 时， \large{-\frac{1}{2}f_{i,j} = -\frac{1}{2}f_{i+1,j} - 1}我们会发现一共有 $m​$ 个未知数和 $m​$ 个方程，很容易想到 高斯消元 求解未知量 $f_{i,1} \sim f_{i,m}\ (1 \leq i &lt; n)​$ 。 比如说，当 $m = 5​$ 时，所构成的矩阵就是： \large{\begin{bmatrix} -\frac{2}{3} & \color{blue}{\frac{1}{3}} & 0 & 0 & 0\\[1ex] \color{red}{\frac{1}{4}} & -\frac{3}{4} & \color{blue}{\frac{1}{4}} & 0 & 0\\[1ex] 0 & \color{red}{\frac{1}{4}} & -\frac{3}{4} & \color{blue}{\frac{1}{4}} & 0\\[1ex] 0 & 0 & \color{red}{\frac{1}{4}} & -\frac{3}{4} & \color{blue}{\frac{1}{4}}\\[1ex] 0 & 0 & 0 & \color{red}{\frac{1}{3}} & -\frac{2}{3}\\[1ex] \end{bmatrix} =\begin{bmatrix} -\frac{1}{3}f_{i+1,j}-1\\[1ex] -\frac{1}{4}f_{i+1,j}-1\\[1ex] -\frac{1}{4}f_{i+1,j}-1\\[1ex] -\frac{1}{4}f_{i+1,j}-1\\[1ex] -\frac{1}{3}f_{i+1,j}-1\\ \end{bmatrix}}本来 高斯消元 的时间复杂度应该是 $O(n^3)​$ 的。但是观察矩阵能够发现，其实这是一个稀疏矩阵，未知数全部集中在对角线上，$0​$ 的地方不需要消元，我们需要消元的只有 $m - 1​$ 个数（上图 $\color{red}{红色}​$ 的数字），回带时原方程中也只需要消去 $m - 1​$ 个数（上图 $\color{blue}{蓝色}​$ 的数字），所以本题中 高斯消元 时间复杂度为 $O(m)​$ 。总时间复杂度为 $O(nm)​$ 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;const int MAXN = 1000;int n, m, x, y;double a[MAXN + 5][MAXN + 5], f[MAXN + 5][MAXN + 5];inline void Gauss() &#123; for (int i = 1; i &lt; m; ++i) &#123; double t = a[i][i]; a[i][i] = 1; a[i][i + 1] /= t; a[i][m + 1] /= t; t = a[i + 1][i]; a[i + 1][i] = 0; a[i + 1][i + 1] -= t * a[i][i + 1]; a[i + 1][m + 1] -= t * a[i][m + 1]; &#125;//消元，消去下一行方程开头的未知数 a[m][m + 1] /= a[m][m]; a[m][m] = 1;//求出最后一个未知数的解 for (int i = m - 1; i; --i) a[i][m + 1] -= a[i + 1][m + 1] * a[i][i + 1];//回带，消去下一行方程末尾的未知数&#125;int main() &#123; read(n), read(m), read(x), read(y); for (int i = n - 1; i &gt;= x; --i) &#123; if (m == 1) &#123; a[1][1] = -1.0 / 2; a[1][m + 1] = -f[i + 1][1] / 2.0 - 1;//特判 m = 1 &#125; else &#123; a[1][1] = -2.0 / 3; a[1][2] = 1.0 / 3; a[1][m + 1] = -f[i + 1][1] / 3.0 - 1.0; for (int j = 2; j &lt; m; ++j) &#123; a[j][j] = -3.0 / 4; a[j][j - 1] = a[j][j + 1] = 1.0 / 4; a[j][m + 1] = -f[i + 1][j] / 4.0 - 1; &#125; a[m][m] = -2.0 / 3; a[m][m - 1] = 1.0 / 3; a[m][m + 1] = -f[i + 1][m] / 3.0 - 1; &#125;//构造矩阵 Gauss();//高斯消元 for (int j = 1; j &lt;= m; ++j) f[i][j] = a[j][m + 1];//赋值求出的解 &#125; printf("%.10lf\n", f[x][y]); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>数论数学</tag>
        <tag>动态规划</tag>
        <tag>概率期望</tag>
        <tag>Codeforces</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见积性函数]]></title>
    <url>%2Fnotes%2Fchang-jian-ji-xing-han-shu%2F</url>
    <content type="text"><![CDATA[定义积性函数 指对于 任意互质的整数 $a$ 和 $b$ 有性质 $f(ab)=f(a)\times f(b)$ 的数论函数。 完全积性函数 指对于 任意整数 $a$ 和 $b$ 有性质 $f(ab)=f(a)\times f(b)$ 的数论函数。 很显然 完全积性函数 是 积性函数 的一个子集。 积性函数欧拉函数定义：欧拉函数，属于 积性函数，但不是完全积性函数。常用 $\varphi$ 表示，读作 fai 。 $\varphi(n)$ 定义为小于等于 $n$ 的正整数中与 $n$ 互质的数的个数。 公式：若 $p_1 , p_2 ,\ldots, p_m$ 为 $x$ 的所有 互不相同 的质因数，$n$ 是一个不为 $0$ 的整数，则 \begin{aligned} \varphi(n)&=n\times\left ( 1-\frac{1}{p_1}\right )\times \left ( 1-\frac{1}{p_2}\right )\times \cdots \times \left ( 1-\frac{1}{p_m}\right )\\[2ex] &=n\prod\limits_{i=1}^{m}\left ( 1-\frac{1}{p_i}\right )\\ \end{aligned}性质 &amp; 证明：性质 1： 若 $n , m​$ 互质，则 $\varphi(nm)=\varphi(n) \times \varphi(m)​$ 。 证明： 积性函数特有性质。 性质 2： 若 $n​$ 为 质数，则 $\varphi(n)=n-1​$ 。 证明： 所有小于 $n$ 的正整数都与 $n$ 互质，一共 $n - 1​$ 个。 性质 3： 若 $n​$ 为 奇数，则 $\varphi(2n)=\varphi(n)​$ 。 证明： 显然 $n$ 与 $2$ 互质，且 $\varphi(2) = 1$，所以根据 性质 1，可得 \begin{aligned} \varphi(2n)&=\varphi(2) \times \varphi(n)\\[1ex] &=1\times \varphi(n)\\[1ex] &=\varphi(n) \end{aligned}性质 4： 若 $p$ 为质数，$n = p^k$，则 \varphi(n)=p^k-p^{k-1}证明： 由 $n=p^k$，得 $n$ 的质因数只有 $p$，再通过公式，可知 \begin{aligned} \varphi(n)&=n\times\left(1-\frac{1}{p}\right)\\[2ex] &=p^k \times \left(1-\frac{1}{p}\right)\\[2ex] &= p^k - p^{k-1} \end{aligned}性质 5： 若 $n &gt; 2​$，则 $\varphi(n)​$ 为偶数。 若 $n &gt; 1$，则小于等于 $n$ 且与 $n$ 互质的数的和为 \frac{n \times \varphi(n)}{2}证明： 首先需要知道：若 $n$ 与 $m$ 互质 $(n &gt; m)$，则 $n$ 与 $n - m$ 互质。 \begin{aligned} &\gcd(n,m)=1\\[1ex] &\gcd(n,m)=\gcd(n,n-m)\\ \end{aligned}显然与 $n$ 互质的数都是成对出现的，且相加的和为 $n$，只有在 $\gcd(n,\frac{n}{2})=1$ 时例外，但这种情况只会在 $n \leq 2$ 时出现，所以 $\varphi(n)\ (n &gt; 2)$ 为偶数得证。小于等于 $n$ 的数中，与 $n$ 互质的数的个数为 $\varphi(n)$，所以一共有 $\frac{\varphi(n)}{2}$ 对，总和为 $\frac{n \times \varphi(n)}{2}​$。 性质 6： 若正整数 $x$ 与质数 $p$ 不互质 程序：如何求出 $\varphi(n)​$ ？ 根据欧拉函数的公式我们能够得到以下代码： 123456789inline int getPhi(int n) &#123; int res = n; for (int i = 2; i &lt;= n; ++i)//枚举因数 if (n % i == 0) &#123; res -= res / i; for (; n % i == 0; n /= i);//将质因数 i 除完 &#125; return res;&#125; 在最坏情况下（$n​$ 是质数），该代码的时间复杂度为 $O(n)​$，这显然不够优秀，考虑如何优化。 任何一个整数 $n$ 都不可能存在 $2$ 个大于 $\sqrt n$ 的质因子，所以我们枚举因数时只需要遍历到 $O(\sqrt n)$ 即可，如果将小于 $\sqrt n$ 的质因子除完后，剩下的数不为 $1$，说明还有 $1$ 个大于 $\sqrt n$ 的质因子，最后要算进去。这种做法的时间复杂度为 $O(\sqrt n)$ 。 求一个数的欧拉函数值： 12345678910inline int getPhi(int n) &#123; int res = n; for (int i = 2; i * i &lt;= n; ++i) if (n % i == 0) &#123; res -= res / i; for (; n % i == 0; n /= i); &#125; if (n &gt; 1) res -= res / n; return res;&#125; 如果需要求 $\varphi(1)\sim \varphi(n)​$ 的值，用上述方法逐个求的时间复杂度为 $O(n\sqrt n)​$，有没有更快的做法呢？ 线性筛求欧拉函数： 1234567891011121314151617inline void getPhi(int n) &#123; isNotPrime[1] = 1; phi[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; if (!isNotPrime[i]) &#123; prime[++cnt] = i; phi[i] = i - 1; &#125; for (int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n; ++j) &#123; isNotPrime[i * prime[j]] = 1; if (i % prime[j] == 0) &#123; phi[i * prime[j]] = phi[i] * prime[j]; break; &#125; else phi[i * prime[j]] = phi[i] * (prime[j] - 1); &#125; &#125;&#125; 莫比乌斯函数定义：莫比乌斯函数，属于 积性函数，但不是完全积性函数。常用 $\mu$ 表示，读作 miu 。 莫比乌斯函数的定义域是全体自然数 $n$ 。 若 $n = 1$，则 $\mu(1)=1$； 若 $n$ 存在大于 $1$ 的平方因子，则 $\mu(n)=0$（平方因子即 $4 , 9 , 25$ 等）； 若 $n$ 是偶数个互不相同的质数之积，则 $\mu(n)=1$； 若 $n$ 是奇数个互不相同的质数之积，则 $\mu(n)=-1$ 。 公式： \mu(n)=\left\{\begin{matrix} 1& n=1\\[2ex] (-1)^m& n=p_1\times p_2 \times \cdots \times p_m = \prod\limits_{i=1}^{m}p_i(\forall p_i \neq p_j)\\[2ex] 0& others\\ \end{matrix}\right.性质 &amp; 证明：性质 1： 若 $n , m$ 互质，则 $\mu(nm)=\mu(n) \times \mu(m)$ 。 证明： 积性函数特有性质。 性质 2： 若 $n \neq 1$，则 $n$ 所有因子的莫比乌斯函数值的和为 $0$，即 \sum\limits_{d\mid n}\mu(d)=\left\{\begin{matrix} 1& n=1\\[2ex] 0& n>1 \end{matrix}\right.证明： 除数函数定义：除数函数，属于 积性函数，但不是完全积性函数。常用 $\sigma$ 表示，读作 sigma 。 $\sigma_x(n)$ 定义为 $n$ 的正约数的 $x$ 次幂之和，即 \sigma_x(n)=\sum\limits_{d\mid n}d^x公式：若 $p_1 , p_2 ,\ldots, p_m$ 为 $x$ 的所有质因数，$n$ 和 $x$ 都是 自然数 。 \begin{aligned} \sigma_x(n) &= (1 + p_1^x+p_1^{2x}+\cdots+p_1^{a_1x})\\[1ex] &\times (1 + p_2^x+p_2^{2x}+\cdots+p_2^{a_2x})\\[1ex] &\times (1 + p_3^x+p_3^{2x}+\cdots+p_3^{a_3x})\\[1ex] &\times \cdots \cdots\\[1ex] &\times (1 + p_m^x+p_m^{2x}+\cdots+p_m^{a_mx})\\[2ex] &=\prod\limits_{i=1}^{m}\sum\limits_{j=0}^{a_i}p_i^{jx}\\[2ex] &=\prod\limits_{i=1}^{m}\frac{p_i^{(a_i+1)x}-1}{p_i^x-1}\\ \end{aligned}性质 &amp; 证明：性质 1： 特殊地，$\sigma_0(n)$ 可以表示 $n$ 的正约数个数，$\sigma_1(n)$ 可以表示 $n​$ 的正约数之和。 证明： 根据定义即能得到该结论。 性质 2： 若 $n , m​$ 互质，且 $x​$ 是自然数，则 $\sigma_x(nm)=\sigma_x(n) \times \sigma_x(m)​$ 。 证明： 积性函数特有性质。 完全积性函数]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>数论数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的质数相关定理]]></title>
    <url>%2Fnotes%2Fchang-yong-de-zhi-shu-xiang-guan-ding-li%2F</url>
    <content type="text"><![CDATA[前言许多与质数相关的定理都是数论的基础，想要学好数论，必须掌握这些定理并且能够熟练运用。 唯一分解定理（算数基本定理）任何一个大于 $1$ 的自然数都可以表示为有限个（包括 $1$ 个）质数的乘积。 \begin{aligned} n &= p_1^{a_1} \times p_2^{a_2} \times p_3^{a_3} \times \cdots \times p_m^{a_m}\\[2ex] &= \prod\limits_{i=1}^{m}p_i^{a_i}\\ \end{aligned}其中 $p_i (1 \leq i \leq m)$ 为质数，且都是 $n$ 的质因子。 当 $p_1 &lt; p_2 &lt; \cdot \cdot \cdot &lt; p_m$ 时，该式又称为 $n$ 的 标准分解式 。 约数个数定理若 $n = \prod\limits_{i=1}^{m}p_i^{a_i}$，则 $n​$ 的约数个数可以表示为： \begin{aligned} \sigma_0(n) &= (a_1 + 1) \times (a_2+1) \times \cdots \times (a_m+1)\\[2ex] &=\prod\limits_{i=1}^{m}(a_i+1)\\ \end{aligned} $\sigma$ 是 除数函数 。具体内容请见 常见积性函数 - 除数函数 。 证明： 对于这个 $n​$，显然 $p_i^{a_i}(1 \leq i \leq m)​$ 的约数有： p_i^0,p_i^1,p_i^2,\ldots,p_i^{a_i}一共 $a_i+1$ 个。而 $n$ 的约数肯定是 $p_1^{a_1},p_2^{a_2},p_3^{a_3},\cdots,p_m^{a_m}$ 每一个数各选出一个约数的乘积。 根据 乘法原理，一共有 (a_1 + 1) \times (a_2+1) \times \cdots \times (a_m+1) =\prod\limits_{i=1}^{m}(a_i+1)种选法，即 $n$ 的约数个数。 约数和定理若 $n = \prod\limits_{i=1}^{m}p_i^{a_i}$，则 $n$ 的所有正约数之和可以表示为： \begin{aligned} \sigma_1(n) &= (p_1^0 + p_1^1+p_1^2+\cdots+p_1^{a_1})\\[1ex] &\times (p_2^0 + p_2^1+p_2^2+\cdots+p_2^{a_2})\\[1ex] &\times (p_3^0 + p_3^1+p_3^2+\cdots+p_3^{a_3})\\[1ex] &\times \cdots \cdots\\[1ex] &\times (p_m^0 + p_m^1+p_m^2+\cdots+p_m^{a_m})\\[2ex] &= \prod\limits_{i=1}^{m}\sum\limits_{j=0}^{a_i}p_i^j\\ \end{aligned}其实 $\sum\limits_{j=0}^{a_i}p_i^j$ 是一个公比为 $p_i$ 的 等比数列 的和，因此该式子也能表示为： \sigma_1(n) = \prod\limits_{i=1}^{m}\frac{p_i^{a_i+1}-1}{p_i-1} $\sigma$ 是 除数函数 。具体内容请见 常见积性函数 - 除数函数 。 证明： 咕 威尔逊定理若 $p$ 为质数，则 (p-1)! \equiv -1\pmod p威尔逊定理的 逆定理 也成立，即： 对于某一个正整数 $p$，若 $(p-1)! \equiv -1\pmod p$，则 $p$ 一定是一个质数。 证明： 咕 二次探测定理若 $p​$ 是质数，$x​$ 是小于 $p​$ 的正整数，且 $x^2 \equiv 1\pmod p​$，则 x_1=1\ ,\ x_2=p-1证明： 根据同余式的性质，两边同时减去 $1$，得到 x^2 - 1 \equiv 0\pmod p左边显然可以用 平方差公式 因式分解，得到 (x+1)(x-1)\equiv 0\pmod p这个式子等价于 p\mid (x+1)(x-1)显然 $p$ 的因子来自 $x + 1$ 和 $x - 1$，但是因为 $p$ 是一个质数，所以 $p$ 的因子只有 $1$ 和 $p$，因此一定满足 $p\mid x+1$ 或 $p\mid x-1$ 。又因为 $0 &lt; x &lt; p$，所以 $x$ 的值为 $1$ 或 $p - 1$ 。 二次探测定理的 逆定理 也成立，即： $x​$ 是小于 $p​$ 的正整数，若 $x^2 \equiv 1\pmod p​$，且 $x\neq 1 , x\neq p-1​$，则这个 $p​$ 一定不是质数。 费马小定理若 $a​$ 为正整数，$p​$ 为质数，且 $a​$ 与 $p​$ 互质，则 a^{p-1}\equiv 1\pmod p证明： 咕 欧拉定理若 $a$ 和 $p$ 都是正整数，且 $a$ 与 $p$ 互质，则 a^{\varphi(p)} \equiv 1\pmod p $\varphi​$ 是 欧拉函数 。具体内容请见 常见积性函数 - 欧拉函数 。 证明： 咕 扩展欧拉定理若 $a$ 和 $p$ 都是正整数，则 \left\{\begin{array} {ll}a^{b} \equiv {a^{b \bmod \varphi(p)}} \pmod p & {\gcd(a, p)=1} \\[2ex] a^{b} \equiv {a^{b}} \pmod p & {\gcd(a, p) \neq 1, b]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>数论数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 1607」「USACO2008 Dec」Patting Heads 轻拍牛头]]></title>
    <url>%2Fproblems%2Fbzoj-1607%2F</url>
    <content type="text"><![CDATA[Descripion给定 $n\ (1 \leq n \leq 10^5)$ 个正整数 $a_i\ (1 \leq a_i \leq 10^6)$ 。对于每一个数 $a_i$，求有多少个数 $j\ (1 \leq j \leq n)$ 满足 $a_i \mid a_j$ 且 $i \neq j$ 。 Source[BZOJ]1607 Solution看完题目很容易想到 $O(n^2)​$ 的暴力算法，枚举所有 $i​$ 和 $j​$，显然会超时。但我们发现 $a_i​$ 并不大，所以考虑另一种方法。 我们用一个桶 $cnt​$ 记录 $a_i​$ 出现的次数，$ans_i​$ 表示 $a_i=i​$ 时的答案，枚举 $i=1 \sim \max \begin{Bmatrix}a_i\end{Bmatrix}​$ ，接着枚举 $i​$ 以及 $i​$ 的倍数，凡是等于 $i​$ 或是 $i​$ 的倍数的数，答案都应该加上 $i​$ 出现的次数。同时因为会把自己算进去，所以答案要减 $1​$ 。时间复杂度为 $O(n\log\log n)​$，类似 埃拉托斯特尼筛法 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1, len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1e5, MAXM = 1e6;int n, maxn, a[MAXN + 5], cnt[MAXM + 5], ans[MAXM + 5];int main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); ++cnt[a[i]]; maxn = max(maxn, a[i]); &#125; for (int i = 1; i &lt;= maxn; ++i) &#123; if (!cnt[i]) continue;//小优化：判断 i 是否出现过 for (int j = i; j &lt;= maxn; j += i)//枚举 i 以及 i 的倍数 ans[j] += cnt[i];//如果 i | j，则让 ans[j] 增加 i 出现的次数 &#125; for (int i = 1; i &lt;= n; ++i) &#123; write(ans[a[i]] - 1);//因为 a[i] | a[i]，多算了一次自己，要减 1 putchar('\n'); &#125; return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>数论数学</tag>
        <tag>USACO</tag>
        <tag>2008</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2926」「USACO08DEC」拍头 Patting Heads]]></title>
    <url>%2Fproblems%2Fluogu-p2926%2F</url>
    <content type="text"><![CDATA[Descripion给定 $n\ (1 \leq n \leq 10^5)$ 个正整数 $a_i\ (1 \leq a_i \leq 10^6)$ 。对于每一个数 $a_i$，求有多少个数 $j\ (1 \leq j \leq n)$ 满足 $a_i \mid a_j$ 且 $i \neq j$ 。 Source[Luogu]P2926 Solution看完题目很容易想到 $O(n^2)​$ 的暴力算法，枚举所有 $i​$ 和 $j​$，显然会超时。但我们发现 $a_i​$ 并不大，所以考虑另一种方法。 我们用一个桶 $cnt​$ 记录 $a_i​$ 出现的次数，$ans_i​$ 表示 $a_i=i​$ 时的答案，枚举 $i=1 \sim \max \begin{Bmatrix}a_i\end{Bmatrix}​$ ，接着枚举 $i​$ 以及 $i​$ 的倍数，凡是等于 $i​$ 或是 $i​$ 的倍数的数，答案都应该加上 $i​$ 出现的次数。同时因为会把自己算进去，所以答案要减 $1​$ 。时间复杂度为 $O(n\log\log n)​$，类似 埃拉托斯特尼筛法 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1, len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1e5, MAXM = 1e6;int n, maxn, a[MAXN + 5], cnt[MAXM + 5], ans[MAXM + 5];int main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); ++cnt[a[i]]; maxn = max(maxn, a[i]); &#125; for (int i = 1; i &lt;= maxn; ++i) &#123; if (!cnt[i]) continue;//小优化：判断 i 是否出现过 for (int j = i; j &lt;= maxn; j += i)//枚举 i 以及 i 的倍数 ans[j] += cnt[i];//如果 i | j，则让 ans[j] 增加 i 出现的次数 &#125; for (int i = 1; i &lt;= n; ++i) &#123; write(ans[a[i]] - 1);//因为 a[i] | a[i]，多算了一次自己，要减 1 putchar('\n'); &#125; return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>数论数学</tag>
        <tag>USACO</tag>
        <tag>2008</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 2721」「Violet 5」樱花]]></title>
    <url>%2Fproblems%2Fbzoj-2721%2F</url>
    <content type="text"><![CDATA[Descripion求不定方程 \frac{1}{x} + \frac{1}{y} = \frac{1}{n!}\ (1 \leq n \leq 10^6)正整数解 $(x, y) $ 的数目，答案对 $10^9+7$ 取模。 Source[BZOJ]2721 Solution题目所给的方程一看就知道不能直接做，必须化简。 我们先把等式左边通分，得到 \frac{x+y}{xy}=\frac{1}{n!}对角相乘，得到 xy=(x+y)n!移项 xy-(x+y)n!=0根据等式的性质，两边同时加上 $(n!)^2$，得到 xy-(x+y)n!+(n!)^2=(n!)^2这时我们发现等式左边可以因式分解了，式子变为 (x-n!)(y-n!)=(n!)^2即使到了这一步，还是看不出什么，我们考虑换元。假设 $a=x-n!$，$b=y-n!$，则能得到 ab=(n!)^2很显然 $n!​$ 是确定的，$a,b​$ 有多少不同的正整数解， $x,y​$ 就有多少不同的值能使等式成立，而 $a,b​$ 都是 $(n!)^2​$ 的因数，所以问题就变为求 $(n!)^2​$ 的因数个数。根据 唯一分解定理： n!=p_1^{a_1} \times p_2^{a_2} \times \cdot \cdot \cdot \times p_m^{a_m}其中 $m$ 表示 $n!$ 分解出的不同质数的个数，$p_i$ 表示 $n!$ 分解出的质数，$a_i$ 表示质因子 $p_i$ 的个数，那么 (n!)^2=p_1^{2a_1} \times p_2^{2a_2} \times \cdot \cdot \cdot \times p_m^{2a_m}$(n!)^2​$ 的因数个数就等于 $\prod\limits_{i=1}^{m}(2a_i+1)​$ 。 这个东西怎么求呢？ 我们先用 线性筛法（欧拉筛）求出 $1\sim n​$ 内的质数，并记录下每个数的最小质因子（线性筛中的合数只会被它的最小质因子筛去）。因为我们要求 $n!​$ 的质因数，所以枚举 $1 \sim n​$ 每一个数，依次分解它们，得到它们有哪些质因数。具体方法：每次除以它本身的最小质因子，直到这个数变成 $1​$ 为止。例如求 $18​$ 的因数：$18​$ 的最小质因子是 $2​$，就将 $a_2 +1​$，$18​$ 除以 $2​$ 变为 $9​$；再考虑 $9​$，$9​$ 的最小质因子是 $3​$，将 $a_3 +1​$，$9​$ 除以 $3​$ 变为 $3​$；$3​$ 的最小质因子是 $3​$，所以将 $a_3 + 1​$，$3​$ 除以 $3​$ 变为 $1​$，停止计算 。此时我们已经可以知道：$18=2^{a_2=1}\times 3^{a_3=2} ​$。按上述操作处理，就能算出 $n!​$ 的质因数分布，根据公式就能得到答案。同时因为最小的质数是 $2​$，每次除以它的最小质因子时，最大也会变为原来的 $\frac{1}{2}​$，所以时间复杂度为 $O(n\log n)​$ 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1, len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1e6;const LL MOD = 1e9 + 7;int n, cnt, a[MAXN + 5], prime[MAXN + 5], minPrime[MAXN + 5];//minPrime[i]表示 i 的最小质因子 LL ans = 1;inline void getPrime(int n) &#123; for (int i = 2; i &lt;= n; ++i) &#123; if (!minPrime[i]) &#123; minPrime[i] = i;//质数的最小质因子是它本身 prime[++cnt] = i; &#125; for (int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n; ++j) &#123; minPrime[i * prime[j]] = prime[j];//线性筛中的合数只会被最小质因子筛去 if (i % prime[j] == 0) break; &#125; &#125; &#125;int main() &#123; read(n); getPrime(n);//线性筛质数 for (int i = 1; i &lt;= n; ++i) for (int j = i; j &gt; 1; j /= minPrime[j]) ++a[minPrime[j]];//质因子计数 for (int i = 1; i &lt;= cnt; ++i) ans = ans * (LL) (a[prime[i]] &lt;&lt; 1 | 1) % MOD;//用公式求得答案 write(ans); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>数论数学</tag>
        <tag>筛法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P1445」「Violet」樱花]]></title>
    <url>%2Fproblems%2Fluogu-p1445%2F</url>
    <content type="text"><![CDATA[Descripion求不定方程 \frac{1}{x} + \frac{1}{y} = \frac{1}{n!}\ (1 \leq n \leq 10^6)正整数解 $(x, y) $ 的数目，答案对 $10^9+7$ 取模。 Source[Luogu]P1445 Solution题目所给的方程一看就知道不能直接做，必须化简。 我们先把等式左边通分，得到 \frac{x+y}{xy}=\frac{1}{n!}对角相乘，得到 xy=(x+y)n!移项 xy-(x+y)n!=0根据等式的性质，两边同时加上 $(n!)^2$，得到 xy-(x+y)n!+(n!)^2=(n!)^2这时我们发现等式左边可以因式分解了，式子变为 (x-n!)(y-n!)=(n!)^2即使到了这一步，还是看不出什么，我们考虑换元。假设 $a=x-n!$，$b=y-n!$，则能得到 ab=(n!)^2很显然 $n!​$ 是确定的，$a,b​$ 有多少不同的正整数解， $x,y​$ 就有多少不同的值能使等式成立，而 $a,b​$ 都是 $(n!)^2​$ 的因数，所以问题就变为求 $(n!)^2​$ 的因数个数。根据 唯一分解定理： n!=p_1^{a_1} \times p_2^{a_2} \times \cdot \cdot \cdot \times p_m^{a_m}其中 $m$ 表示 $n!$ 分解出的不同质数的个数，$p_i$ 表示 $n!$ 分解出的质数，$a_i$ 表示质因子 $p_i$ 的个数，那么 (n!)^2=p_1^{2a_1} \times p_2^{2a_2} \times \cdot \cdot \cdot \times p_m^{2a_m}$(n!)^2​$ 的因数个数就等于 $\prod\limits_{i=1}^{m}(2a_i+1)​$ 。 这个东西怎么求呢？ 我们先用 线性筛法（欧拉筛）求出 $1\sim n​$ 内的质数，并记录下每个数的最小质因子（线性筛中的合数只会被它的最小质因子筛去）。因为我们要求 $n!​$ 的质因数，所以枚举 $1 \sim n​$ 每一个数，依次分解它们，得到它们有哪些质因数。具体方法：每次除以它本身的最小质因子，直到这个数变成 $1​$ 为止。例如求 $18​$ 的因数：$18​$ 的最小质因子是 $2​$，就将 $a_2 +1​$，$18​$ 除以 $2​$ 变为 $9​$；再考虑 $9​$，$9​$ 的最小质因子是 $3​$，将 $a_3 +1​$，$9​$ 除以 $3​$ 变为 $3​$；$3​$ 的最小质因子是 $3​$，所以将 $a_3 + 1​$，$3​$ 除以 $3​$ 变为 $1​$，停止计算 。此时我们已经可以知道：$18=2^{a_2=1}\times 3^{a_3=2} ​$。按上述操作处理，就能算出 $n!​$ 的质因数分布，根据公式就能得到答案。同时因为最小的质数是 $2​$，每次除以它的最小质因子时，最大也会变为原来的 $\frac{1}{2}​$，所以时间复杂度为 $O(n\log n)​$ 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1, len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1e6;const LL MOD = 1e9 + 7;int n, cnt, a[MAXN + 5], prime[MAXN + 5], minPrime[MAXN + 5];//minPrime[i]表示 i 的最小质因子 LL ans = 1;inline void getPrime(int n) &#123; for (int i = 2; i &lt;= n; ++i) &#123; if (!minPrime[i]) &#123; minPrime[i] = i;//质数的最小质因子是它本身 prime[++cnt] = i; &#125; for (int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n; ++j) &#123; minPrime[i * prime[j]] = prime[j];//线性筛中的合数只会被最小质因子筛去 if (i % prime[j] == 0) break; &#125; &#125; &#125;int main() &#123; read(n); getPrime(n);//线性筛质数 for (int i = 1; i &lt;= n; ++i) for (int j = i; j &gt; 1; j /= minPrime[j]) ++a[minPrime[j]];//质因子计数 for (int i = 1; i &lt;= cnt; ++i) ans = ans * (LL) (a[prime[i]] &lt;&lt; 1 | 1) % MOD;//用公式求得答案 write(ans); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>数论数学</tag>
        <tag>筛法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 242E」XOR on Segment]]></title>
    <url>%2Fproblems%2Fcodeforces-242e%2F</url>
    <content type="text"><![CDATA[Description给定 $n\ (1 \leq n \leq 10^5)$ 个数 $a_i\ (0 \leq a_i \leq 10^6)$，现在有 $m\ (1 \leq m \leq 5 \times 10^4)$ 个操作（操作有 $2$ 种）: 1 l r：求 $\sum\limits_{i=l}^{r}a_i\ (1 \leq l \leq r \leq n)$； 2 l r x：区间 $[l,r]\ (1 \leq l \leq r \leq n)$ 内的数对 $x\ (1 \leq x \leq 10^6)$ 异或。 Source[Luogu]CF242E [Codeforces]242E Solution 前置知识： 线段树 因为是区间修改和区间查询，且异或具有结合律：$(a \oplus b) \oplus c = a \oplus (b \oplus c)​$，我们很容易想到用线段树来维护。可是似乎打不了懒标记，怎么办？先考虑 $a_i​$ 只有 $0​$ 和 $1​$ 两个值的情况，当对一条线段区间反转的时候，我们只需要让这条线段的懒标记异或 $1​$，这个区间 $1​$ 的个数变为 区间长度 - 原来区间 $1​$ 的个数。标记下放时，如果这条线段的懒标记为 $1​$，则将这条线段的左右区间反转（做上述反转操作），并清空这条线段的懒标记。 显然只有 $0$ 和 $1$ 时用线段树维护很简单，现在我们需要让这些数转化为 $0$ 和 $1$ 进行操作，这不就是把它们转化成 二进制 吗？相当于建了 $\log \max\begin{Bmatrix}a_i\end{Bmatrix}$ 棵线段树，分别维护 $a_i$ 在二进制下的每一位，以及每一位的区间和。对于即将异或的数 $x$，先找到要修改的区间 $[l,r]$，再把 $x$ 二进制拆分，如果 $x$ 在二进制下某一位是 $1$，我们就对这一位所在的线段树区间 $[l,r]$ 反转。查询时，同样先找到要查询的区间 $[l,r]$，把二进制下每一位所在的 线段树区间 $[l,r]$ 的和 × 二进制下这一位对应的值 加起来就是答案。因为每一次修改或查询都要在线段树内二进制拆分，所以时间复杂度为 $O(n\log^2n)$ 。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1, len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1e5, MAX_LOG = 21;int n, m, a[MAXN + 5];struct SegmentTree &#123; LL lazy[MAXN &lt;&lt; 2 | 3], sum[MAX_LOG + 1][MAXN &lt;&lt; 2 | 3]; //sum[i][x]表示二进制下第 i 位第 x 条线段的和 inline int lson(int x) &#123; return x &lt;&lt; 1; &#125; inline int rson(int x) &#123; return x &lt;&lt; 1 | 1; &#125; inline void pushUp(LL x) &#123; for (int i = 0; i &lt;= MAX_LOG; ++i) sum[i][x] = sum[i][lson(x)] + sum[i][rson(x)];//维护二进制下每一位 &#125; void build(int *a, int x = 1, int l = 1, int r = n) &#123; if (l == r) &#123; for (register int i = 0; i &lt;= MAX_LOG; ++i) sum[i][x] = (a[l] &gt;&gt; i) &amp; 1;//二进制拆分 return; &#125; int mid = (l + r) &gt;&gt; 1; build(a, lson(x), l, mid), build(a, rson(x), mid + 1, r); pushUp(x); &#125; inline void modify(int x, int l, int r, LL p) &#123; lazy[x] ^= p;//异或满足结合律 (a ^ b) ^ c = a ^ (b ^ c) for (int i = 0; i &lt;= MAX_LOG; ++i) if ((p &gt;&gt; i) &amp; 1)//如果第 i 位为 1 sum[i][x] = r - l + 1 - sum[i][x];//区间内 1 的个数取反 &#125; inline void pushDown(int x, int l, int r) &#123; LL mid = (l + r) &gt;&gt; 1; modify(lson(x), l, mid, lazy[x]), modify(rson(x), mid + 1, r, lazy[x]); lazy[x] = 0; &#125; void update(int ql, int qr, LL p, int l = 1, int r = n, int x = 1) &#123; if (ql &lt;= l &amp;&amp; qr &gt;= r) &#123; modify(x, l, r, p); return; &#125; if (lazy[x]) pushDown(x, l, r); LL mid = (l + r) &gt;&gt; 1; if (ql &lt;= mid) update(ql, qr, p, l, mid, lson(x)); if (qr &gt; mid) update(ql, qr, p, mid + 1, r, rson(x)); pushUp(x); &#125; LL query(int ql, int qr, int l = 1, int r = n, int x = 1) &#123; if (ql &lt;= l &amp;&amp; qr &gt;= r) &#123; LL res = 0; for (int i = 0; i &lt;= MAX_LOG; ++i) res += sum[i][x] &lt;&lt; i;//二进制下第 i 位对应 2 的 i 次方，累加 return res; &#125; if (lazy[x]) pushDown(x, l, r); LL res = 0, mid = (l + r) &gt;&gt; 1; if (ql &lt;= mid) res += query(ql, qr, l, mid, lson(x)); if (qr &gt; mid) res += query(ql, qr, mid + 1, r, rson(x)); return res; &#125;&#125; tr;int main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) read(a[i]); tr.build(a); read(m); for (int i = 1; i &lt;= m; ++i) &#123; int opt, l, r; LL x; read(opt); if (opt == 1) &#123; read(l), read(r); write(tr.query(l, r)); putchar('\n'); &#125; else &#123; read(l), read(r), read(x); tr.update(l, r, x); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉查找树(BST)简介]]></title>
    <url>%2Fnotes%2Fer-cha-cha-zhao-shu-bst-jian-jie%2F</url>
    <content type="text"><![CDATA[介绍二叉查找树(Binary Search Tree) 又称 二叉排序树(Binary Sort Tree) ，亦称 二叉搜索树，简写为 BST 。 二叉查找树具有以下性质： 如果左子树非空，那么左子树上的所有节点的值均小于等于根节点的值。 如果右子树非空，那么右子树上的所有节点的值均大于等于根节点的值。 二叉查找树的 左子树 与 右子树 也分别为二叉查找树。 通俗地讲：二叉查找树上点的权值，左儿子 &lt; 根节点 &lt; 右儿子 。 根据这个性质，我们很容易发现二叉查找树的中序遍历是一个单调不减的序列。 那么，二叉查找树有什么作用呢？ 对于一个长度为 $8​$ 的序列： $1, 15, 5, 3, 8, 10, 9, 12, 10​$，该如何找到这个序列第 $k​$ 大的数，并且支持插入与删除元素呢？如果我们将其排序再进行查询，时间复杂度为 $O(n \log n)​$，这显然不够优秀。因此我们考虑构造出一棵二叉查找树，如图。 插入假设我们要向上述序列插入一个数 $11​$，我们从根节点开始。 我们发现 $11 &gt; 9$，因此我们把 $11$ 放到 $9$ 的右儿子。 此时 $12$ 比 $11$ 大了，为了保持二叉搜索树的性质，我们把 $11$ 放到 $12​$ 的左儿子。 $11 &gt; 10$，本来应该让 $11$ 和 $10$ 的右儿子继续比较，可是 $10$ 没有右儿子，因此我们把 $11$ 插入到该位置。 小结：插入一个数时，从根节点开始，依次比较要插入的数和当前节点的值，如果大于当前节点，就放到该结点的右儿子，如果小于当前节点，就放到该结点的左儿子，重复上述操作，直到下放的位置没有结点。如果中途碰到与某个节点相等，我们再定义一个 $cnt$ 数组，表示当前节点值的个数，并且加上 $1$ 。这样我们就完成了一个数的插入过程。 删除类似插入的过程，还是依次比较要删除的数和当前节点的值，不断下放，当找到目标节点时，并不需要把该节点整个删掉，只需要给该节点值的个数减 $1$ 。对于节点 $x$，如果 $cnt[x] = 0$， 则表示当前位置没有节点。当一个位置没有节点时，这棵树依旧满足二叉查找树的性质。 查询前驱$x$ 的前驱定义为小于 $x$ 的最大的数。那么如何找 $x​$ 的前驱呢？ 这里以 $6$ 为例，从根节点开始。 从前驱的定义可知，$6$ 的前驱一定比 $6$ 小。而 $9 &gt; 6$，所以把 $6$ 放在 $9$ 的左儿子。 $8$ 还是比 $6$ 大，因此我们把 $6$ 放到 $8$ 的左儿子。 我们发现 $3 &lt; 6$，但是并不知道 $3$ 是不是小于 $6$ 的数中最大的，我们还要去找比 $3$ 大的数，因为这些数也有可能成为答案。所以记录当前答案为 $3$，把 $6$ 放在 $3$ 的右儿子。 $5$ 还是比 $6$ 小，更新当前答案为 $5$，而 $5$ 没有右儿子，所以最后答案 （$6$ 的前驱）就是 $5$ 。 小结：寻找 $x$ 的前驱时，从根节点开始，依次比较 $x$ 和当前节点的值。如果当前节点的值大于 $x$，则往该节点的左儿子找，直到出现小于 $x$ 的节点。此时我们记录当前答案为这个节点的值，往这个节点的右儿子找，如果途中遇到的节点的值小于 $x$，就更新当前答案，否则结束查询，当前答案就是 $x$ 的前驱。 后继$x​$ 的后继定义为大于 $x​$ 的最小的数。 与前驱的操作恰恰相反，依次比较 $x​$ 和当前节点的值。如果当前节点的值小于 $x​$，则往该节点的右儿子找，直到出现大于 $x​$ 的节点。此时我们记录当前答案为这个节点的值，往这个节点的左儿子找，如果途中遇到的节点的值大于 $x​$，就更新当前答案，否则结束查询，当前答案就是 $x​$ 的后继。 已知排名求值排名定义为比当前数小的数的个数 $+1​$，现在需要寻找排名为 $x​$ 的数。 我们新定义一个数组 $size$，对于一个节点 $x$，$size[x]$ 表示 $x$ 以及它的子树大小之和，需要递归预处理出每个节点的 $size$，当然，插入与删除操作时也要更新 $size$ 数组。假设我们要寻找排名为 $7$ 的数是多少，从根节点开始，如图（红色的数字即为节点的 $size$）。 $9​$ 的左儿子的 $size​$ 为 $4​$，所以 $9​$ 的排名为 $5​$，而要寻找的数的排名为 $7​$，所以该数一定比 $9​$ 大，因此我们到 $9​$ 的右子树找。 此时到了一棵新的子树上，因为排名为 $5$ 以及 $5$ 之前的节点都不要了，所以我们需要在该子树上找排名为 $2$ 的数。$12$ 的左儿子的 $size$ 为 $2$，因此 $12$ 在该子树上的排名为 $3$，排名为 $2$ 的数一定比 $12$ 小，应该到 $12$ 的左子树找。 现在所在的子树又少了 $2$ 个节点，但这 $2$ 个节点的排名都比 $2$ 大，所以仍然在新子树中找排名为 $2$ 的数。因为 $10$ 没有左儿子（即 $size$ 为 $0$），所以 $10$ 的排名为 $1$，而要查询的数排名为 $2$，大于 $10$，应该到 $10$ 的右子树找。 排名为 $1​$ 的节点已经不要了，因此要在新子树中找排名为 $1​$ 的节点。而 $11​$ 没有左儿子（即 $size​$ 为 $0​$），所以 $11​$ 的排名为 $1​$ 。最后的答案就是 $11​$ 。 小结：已知排名求值时，先预处理出每个节点的子树大小 $size$，从根节点开始，依次检查每个节点的排名，每个节点 $x$ 的排名为它 左儿子的 $size$ 加上 $cnt[x]$ (该节点值的数量) 。如果该节点的排名比要查询的排名小，则在该节点的右子树中查询 当前要查询的排名 - 该节点排名 的数。如果该节点排名更大，就在左子树中继续查询这个排名的数。如果排名相等，则该节点的值就是答案。 已知值求排名与已知排名求值的过程相似，以查询 $11$ 的排名为例，从根节点开始，初始没有数比 $11$ 小，所以 $11$ 的排名为 $1​$ 。 $9​$ 的排名为它左儿子的 $size​$ 加上它的 $cnt​$，也就是 $5​$，显然 $9 &lt; 11​$，所以 $11​$ 的排名变为 $1 + 5 = 6​$，并且往 $9​$ 的右子树找。 因为 $12 &gt; 11$，没有数比 $11$ 小，所以往 $12$ 的左子树找。 $10$ 比 $11$ 小，因为 $10$ 没有左儿子（左儿子 $size$ 为 $0$），所以 $10$ 在该子树中的排名为 $1$ 。$11$ 的排名更新为 $6 + 1 = 7$，并往 $10$ 的右子树找。 与目标节点重合，停止查询，$7$ 即为 $11$ 的排名。 小结：已知值求排名时，初始化已知值的排名为 $1$ 。从根节点开始，依次检查每个节点的值，如果该节点的值比已知值小，则排名更新为 它当前的排名 加上 该节点的排名，每个节点 $x$ 的排名为它 左儿子的 $size$ 加上 $cnt[x]$ (该节点值的数量) ，往该节点的右子树走。如果该节点的值比已知值大，则往该节点的左子树走。如果与已知值相等，则停止查询，当前排名就是这个值最终的排名。 总结普通的二叉查找树在数据随机的情况下所有操作的时间复杂度都是 $O(\log n)$ 的，但是在最劣情况下会变成一条链，时间复杂度为 $O(n)$，因此我们需要旋转，分裂等操作来维护二叉查找树，使其时间复杂度稳定为 $O(\log n)$，这种二叉查找树称作平衡二叉树，简称平衡树。平衡树的常见实现方法有 Treap , Splay , AVL , 替罪羊树 , 红黑树 等，这里不作介绍。]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伸展树(Splay)小结]]></title>
    <url>%2Fnotes%2Fshen-zhan-shu-splay-xiao-jie%2F</url>
    <content type="text"><![CDATA[前置知识二叉查找树(BST) 线段树 简介伸展树(Splay Tree) 是平衡二叉树的一种，也属于二叉查找树，使用旋转保持平衡。它能在 $O(\log n)​$ 内完成插入、删除和查询操作，还具有很强的区间操作能力，所以也能作为 LCT 的辅助树，可以说是一种万能的平衡树。 原理咕咕咕]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
        <tag>Splay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 3211」花神游历各国]]></title>
    <url>%2Fproblems%2Fbzoj-3211%2F</url>
    <content type="text"><![CDATA[Description给定 $n\ (n \leq 10^5)​$ 个数，已知 $\sum\limits_{i=1}^{n}a_i \leq 10^{18}​$。 $m\ (m \leq 10^5)$ 个操作（操作有 $2$ 种）： 1 x y：询问区间 $[x,y]\ (1 \leq x,y \leq n)$ 所有数的和（不保证 $x \leq y$，若 $x &gt; y$，则交换 $x,y$）。 2 x y：将区间 $[x,y]\ (1 \leq x,y \leq n)$ 内的每一个数开 平方根（下取整） 。 Source[BZOJ]3211 Solution 前置知识： 线段树 因为要维护区间和，所以我们想到用线段树来维护。 但是会发现懒惰标记不能打，那该怎么办呢？ 考虑暴力修改： $a[i]$ 最大为 $10^{18}$。 \left \lfloor \sqrt{\sqrt{\sqrt{\sqrt{\sqrt{\sqrt{10^{18}}}}}}}\right \rfloor = 1换言之， \left \lfloor \sqrt[2^6]{10^{18}}\right \rfloor = 1一个数最多开 $6$ 次平方根就会变成 $1$ 。 因为 $\sqrt{1} = 1,\sqrt{0} = 0$， 我们只需要维护 区间和 与 区间最大值 即可， 当一个区间的最大值 $\leq 1$ 时，我们对这个区间的修改就是无用的，因为无论怎么修改这个数仍是它本身。 而我们对一个数的开平方操作不会超过 $6$ 次，所以时间复杂度仍是 $O(n \log n)$ 。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1, len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1e5 + 10;struct SegmentTree &#123; LL sum[MAXN &lt;&lt; 2], maxx[MAXN &lt;&lt; 2]; inline int lson(int x) &#123; return x &lt;&lt; 1; &#125; inline int rson(int x) &#123; return x &lt;&lt; 1 | 1; &#125; inline void pushUp(int x) &#123; sum[x] = sum[lson(x)] + sum[rson(x)]; maxx[x] = max(maxx[lson(x)], maxx[rson(x)]); &#125; void build(int x, int l, int r, LL *a) &#123; if (l == r) &#123; sum[x] = a[l]; maxx[x] = a[l]; return; &#125; int mid = (l + r) &gt;&gt; 1; build(lson(x), l, mid, a), build(rson(x), mid + 1, r, a); pushUp(x); &#125; void update(int ql, int qr, int l, int r, int x) &#123; if (maxx[x] &lt;= 1) return;//如果区间最大值小于等于1，就可以直接忽略这个区间的修改操作 if (l == r) &#123; sum[x] = sqrt(sum[x]); maxx[x] = sqrt(maxx[x]); return; &#125; int mid = (l + r) &gt;&gt; 1; if (ql &lt;= mid) update(ql, qr, l, mid, lson(x)); if (qr &gt; mid) update(ql, qr, mid + 1, r, rson(x)); pushUp(x); &#125; LL query(int ql, int qr, int l, int r, int x) &#123; if (ql &lt;= l &amp;&amp; qr &gt;= r) return sum[x]; int mid = (l + r) &gt;&gt; 1; LL res = 0; if (ql &lt;= mid) res += query(ql, qr, l, mid, lson(x)); if (qr &gt; mid) res += query(ql, qr, mid + 1, r, rson(x)); return res; &#125;&#125; tr;int n, m;LL a[MAXN];int main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) read(a[i]); tr.build(1, 1, n, a); read(m); for (int opt, l, r, i = 1; i &lt;= m; ++i) &#123; read(opt), read(l), read(r); if (l &gt; r) swap(l, r); if (opt == 1) &#123; write(tr.query(l, r, 1, n, 1)); putchar('\n'); &#125; else tr.update(l, r, 1, n, 1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P4145」上帝造题的七分钟2/花神游历各国]]></title>
    <url>%2Fproblems%2Fluogu-p4145%2F</url>
    <content type="text"><![CDATA[Description给定 $n\ (n \leq 10^5)​$ 个数，已知 $\sum\limits_{i=1}^{n}a_i \leq 10^{18}​$。 $m\ (m \leq 10^5)$ 个操作（操作有 $2$ 种）： 0 x y：将区间 $[x,y]\ (1 \leq x,y \leq n)$ 内的每一个数开 平方根（下取整） 。 1 x y：询问区间 $[x,y]\ (1 \leq x,y \leq n)$ 所有数的和（不保证 $x \leq y$，若 $x &gt; y$，则交换 $x,y$）。 Source[Luogu]P4145 Solution 前置知识： 线段树 因为要维护区间和，所以我们想到用线段树来维护。 但是会发现懒惰标记不能打，那该怎么办呢？ 考虑暴力修改： $a[i]$ 最大为 $10^{18}$。 \left \lfloor \sqrt{\sqrt{\sqrt{\sqrt{\sqrt{\sqrt{10^{18}}}}}}}\right \rfloor = 1换言之， \left \lfloor \sqrt[2^6]{10^{18}}\right \rfloor = 1一个数最多开 $6$ 次平方根就会变成 $1$ 。 因为 $\sqrt{1} = 1,\sqrt{0} = 0$， 我们只需要维护 区间和 与 区间最大值 即可， 当一个区间的最大值 $\leq 1$ 时，我们对这个区间的修改就是无用的，因为无论怎么修改这个数仍是它本身。 而我们对一个数的开平方操作不会超过 $6$ 次，所以时间复杂度仍是 $O(n \log n)$ 。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1, len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1e5 + 10;struct SegmentTree &#123; LL sum[MAXN &lt;&lt; 2], maxx[MAXN &lt;&lt; 2]; inline int lson(int x) &#123; return x &lt;&lt; 1; &#125; inline int rson(int x) &#123; return x &lt;&lt; 1 | 1; &#125; inline void pushUp(int x) &#123; sum[x] = sum[lson(x)] + sum[rson(x)]; maxx[x] = max(maxx[lson(x)], maxx[rson(x)]); &#125; void build(int x, int l, int r, LL *a) &#123; if (l == r) &#123; sum[x] = a[l]; maxx[x] = a[l]; return; &#125; int mid = (l + r) &gt;&gt; 1; build(lson(x), l, mid, a), build(rson(x), mid + 1, r, a); pushUp(x); &#125; void update(int ql, int qr, int l, int r, int x) &#123; if (maxx[x] &lt;= 1) return;//如果区间最大值小于等于1，就可以直接忽略这个区间的修改操作 if (l == r) &#123; sum[x] = sqrt(sum[x]); maxx[x] = sqrt(maxx[x]); return; &#125; int mid = (l + r) &gt;&gt; 1; if (ql &lt;= mid) update(ql, qr, l, mid, lson(x)); if (qr &gt; mid) update(ql, qr, mid + 1, r, rson(x)); pushUp(x); &#125; LL query(int ql, int qr, int l, int r, int x) &#123; if (ql &lt;= l &amp;&amp; qr &gt;= r) return sum[x]; int mid = (l + r) &gt;&gt; 1; LL res = 0; if (ql &lt;= mid) res += query(ql, qr, l, mid, lson(x)); if (qr &gt; mid) res += query(ql, qr, mid + 1, r, rson(x)); return res; &#125;&#125; tr;int n, m;LL a[MAXN];int main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) read(a[i]); tr.build(1, 1, n, a); read(m); for (int opt, l, r, i = 1; i &lt;= m; ++i) &#123; read(opt), read(l), read(r); if (l &gt; r) swap(l, r); if (opt == 1) &#123; write(tr.query(l, r, 1, n, 1)); putchar('\n'); &#125; else tr.update(l, r, 1, n, 1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SPOJ 2713」GSS4 - Can you answer these queries Ⅳ]]></title>
    <url>%2Fproblems%2Fspoj-2713%2F</url>
    <content type="text"><![CDATA[Description给定 $n\ (n \leq 10^5)​$ 个数，已知 $\sum\limits_{i=1}^{n}a_i \leq 10^{18}​$。 $m\ (m \leq 10^5)$ 个操作（操作有 $2$ 种）： 0 x y：将区间 $[x,y]\ (1 \leq x,y \leq n)$ 内的每一个数开 平方根（下取整） 。 1 x y：询问区间 $[x,y]\ (1 \leq x,y \leq n)$ 所有数的和（不保证 $x \leq y$，若 $x &gt; y$，则交换 $x,y$）。 Source[Luogu]SP2713 [SPOJ]GSS4 Solution 前置知识： 线段树 因为要维护区间和，所以我们想到用线段树来维护。 但是会发现懒惰标记不能打，那该怎么办呢？ 考虑暴力修改： $a[i]$ 最大为 $10^{18}$。 \left \lfloor \sqrt{\sqrt{\sqrt{\sqrt{\sqrt{\sqrt{10^{18}}}}}}}\right \rfloor = 1换言之， \left \lfloor \sqrt[2^6]{10^{18}}\right \rfloor = 1一个数最多开 $6$ 次平方根就会变成 $1$ 。 因为 $\sqrt{1} = 1,\sqrt{0} = 0$， 我们只需要维护 区间和 与 区间最大值 即可， 当一个区间的最大值 $\leq 1$ 时，我们对这个区间的修改就是无用的，因为无论怎么修改这个数仍是它本身。 而我们对一个数的开平方操作不会超过 $6$ 次，所以时间复杂度仍是 $O(n \log n)$ 。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1, len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1e5 + 10;struct SegmentTree &#123; LL sum[MAXN &lt;&lt; 2], maxx[MAXN &lt;&lt; 2]; inline int lson(int x) &#123; return x &lt;&lt; 1; &#125; inline int rson(int x) &#123; return x &lt;&lt; 1 | 1; &#125; inline void pushUp(int x) &#123; sum[x] = sum[lson(x)] + sum[rson(x)]; maxx[x] = max(maxx[lson(x)], maxx[rson(x)]); &#125; void build(int x, int l, int r, LL *a) &#123; if (l == r) &#123; sum[x] = a[l]; maxx[x] = a[l]; return; &#125; int mid = (l + r) &gt;&gt; 1; build(lson(x), l, mid, a), build(rson(x), mid + 1, r, a); pushUp(x); &#125; void update(int ql, int qr, int l, int r, int x) &#123; if (maxx[x] &lt;= 1) return;//如果区间最大值小于等于1，就可以直接忽略这个区间的修改操作 if (l == r) &#123; sum[x] = sqrt(sum[x]); maxx[x] = sqrt(maxx[x]); return; &#125; int mid = (l + r) &gt;&gt; 1; if (ql &lt;= mid) update(ql, qr, l, mid, lson(x)); if (qr &gt; mid) update(ql, qr, mid + 1, r, rson(x)); pushUp(x); &#125; LL query(int ql, int qr, int l, int r, int x) &#123; if (ql &lt;= l &amp;&amp; qr &gt;= r) return sum[x]; int mid = (l + r) &gt;&gt; 1; LL res = 0; if (ql &lt;= mid) res += query(ql, qr, l, mid, lson(x)); if (qr &gt; mid) res += query(ql, qr, mid + 1, r, rson(x)); return res; &#125;&#125; tr;int n, m;LL a[MAXN];int main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) read(a[i]); tr.build(1, 1, n, a); read(m); for (int opt, l, r, i = 1; i &lt;= m; ++i) &#123; read(opt), read(l), read(r); if (l &gt; r) swap(l, r); if (opt == 1) &#123; write(tr.query(l, r, 1, n, 1)); putchar('\n'); &#125; else tr.update(l, r, 1, n, 1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>SPOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SPOJ 1716」GSS3 - Can you answer these queries Ⅲ]]></title>
    <url>%2Fproblems%2Fspoj-1716%2F</url>
    <content type="text"><![CDATA[Description给定一个长度为 $n\ (n \leq 50000, \mid a_i \mid \leq 10000)​$ 的整数序列 和 $m\ (m \leq 50000)​$ 个操作（操作有 $2​$ 种）： 0 x y：把 $a_x\ (1 \leq x \leq n)​$ 的值修改为 $y\ (\mid y \mid \leq 10000)​$。 1 x y： 询问区间 $[x,y]\ (1 \leq x \leq y \leq n)$ 的最大子段和。 Source[Luogu]SP1716 [SPOJ]GSS3 Solution 前置知识： 线段树 仅仅是比 「SPOJ1043」GSS1 多了一个单点修改操作，暴力修改并且加上 $\mathrm{pushUp}$ 操作即可。 $\mathrm{pushUp}$ 操作 和 $\mathrm{query}$ 操作 的详细实现过程请看上一行链接。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1, len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 5e4 + 10;struct SegmentTree &#123; struct Node &#123; LL sum, lsum, rsum, res; &#125; seg[MAXN &lt;&lt; 2]; inline int lson(int x) &#123; return x &lt;&lt; 1; &#125; inline int rson(int x) &#123; return x &lt;&lt; 1 | 1; &#125; inline void pushUp(int x) &#123; seg[x].sum = seg[lson(x)].sum + seg[rson(x)].sum; seg[x].res = max(max(seg[lson(x)].res, seg[rson(x)].res), seg[lson(x)].rsum + seg[rson(x)].lsum); seg[x].lsum = max(seg[lson(x)].lsum, seg[lson(x)].sum + seg[rson(x)].lsum); seg[x].rsum = max(seg[rson(x)].rsum, seg[lson(x)].rsum + seg[rson(x)].sum); &#125; void build(int x, int l, int r, LL *a) &#123; if (l == r) &#123; seg[x] = (Node) &#123; a[l], a[l], a[l], a[l] &#125;; return; &#125; int mid = (l + r) &gt;&gt; 1; build(lson(x), l, mid, a), build(rson(x), mid + 1, r, a); pushUp(x); &#125; void update(int q, int l, int r, int x, LL p) &#123; if (l == r) &#123; seg[x] = (Node) &#123; p, p, p, p &#125;; return; &#125; int mid = (l + r) &gt;&gt; 1; if (q &lt;= mid) update(q, l, mid, lson(x), p); else update(q, mid + 1, r, rson(x), p); pushUp(x); &#125; Node query(int ql, int qr, int l, int r, int x) &#123; if (ql &lt;= l &amp;&amp; qr &gt;= r) return seg[x]; int mid = (l + r) &gt;&gt; 1; if (qr &lt;= mid) return query(ql, qr, l, mid, lson(x)); if (ql &gt; mid) return query(ql, qr, mid + 1, r, rson(x)); Node ans, lx = query(ql, qr, l, mid, lson(x)), ly = query(ql, qr, mid + 1, r, rson(x)); ans.sum = lx.sum + ly.sum; ans.res = max(max(lx.res, ly.res), lx.rsum + ly.lsum); ans.lsum = max(lx.lsum, lx.sum + ly.lsum); ans.rsum = max(ly.rsum, lx.rsum + ly.sum); return ans; &#125;&#125; tr;int n, q, l, r;bool opt;LL a[MAXN];int main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) read(a[i]); tr.build(1, 1, n, a); for (read(q); q; --q) &#123; read(opt), read(l), read(r); if (!opt) tr.update(l, 1, n, 1, r); else &#123; write(tr.query(l, r, 1, n, 1).res); putchar('\n'); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>SPOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SPOJ 1043」GSS1 - Can you answer these queries Ⅰ]]></title>
    <url>%2Fproblems%2Fspoj-1043%2F</url>
    <content type="text"><![CDATA[Description给定一个长度为 $n\ (n \leq 50000, \mid a_i \mid \leq 15007)$ 的整数序列，对于 $m\ (m \leq 50000)$ 个询问 $l,r\ (1 \leq l \leq r \leq n)$，求区间 $[l,r]$ 的最大子段和。 Source[Luogu]SP1043 [SPOJ]GSS1 Solution 前置知识： 线段树 如果用朴素的最大子段和算法，时间复杂度为 $O(nm)$，一定会超时。 很容易想到用数据结构来维护。 我们建立一棵线段树，对于区间 $x$，有以下定义： $sum[x]$ 表示区间和； $lsum[x]$ 表示以该区间左端点为起点的最大子段和； $rsum[x]$ 表示以该区间右端点为起点的最大子段和； $res[x]$ 表示该区间内的最大子段和。 与普通的线段树不同，这道题维护的信息很多，我们先来分析该题最重要的 $\mathrm{pushUp}$ 与 $\mathrm{query}$ 操作。 $\mathrm{pushUp}$ 操作首先，是维护区间和，最基本的线段树操作，就不用多说了： \large{sum[x] = sum[lson(x)] + sum[rson(x)]}其次，假如我们知道一个区间的左右子区间信息，如何更新该区间的最大子段和？ 很显然，答案可能为 左区间的最大子段和 或 右区间的最大子段和 。 除此之外，合并区间后，答案也有可能为 左区间的右起最大子段和 + 右区间的左起最大子段和，如上图。 由此我们可以得到代码： \large{res[x]=\max\begin{Bmatrix}res[lson(x)],res[rson(x)],rsum[lson(x)]+lsum[rson(x)]\end{Bmatrix}}那如何更新该区间的 左起最大子段和 和 右起最大子段和 呢？ 区间左起最大子段和可以是 左区间的左起最大子段和 或 左区间的区间和 + 右区间的左起最大子段和，如上图。 右起最大子段和将上述操作反过来即可。 代码实现如下： \large{\begin{aligned} lsum[x]&=\max(lsum[lson],sum[lson]+lsum[rson])\\[2ex] rsum[x]&=\max(rsum[rson],rsum[lson]+sum[rsum]) \end{aligned}}$\mathrm{query}$ 操作 当答案来自两个不同的区间时（如图），我们需要对这两个区间答案进行合并，并不只是取最大值那样简单。 我们还需要进行类似 $\mathrm{pushUp}​$ 的操作，已知左右区间的答案，更新该区间答案。 函数的返回值有很多，所以用结构体式线段树实现更方便。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1, len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 5e4 + 10;struct SegmentTree &#123; struct Node &#123; LL sum, lsum, rsum, res; &#125; seg[MAXN &lt;&lt; 2]; inline int lson(int x) &#123; return x &lt;&lt; 1; &#125; inline int rson(int x) &#123; return x &lt;&lt; 1 | 1; &#125; inline void pushUp(int x) &#123; seg[x].sum = seg[lson(x)].sum + seg[rson(x)].sum; seg[x].res = max(max(seg[lson(x)].res, seg[rson(x)].res), seg[lson(x)].rsum + seg[rson(x)].lsum); seg[x].lsum = max(seg[lson(x)].lsum, seg[lson(x)].sum + seg[rson(x)].lsum); seg[x].rsum = max(seg[rson(x)].rsum, seg[lson(x)].rsum + seg[rson(x)].sum); &#125; void build(int x, int l, int r, LL *a) &#123; if (l == r) &#123; seg[x] = (Node) &#123; a[l], a[l], a[l], a[l] &#125;; return; &#125; int mid = (l + r) &gt;&gt; 1; build(lson(x), l, mid, a), build(rson(x), mid + 1, r, a); pushUp(x); &#125; Node query(int ql, int qr, int l, int r, int x) &#123;//分成3种情况考虑 if (ql &lt;= l &amp;&amp; qr &gt;= r) return seg[x]; int mid = (l + r) &gt;&gt; 1; if (qr &lt;= mid) return query(ql, qr, l, mid, lson(x)); if (ql &gt; mid) return query(ql, qr, mid + 1, r, rson(x)); Node ans, lx = query(ql, qr, l, mid, lson(x)), ly = query(ql, qr, mid + 1, r, rson(x)); ans.sum = lx.sum + ly.sum; ans.res = max(max(lx.res, ly.res), lx.rsum + ly.lsum); ans.lsum = max(lx.lsum, lx.sum + ly.lsum); ans.rsum = max(ly.rsum, lx.rsum + ly.sum); return ans; &#125;&#125; tr;int n, q, l, r;LL a[MAXN];int main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) read(a[i]); tr.build(1, 1, n, a); for (read(q); q; --q) &#123; read(l), read(r); write(tr.query(l, r, 1, n, 1).res); putchar('\n'); &#125; return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>SPOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 1303」「CQOI2009」中位数图]]></title>
    <url>%2Fproblems%2Fbzoj-1303%2F</url>
    <content type="text"><![CDATA[Description给定长度为 $n\ (n \leq 10^5)$ 的排列，求有多少包含 $b\ (1 \leq b \leq n)$ 的奇数长度的序列中位数为 $b$ 。 Source[BZOJ]1303 Solution因为所求的是中位数，所以考虑改变原序列。把大于 $b$ 的数全部变为 $1$，小于 $b$ 的数变为 $-1$，等于 $b$ 则为 $0$ 。问题就变为求存在几个包含 $b$ 的区间和为 $0$ 。我们假设 $tmp$ 为 $b$ 的下标，原数组为 $x$，新数组为 $a​$ 。 Sample Input127 45 7 2 4 3 1 6 Sample Output14 Example 对于样例，能使结果成立的 $4$ 个区间分别为 $[1,5]$，$[1,7]$，$[2,4]$，$[4,4]$ 。 接下来我们建造两个桶，分别计数 $tmp​$ 左边的后缀和与右边的前缀和，假设左边的后缀和为 $l​$，右边的前缀和为 $r​$ 。$l[i]/r[i]​$ 表示从点 $i​$ 向右/向左 到点 $tmp​$ 为止 (比 $b​$ 大的数的数量 - 比 $b​$ 小的数的数量) 出现的次数。还是拿样例来说： 通过观察上图，我们能够发现，左边的数 $x​$ 可以与右边的每一个 $-x​$ 进行匹配。通过乘法原理，该值即为 $l[x] \times r[-x]​$，由题意可知 $-10^5 \le x \le 10^5​$，遍历所有的 $x​$ 即可，最终答案为： \sum\limits_{i=\min{x}}^{\max{x}}l[i] \times r[-i]值得注意的是，$l[0]$ 和 $r[0]$ 的初始值为 $1$，因为 $b$ 是需要被算入的。当然，桶的下标不能是负数，所以我在每次操作时都加上了一个很大的数，比如数据最大值 —— $10^5$，也可以用 $\mathrm{STL}$ 中的 $map$ 解决问题，时间复杂度为 $O(n)$ 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1, len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1e5;int n, b, tmp, sum, a[MAXN + 10], l[MAXN &lt;&lt; 1 | 1], r[MAXN &lt;&lt; 1 | 1];LL ans;int main() &#123; read(n), read(b); for (int x, i = 1; i &lt;= n; ++i) &#123; read(x); if (x == b) tmp = i; else a[i] = x &gt; b ? 1 : -1; &#125; ++l[MAXN], ++r[MAXN]; for (int i = tmp - 1; i &gt;= 1; --i) &#123; sum += a[i]; ++l[sum + MAXN]; &#125;//后缀和 sum = 0; for (int i = tmp + 1; i &lt;= n; ++i) &#123; sum += a[i]; ++r[sum + MAXN]; &#125;//前缀和 for (int i = -MAXN; i &lt;= MAXN; ++i) ans += (LL) l[i + MAXN] * (LL) r[-i + MAXN];//公式计算答案 write(ans); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>数论数学</tag>
        <tag>2009</tag>
        <tag>CQOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P1627」「CQOI2009」中位数图]]></title>
    <url>%2Fproblems%2Fluogu-p1627%2F</url>
    <content type="text"><![CDATA[Description给定长度为 $n\ (n \leq 10^5)$ 的排列，求有多少包含 $b\ (1 \leq b \leq n)$ 的奇数长度的序列中位数为 $b$ 。 Source[Luogu]P1627 Solution因为所求的是中位数，所以考虑改变原序列。把大于 $b$ 的数全部变为 $1$，小于 $b$ 的数变为 $-1$，等于 $b$ 则为 $0$ 。问题就变为求存在几个包含 $b$ 的区间和为 $0$ 。我们假设 $tmp$ 为 $b$ 的下标，原数组为 $x$，新数组为 $a​$ 。 Sample Input127 45 7 2 4 3 1 6 Sample Output14 Example 对于样例，能使结果成立的 $4$ 个区间分别为 $[1,5]$，$[1,7]$，$[2,4]$，$[4,4]$ 。 接下来我们建造两个桶，分别计数 $tmp​$ 左边的后缀和与右边的前缀和，假设左边的后缀和为 $l​$，右边的前缀和为 $r​$ 。$l[i]/r[i]​$ 表示从点 $i​$ 向右/向左 到点 $tmp​$ 为止 (比 $b​$ 大的数的数量 - 比 $b​$ 小的数的数量) 出现的次数。还是拿样例来说： 通过观察上图，我们能够发现，左边的数 $x​$ 可以与右边的每一个 $-x​$ 进行匹配。通过乘法原理，该值即为 $l[x] \times r[-x]​$，由题意可知 $-10^5 \le x \le 10^5​$，遍历所有的 $x​$ 即可，最终答案为： \sum\limits_{i=\min{x}}^{\max{x}}l[i] \times r[-i]值得注意的是，$l[0]$ 和 $r[0]$ 的初始值为 $1$，因为 $b$ 是需要被算入的。当然，桶的下标不能是负数，所以我在每次操作时都加上了一个很大的数，比如数据最大值 —— $10^5$，也可以用 $\mathrm{STL}$ 中的 $map$ 解决问题，时间复杂度为 $O(n)$ 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1, len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1e5;int n, b, tmp, sum, a[MAXN + 10], l[MAXN &lt;&lt; 1 | 1], r[MAXN &lt;&lt; 1 | 1];LL ans;int main() &#123; read(n), read(b); for (int x, i = 1; i &lt;= n; ++i) &#123; read(x); if (x == b) tmp = i; else a[i] = x &gt; b ? 1 : -1; &#125; ++l[MAXN], ++r[MAXN]; for (int i = tmp - 1; i &gt;= 1; --i) &#123; sum += a[i]; ++l[sum + MAXN]; &#125;//后缀和 sum = 0; for (int i = tmp + 1; i &lt;= n; ++i) &#123; sum += a[i]; ++r[sum + MAXN]; &#125;//前缀和 for (int i = -MAXN; i &lt;= MAXN; ++i) ans += (LL) l[i + MAXN] * (LL) r[-i + MAXN];//公式计算答案 write(ans); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>数论数学</tag>
        <tag>2009</tag>
        <tag>CQOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用距离算法详解]]></title>
    <url>%2Fnotes%2Fchang-yong-ju-li-suan-fa-xiang-jie%2F</url>
    <content type="text"><![CDATA[前言在计算距离时，我们一般都是求两点之间的直线距离，实际上距离算法并不只这一种，还有其他的距离算法在 $\mathrm{OI}$ 中也同样很重要。不同的距离算法都有明显的优缺点。本文主要讲解 三种 常见的距离算法，分别是 欧氏距离，曼哈顿距离，切比雪夫距离 。 一、欧氏距离（欧几里得度量）欧氏距离，是一个通常采用的距离定义，指在 $m​$ 维空间中两个点之间的真实距离，或者向量的自然长度（即该点到原点的距离）。在二维和三维空间中的欧氏距离就是两点之间的实际距离。—— 来源：百度百科 欧氏距离 是最易于理解的一种距离算法。在数学的平面直角坐标系中，设点 $A,B$ 的坐标分别为 $A(x_1,y_1),B(x_2,y_2)$，求点 $A,B$ 之间的距离，我们一般会使用如下公式： \left | AB \right | = \sqrt{\left ( x_2 - x_1 \right )^2 + \left ( y_2 - y_1 \right )^2}实际上这就是平面（二维空间）中两点欧氏距离的距离公式，除此之外，$P(x,y)$ 到原点的欧氏距离可以用公式表示为： \left | P \right | = \sqrt{x^2+y^2}举个例子，在下图中 $A,B$ 的坐标分别为 $A(6,5),B(2,2)$。 通过公式，我们很容易得到 $A,B​$ 两点间的欧氏距离： \left | AB \right | = \sqrt{\left ( 2 - 6 \right )^2 + \left ( 2 - 5 \right )^2} = \sqrt{4^2+3^2} = 5那么，三维空间 中两点的欧氏距离公式呢？我们来观察下图。 我们很容易发现，在$\triangle ADC$中，$\angle ADC = 90^\circ$；在$\triangle ACB$中，$\angle ACB = 90^\circ$ 。 \begin{aligned} \therefore \left | AB\right | &=\sqrt{\left | AC\right | ^2+\left | BC\right | ^2}\\ &=\sqrt{\left | AD\right | ^2+\left | CD\right | ^2+\left | BC\right | ^2}\\ \end{aligned}由此可得，三维空间 中欧氏距离的距离公式为： \left | AB \right | = \sqrt{\left ( x_2 - x_1 \right )^2 + \left ( y_2 - y_1 \right )^2 + \left ( z_2 - z_1 \right )^2} \left | P\right | = \sqrt{x^2+y^2+z^2}例题：[Luogu]P3958 以此类推，我们就得到了 $n$ 维空间 中欧氏距离的距离公式： \begin{aligned} d(x,y) &= \sqrt{\left ( x_1 - y_1 \right )^2 + \left ( x_2 - y_2 \right )^2 + \cdots +\left ( x_n - y_n \right )^2}\\ &= \sqrt{\sum\limits_{i = 1}^{n}(x_i - y_i)^2}\\ \end{aligned}欧氏距离虽然很有用，但也有明显的缺点。两个整点计算其欧氏距离时，往往答案是浮点型，会存在一定误差。 二、曼哈顿距离曼哈顿距离 是种使用在几何度量空间的几何学用语，用以标明两个点在标准坐标系上的绝对轴距总和。曼哈顿距离不是距离不变量，当坐标轴变动时，点间的距离就会不同。—— 来源：百度百科 在 二维空间 内，两个点之间的曼哈顿距离为它们横坐标之差的绝对值与纵坐标之差的绝对值之和。设点 $A(x_1,y_1),B(x_2,y_2)$，则 $A,B$ 之间的曼哈顿距离用公式可以表示为： d(A,B) = \left | x_1 - x_2\right | + \left | y_1 - y_2 \right |观察下图： 在 $A,B​$ 间，$\color{yellow}{黄线}​$，$\color{orange}{橙线}​$ 都表示曼哈顿距离，而$\color{red}{红线}​$，$\color{blue}{蓝线}​$ 表示 等价 的曼哈顿距离，$\color{green}{绿线}​$ 表示欧氏距离。 同样的例子，在下图中 $A,B$ 的坐标分别为 $A(6,5),B(2,2)$ 。 通过公式，我们很容易得到 $A,B$ 两点间的曼哈顿距离： d(A,B) = \left | 6 - 2\right | + \left | 5 - 2\right | = 4 + 3 = 7经过推导，我们得到 $n​$ 维空间 的曼哈顿距离公式为： \begin{aligned} d(A,B) &= \left | x_1 - y_1\right | + \left | x_2 - y_2\right | + \cdots + \left | x_n - y_n\right | \\[2ex] &=\sum\limits_{i = 1}^{n}\left | x_i - y_i\right | \\ \end{aligned}除了公式之外，曼哈顿距离还具有以下 数学性质： 非负性 曼哈顿距离是一个非负数。 $d(i,j)\geq 0$ 统一性 点到自身的曼哈顿距离为 $0$。 $d(i,i) = 0$ 对称性 $A$ 到 $B$ 与 $B$ 到 $A$ 的曼哈顿距离相等，且是对称函数。 $d(i,j) = d(j,i)$ 三角不等式 从点 $i$ 到 $j$ 的直接距离不会大于途经的任何其它点 $k$ 的距离。 $d(i,j)\leq d(i,k)+d(k,j)$ 例题：[Luogu]P5098 解析： 根据题意，对于式子 $\left | x_1-x_2\right| +\left | y_1-y_2\right| $，我们可以假设 $x_1 - x_2 \geq 0$，根据 $y_1 - y_2$ 的符号分成两种情况： (y_1 - y_2 \geq 0)\rightarrow \left | x_1-x_2\right| +\left | y_1-y_2\right| =x_1 + y_1 - (x_2 + y_2) (y_1 - y_2< 0)\rightarrow \left | x_1-x_2\right| +\left | y_1-y_2\right| =x_1 - y_1 - (x_2 - y_2)只要分别求出 $x+y, x-y​$ 的最大值和最小值即能得出答案。 Code 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1, len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;int n, x, y, minx = 0x7fffffff, maxx, miny = 0x7fffffff, maxy;int main() &#123; read(n); for (int i = 1; i &lt;= n; i++) &#123; read(x), read(y); minx = min(minx, x + y), maxx = max(maxx, x + y); miny = min(miny, x - y), maxy = max(maxy, x - y); &#125; write(max(maxx - minx, maxy - miny)); putchar('\n'); return 0;&#125; 其实还有第二种做法，那就是把 曼哈顿距离 转化为 切比雪夫距离 求解，后面会讲到。 三、切比雪夫距离切比雪夫距离 是向量空间中的一种度量，二个点之间的距离定义是其各坐标数值差绝对值的最大值。—— 来源：百度百科 在 二维空间 内，两个点之间的切比雪夫距离为它们横坐标之差的绝对值与纵坐标之差的绝对值的最大值。设点 $A(x_1,y_1),B(x_2,y_2)$，则 $A,B$ 之间的切比雪夫距离用公式可以表示为： d(A,B) = max(\left | x_1 - x_2\right | , \left | y_1 - y_2\right | )仍然是这个例子，下图中 $A,B$ 的坐标分别为 $A(6,5),B(2,2)$。 d(A,B) = \max(\left | 6 - 2\right | , \left | 5 - 2\right | )=\max(4,3)=4同理，$n$ 维空间 中切比雪夫距离的距离公式： \begin{aligned} d(x,y) &= \max\begin{Bmatrix} \left | x_1 - y_1\right | ,\left | x_2 - y_2\right |,\ldots,\left | x_n - y_n\right |\end{Bmatrix}\\ &= \max\begin{Bmatrix} \left | x_i - y_i\right | \end{Bmatrix}(i \in n)\\ \end{aligned}四、（拓展）曼哈顿距离与切比雪夫距离的相互转化首先，我们考虑画出平面直角坐标系上所有到原点的 曼哈顿距离 为 $1​$ 的点。 通过公式，我们很容易得到方程 $\left | x\right| +\left | y\right| = 1$。 将绝对值展开，得到 $4​$ 个 一次函数 ，分别是： y = x + 1\ (x \geq 0, y \geq 0) y = -x + 1\ (x \leq 0, y \geq 0) y = x - 1\ (x \geq 0, y \leq 0) y = -x - 1\ (x \leq 0, y \leq 0)将这 $4​$ 个函数画到平面直角坐标系上，得到一个边长为 $\sqrt{2}​$ 的正方形，如下图所示： 正方形边界上所有的点到原点的 曼哈顿距离 都是 $1$ 。 同理，我们再考虑画出平面直角坐标系上所有到原点的 切比雪夫距离 为 $1$ 的点。 通过公式，我们知道 $\max(\left |x\right | ,\left | y\right| )=1$。 我们将式子展开，也同样可以得到可以得到 $4$ 条 线段，分别是： y = 1\ (-1\leq x \leq 1) y = -1\ (-1\leq x \leq 1) x = 1\ (-1\leq y \leq 1) x = -1\ (-1\leq y \leq 1)画到平面直角坐标系上，可以得到一个边长为 $2​$ 的正方形，如下图所示： 正方形边界上所有的点到原点的 切比雪夫距离 都是 $1$ 。 将这两幅图对比，我们会神奇地发现： 这 $2​$ 个正方形是 相似图形 。 所以，曼哈顿距离 与 切比雪夫距离 之间会不会有联系呢？ 接下来我们简略证明一下： 假设 $A(x_1,y_1),B(x_2,y_2)$， $A,B$ 两点的 曼哈顿距离 为： \begin{aligned} d(A,B)&=\left | x_1 - x_2\right | + \left | y_1 - y_2\right | \\ &= \max\begin{Bmatrix} x_1 - x_2 + y_1 - y_2, x_1 - x_2 + y_2 - y_1,x_2 - x_1 + y_1 - y_2, x_2 - x_1 + y_2 - y_1\end{Bmatrix}\\ &（把绝对值拆开，能够得到四个值，这四个值中的最大值是两个 非负数 之和，即 曼哈顿距离）\\ &= \max\begin{Bmatrix}\left | (x_1 + y_1) - (x_2 + y_2)\right | , \left | (x_1 - y_2) - (x_2 - y_2)\right | \end{Bmatrix}\\ \end{aligned}我们很容易发现，这就是 $(x_1 + y_1,x_1 - y_1), (x_2 + y_2,x_2 - y_2)$ 两点之间的 切比雪夫距离。 所以将每一个点 $(x,y)$ 转化为 $(x + y, x - y)$，新坐标系下的 切比雪夫距离 即为原坐标系下的 曼哈顿距离。 同理，$A,B$ 两点的 切比雪夫距离 为： \begin{aligned} d(A,B)&=\max\begin{Bmatrix} \left | x_1 - x_2\right | ,\left | y_1 - y_2\right | \end{Bmatrix}\\ &=\max\begin{Bmatrix} \left | \frac{x_1 + y_1}{2}-\frac{x_2 + y_2}{2}\right | +\left |\frac{x_1 - y_1}{2}-\frac{x_2 - y_2}{2}\right | \end{Bmatrix}\\ \end{aligned}而这就是 $\left(\frac{x_1 + y_1}{2},\frac{x_1 - y_1}{2}\right),\left (\frac{x_2 + y_2}{2},\frac{x_2 - y_2}{2}\right)​$ 两点之间的 曼哈顿距离。 所以将每一个点 $(x,y)​$ 转化为 $\left(\frac{x + y}{2},\frac{x - y}{2}\right)​$，新坐标系下的 曼哈顿距离 即为原坐标系下的 切比雪夫距离。 结论： 将切比雪夫坐标系旋转 $45^\circ$，再缩小到原来的一半，即可得到曼哈顿坐标系。 将点 $(x,y)​$ 的坐标变为 $(x + y, x - y)​$， 原坐标系中的 曼哈顿距离 $=​$ 新坐标系中的 切比雪夫距离 将点 $(x,y)$ 的坐标变为 $\left( \frac{x + y}{2},\frac{x - y}{2} \right)$， 原坐标系中的 切比雪夫距离 $=​$ 新坐标系中的 曼哈顿距离 碰到求 切比雪夫距离 或 曼哈顿距离 的题目时，我们往往可以相互转化来求解。两种距离在不同的题目中有不同的优缺点，应该灵活运用。 例题： [Luogu]P4648（曼哈顿距离转切比雪夫距离） [Luogu]P3964（切比雪夫距离转曼哈顿距离） 最后给出 [Luogu]P5098 的第二种解法： 我们考虑将题目所求的 曼哈顿距离 转化为 切比雪夫距离，即把每个点的坐标 $(x,y)$ 变为 $(x + y, x - y)$。 所求的答案就变为 $\max_{\forall i,j\in n}\begin{Bmatrix} \max\begin{Bmatrix} \left | x_i - x_j\right| ,\left | y_i - y_j\right| \end{Bmatrix}\end{Bmatrix}$ 现要使得横坐标之差和纵坐标之差最大，只需要预处理出 $x,y$ 的最大值和最小值即可。 Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1, len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;int n, x, y, a, b, minx = 0x7fffffff, maxx, miny = 0x7fffffff, maxy;int main() &#123; read(n); for (int i = 1; i &lt;= n; i++) &#123; read(a), read(b); x = a + b, y = a - b; minx = min(minx, x), maxx = max(maxx, x); miny = min(miny, y), maxy = max(maxy, y); &#125; write(max(maxx - minx, maxy - miny)); putchar('\n'); return 0;&#125; 对比两份代码，我们又能够发现，两种不同的思路，写出来的代码却是完全等价的，是不是很神奇呢？当然，更高深的东西需要大家另行研究。]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>数论数学</tag>
        <tag>距离</tag>
      </tags>
  </entry>
</search>
