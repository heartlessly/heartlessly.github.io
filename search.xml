<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[「BZOJ 2829」信用卡凸包]]></title>
    <url>%2Fproblems%2Fbzoj-2829%2F</url>
    <content type="text"><![CDATA[Description信用卡是一个矩形，唯四个角作了圆滑处理，使它们都是与矩形的两边相切的 $\frac{1}{4}$ 圆。现在平面上有 $n$ 张竖直方向长为 $a$，水平方向长为 $b$，圆半径为 $r$ 的信用卡，给定每张信用卡的坐标 $(x,y)$ 和旋转的弧度 $\theta$，试求其凸包的周长。注意凸包未必是多边形，因为它可能包含若干段圆弧。 $(1 \leq n \leq 10^4,0.1 \leq a,b \leq 10^6,0.0 \leq r &lt; \min \{ \frac{a}{4},\frac{b}{4} \};|x|,|y| \leq 10^6, 0 \leq \theta &lt; 2\pi)$ Source[BZOJ]2829 Solution包含所有信用卡的凸包一定由若干线段和圆弧构成。 我们可以把每张信用卡简化成一个矩形，矩形的四个顶点分别是其对应圆弧的圆心。 这个矩形上的每一个点到信用卡的轮廓距离刚好等于 $r$ 。于是问题就和 [Luogu]P2116 很相似了，唯一不同的地方在于点的处理（这里只分析该问题，其它过程详见链接）。 我们可以把这个矩形的四个顶点加入点集（比如说上图中的点 $A,B,C,D$）。具体求法为先假设信用卡中心为 $(0,0)$，得到的四个顶点分别为 \left( -\frac{b}{2} + r,\frac{a}{2} - r \right),\left( \frac{b}{2} - r,\frac{a}{2} - r \right),\left( -\frac{b}{2} + r,-\frac{a}{2} + r \right),\left( \frac{b}{2} - r,-\frac{a}{2} + r\right)然后对这些点进行旋转，最后给每个顶点的坐标加上原来的中心坐标即可。 对点集中的点求凸包长度，即是所有线段的总长。而圆弧总长刚好是半径为 $r$ 的圆的周长，加起来即是答案。时间复杂度为 $O(n \log n)$ 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;const int MAXN = 4e4;const double PI = acos(-1);int n, m, top, tag;double a, b, r, ans;struct Vector &#123; double x, y; Vector(double a = 0, double b = 0) &#123; x = a, y = b; &#125; inline friend bool operator&lt;(Vector a, Vector b) &#123; return a.x == b.x ? a.y &lt; b.y : a.x &lt; b.x; &#125; inline friend Vector operator+(Vector a, Vector b) &#123; return (Vector) &#123; a.x + b.x, a.y + b.y &#125;; &#125; inline friend Vector operator-(Vector a, Vector b) &#123; return (Vector) &#123; a.x - b.x, a.y - b.y &#125;; &#125;&#125; v[MAXN + 5], sta[MAXN + 5];inline double dist(Vector a, Vector b) &#123;//两点距离 return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));&#125;inline double cross(Vector a, Vector b) &#123;//叉积 return a.x * b.y - a.y * b.x;&#125;inline void rotate(Vector &amp;a, double theta) &#123;//逆时针旋转 theta (rad) double sinTheta = sin(theta), cosTheta = cos(theta); a = (Vector) &#123; a.x * cosTheta - a.y * sinTheta, a.x * sinTheta + a.y * cosTheta &#125;;&#125;inline void getConvexHull(Vector *a, int n) &#123;//求凸包长度 sort(a + 1, a + n + 1); for (int i = 1; i &lt;= n; ++i) &#123; for (; top &gt; 1 &amp;&amp; cross(sta[top] - sta[top - 1], a[i] - sta[top]) &lt;= 0; --top); sta[++top] = a[i]; &#125; tag = top; for (int i = n - 1; i; --i) &#123; for (; top &gt; tag &amp;&amp; cross(sta[top] - sta[top - 1], a[i] - sta[top]) &lt;= 0; --top); sta[++top] = a[i]; &#125; for (int i = 1; i &lt; top; ++i) ans += dist(sta[i], sta[i + 1]);&#125;int main() &#123; read(n); scanf("%lf %lf %lf", &amp;a, &amp;b, &amp;r); for (int i = 1; i &lt;= n; ++i) &#123; double x, y, theta; scanf("%lf %lf %lf", &amp;x, &amp;y, &amp;theta); Vector p = (Vector) &#123; x, y &#125;, v1(-b / 2 + r, a / 2 - r), v2(b / 2 - r, a / 2 - r), //左上角，右上角 v3(-b / 2 + r, -a / 2 + r), v4(b / 2 - r, -a / 2 + r);//左下角，右下角 rotate(v1, theta), rotate(v2, theta); rotate(v3, theta), rotate(v4, theta);//旋转 v[++m] = v1 + p, v[++m] = v2 + p, v[++m] = v3 + p, v[++m] = v4 + p; //加上原来的中心坐标 &#125; getConvexHull(v, m); ans += 2 * PI * r;//答案加上圆弧总长 printf("%.2lf\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>凸包</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P3829」「SHOI2012」信用卡凸包]]></title>
    <url>%2Fproblems%2Fluogu-p3829%2F</url>
    <content type="text"><![CDATA[Description信用卡是一个矩形，唯四个角作了圆滑处理，使它们都是与矩形的两边相切的 $\frac{1}{4}$ 圆。现在平面上有 $n$ 张竖直方向长为 $a$，水平方向长为 $b$，圆半径为 $r$ 的信用卡，给定每张信用卡的坐标 $(x,y)$ 和旋转的弧度 $\theta$，试求其凸包的周长。注意凸包未必是多边形，因为它可能包含若干段圆弧。 $(1 \leq n \leq 10^4,0.1 \leq a,b \leq 10^6,0.0 \leq r &lt; \min \{ \frac{a}{4},\frac{b}{4} \};|x|,|y| \leq 10^6, 0 \leq \theta &lt; 2\pi)$ Source[Luogu]P3829 Solution包含所有信用卡的凸包一定由若干线段和圆弧构成。 我们可以把每张信用卡简化成一个矩形，矩形的四个顶点分别是其对应圆弧的圆心。 这个矩形上的每一个点到信用卡的轮廓距离刚好等于 $r$ 。于是问题就和 [Luogu]P2116 很相似了，唯一不同的地方在于点的处理（这里只分析该问题，其它过程详见链接）。 我们可以把这个矩形的四个顶点加入点集（比如说上图中的点 $A,B,C,D$）。具体求法为先假设信用卡中心为 $(0,0)$，得到的四个顶点分别为 \left( -\frac{b}{2} + r,\frac{a}{2} - r \right),\left( \frac{b}{2} - r,\frac{a}{2} - r \right),\left( -\frac{b}{2} + r,-\frac{a}{2} + r \right),\left( \frac{b}{2} - r,-\frac{a}{2} + r\right)然后对这些点进行旋转，最后给每个顶点的坐标加上原来的中心坐标即可。 对点集中的点求凸包长度，即是所有线段的总长。而圆弧总长刚好是半径为 $r$ 的圆的周长，加起来即是答案。时间复杂度为 $O(n \log n)$ 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;const int MAXN = 4e4;const double PI = acos(-1);int n, m, top, tag;double a, b, r, ans;struct Vector &#123; double x, y; Vector(double a = 0, double b = 0) &#123; x = a, y = b; &#125; inline friend bool operator&lt;(Vector a, Vector b) &#123; return a.x == b.x ? a.y &lt; b.y : a.x &lt; b.x; &#125; inline friend Vector operator+(Vector a, Vector b) &#123; return (Vector) &#123; a.x + b.x, a.y + b.y &#125;; &#125; inline friend Vector operator-(Vector a, Vector b) &#123; return (Vector) &#123; a.x - b.x, a.y - b.y &#125;; &#125;&#125; v[MAXN + 5], sta[MAXN + 5];inline double dist(Vector a, Vector b) &#123;//两点距离 return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));&#125;inline double cross(Vector a, Vector b) &#123;//叉积 return a.x * b.y - a.y * b.x;&#125;inline void rotate(Vector &amp;a, double theta) &#123;//逆时针旋转 theta (rad) double sinTheta = sin(theta), cosTheta = cos(theta); a = (Vector) &#123; a.x * cosTheta - a.y * sinTheta, a.x * sinTheta + a.y * cosTheta &#125;;&#125;inline void getConvexHull(Vector *a, int n) &#123;//求凸包长度 sort(a + 1, a + n + 1); for (int i = 1; i &lt;= n; ++i) &#123; for (; top &gt; 1 &amp;&amp; cross(sta[top] - sta[top - 1], a[i] - sta[top]) &lt;= 0; --top); sta[++top] = a[i]; &#125; tag = top; for (int i = n - 1; i; --i) &#123; for (; top &gt; tag &amp;&amp; cross(sta[top] - sta[top - 1], a[i] - sta[top]) &lt;= 0; --top); sta[++top] = a[i]; &#125; for (int i = 1; i &lt; top; ++i) ans += dist(sta[i], sta[i + 1]);&#125;int main() &#123; read(n); scanf("%lf %lf %lf", &amp;a, &amp;b, &amp;r); for (int i = 1; i &lt;= n; ++i) &#123; double x, y, theta; scanf("%lf %lf %lf", &amp;x, &amp;y, &amp;theta); Vector p = (Vector) &#123; x, y &#125;, v1(-b / 2 + r, a / 2 - r), v2(b / 2 - r, a / 2 - r), //左上角，右上角 v3(-b / 2 + r, -a / 2 + r), v4(b / 2 - r, -a / 2 + r);//左下角，右下角 rotate(v1, theta), rotate(v2, theta); rotate(v3, theta), rotate(v4, theta);//旋转 v[++m] = v1 + p, v[++m] = v2 + p, v[++m] = v3 + p, v[++m] = v4 + p; //加上原来的中心坐标 &#125; getConvexHull(v, m); ans += 2 * PI * r;//答案加上圆弧总长 printf("%.2lf\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>2012</tag>
        <tag>凸包</tag>
        <tag>计算几何</tag>
        <tag>SHOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2116」城墙]]></title>
    <url>%2Fproblems%2Fluogu-p2116%2F</url>
    <content type="text"><![CDATA[Description给定 $n$ 个点，求出最短的包围所有点的轮廓且满足任意点到轮廓的距离不小于给定的 $L$ 。 $(3 \leq n \leq 10^3,1 \leq L \leq 10^3,-10^4 \leq x_i,y_i \leq 10^4)$ Source[Luogu]P2116 Solution所有点到轮廓的距离都 $\geq L$，显然取等于时是最优的。 因此轮廓一定由若干线段和圆弧构成。 而所有的线段都可以由点与点之间的连线平移得到，而且点围成的图形一定是一个凸多边形（凹多边形显然不优，比如图中的 $GH + HF &gt; GF$）。也就是说线段的长度和就是凸包的长度。 那圆弧的长度呢？我们可以大胆猜想圆弧的总长刚好是一个圆周。 证明： 以图中底部的圆为例。 $\because IB$ 和 $CJ$ 分别是 $\odot A$ 和 $\odot D$，$\odot A$ 和 $\odot E$ 的外公切线，$AD \parallel IB,AE \parallel CJ$ $\therefore \angle DAB = \angle EAC = \angle ABI = \angle ACJ = 90^\circ$ $\therefore \angle DAE$ 与 $\angle BAC$ 互补 $\because$ $\angle DAE$ 与它的外角互补 $\therefore \angle BAC$ 等于 $\angle DAE$ 的外角 同理，每个圆弧所对的圆心角都是凸多边形的一个外角，而凸多边形的外角和为 $360^\circ$，因此圆弧的总长即是半径为 $L$ 的圆的周长。 凸包长度加上圆弧总长即是答案。时间复杂度为 $O(n \log n)$ 。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;const int MAXN = 1e3;const double PI = acos(-1);int n, l, top, tag;double ans;struct Vector &#123; double x, y; inline friend bool operator&lt;(Vector a, Vector b) &#123; return a.x == b.x ? a.y &lt; b.y : a.x &lt; b.x; &#125; inline friend Vector operator-(Vector a, Vector b) &#123; return (Vector) &#123; a.x - b.x, a.y - b.y &#125;; &#125;&#125; a[MAXN + 5], sta[MAXN + 5];inline double dist(Vector a, Vector b) &#123;//两点的直线距离 return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));&#125;inline double cross(Vector a, Vector b) &#123;//叉积 return a.x * b.y - a.y * b.x;&#125;inline void getConvexHull(Vector *a, int n) &#123;//求凸包长度 top = ans = 0; sort(a + 1, a + n + 1); for (int i = 1; i &lt;= n; ++i) &#123; for (; top &gt; 1 &amp;&amp; cross(sta[top] - sta[top - 1], a[i] - sta[top]) &lt;= 0; --top); sta[++top] = a[i]; &#125; tag = top; for (int i = n - 1; i; --i) &#123; for (; top &gt; tag &amp;&amp; cross(sta[top] - sta[top - 1], a[i] - sta[top]) &lt;= 0; --top); sta[++top] = a[i]; &#125; for (int i = 1; i &lt; top; ++i) ans += dist(sta[i], sta[i + 1]);&#125;int main() &#123; read(n), read(l); for (int i = 1; i &lt;= n; ++i) scanf("%lf %lf", &amp;a[i].x, &amp;a[i].y); getConvexHull(a, n); ans += 2 * PI * l;//加上圆弧总长 printf("%.0lf\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>凸包</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AtCoder AGC034-A」Kenken Race]]></title>
    <url>%2Fproblems%2Fatcoder-agc034-a%2F</url>
    <content type="text"><![CDATA[Description给定一个长度为 $n$ 的线性地图 $\{s\}$，# 表示障碍，. 表示可以停留。小 $\rm X$ 和小 $\rm Y$ 分别站在 $a$ 处和 $b$ 处，现在小 $\rm X$ 想去 $c$，小 $\rm Y$ 想去 $d$ 。一个人一次只能走一格或两格，不能站在障碍和另一个人所在的位置，求能否使小 $\rm X$ 和小 $\rm Y$ 都到达目的地。 $(4 \leq n \leq 2 \times 10^5,1 \leq a,b,c,d \leq n;a,b,c,d$ 互不相同，且 $a &lt; b &lt; d,a &lt; c;s_a,s_b,s_c,s_d$ 均不为 # $)$ Source[AtCoder]AGC034-A Solution首先保证 $d$ 在 $c$ 的右端，即 $d &gt; c$（如果 $d &lt; c$ 则交换小 $\rm X$ 和小 $\rm Y$）。 接下来就可以分三种情况考虑了。 第一种情况： 显然两个人互不影响，各走各的。如果 $ac$ 之间存在至少两个连续的 #，则小 $\rm X$ 不能到达目的地，$bd$ 同理。 第二种情况： 我们可以先让小 $\rm Y$ 先到达目的地，这样两人仍然互不影响。所以也只需要判断是否存在至少两个连续的 # 。 第三种情况： 还是先判断是否存在至少两个连续的 #（保证小 $\rm X$ 能到达 $c$，小 $\rm Y$ 能到达 $d$）。但是注意小 $\rm X$ 不论怎样都会影响到小 $\rm Y$，所以可以把小 $\rm X$ 看成一个可以放置在任何空位的障碍。当 $ac$ 之间存在至少三个连续的 . 时，就可以先让小 $\rm X$ 到达它们中间的那个点（即把 ... 变成 .#.）。这样就能使小 $\rm Y$ 到达 $d$，然后小 $\rm X$ 就不受影响了（直接到 $c$）。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;inline void readChar(char &amp;c) &#123; for (c = getchar(); c != '.' &amp;&amp; c != '#'; c = getchar());&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 2e5;int n, a, b, c, d;char s[MAXN + 5];int main() &#123; read(n), read(a), read(b), read(c), read(d); if (d &lt; c) swap(a, b), swap(c, d);//确保 d &gt; c for (int i = 1; i &lt;= n; ++i) readChar(s[i]); for (int i = a; i &lt;= c; ++i) if (s[i] == '#' &amp;&amp; s[i - 1] == '#') &#123; puts("No");//判断 ac 间是否存在两个连续的 # return 0; &#125; for (int i = b; i &lt;= d; ++i) if (s[i] == '#' &amp;&amp; s[i - 1] == '#') &#123; puts("No");//判断 bd 间是否存在两个连续的 # return 0; &#125; if (a &lt; b) &#123;//b 先到 d，a 再到 b（第一、二种情况） puts("Yes"); return 0; &#125; for (int i = a; i &lt;= c; ++i)//让 a 到一个合适的位置，使 b 能够到达 d if (s[i - 1] == '.' &amp;&amp; s[i] == '.' &amp;&amp; s[i + 1] == '.') &#123; puts("Yes"); return 0; &#125; puts("No"); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2857」「USACO06FEB」稳定奶牛分配 Steady Cow Assignment]]></title>
    <url>%2Fproblems%2Fluogu-p2857%2F</url>
    <content type="text"><![CDATA[Description给定 $n$ 头牛和 $b$ 座牛棚，已知每头牛最喜欢，第 $2$ 喜欢，第 $3$ 喜欢，……，第 $b$ 喜欢的牛棚分别是什么，以及每个牛棚的容量 $v_i$（最多能住 $v_i$ 头牛）。如果某头牛住在第 $i$ 喜欢的牛棚里，则这头牛的不满意度为 $i$ 。求如何分配牛棚，使所有牛的 最大不满意度 - 最小不满意度 + 1 的值最小。输出这个值是多少。 $(1 \leq n \leq 10^3,1 \leq b \leq 20,\sum\limits_{i = 1}^n v_i = n)$ Source[Luogu]P2857 Solution考虑 网络流 + 二分答案 。 我们可以把图分成两部分。左部点是牛，右部点是牛棚。 在源点与每头牛之间连一条流量为 $1$ 的边（一头牛最大贡献为 $1$），在第 $i$ 个牛棚与汇点之间连一条流量为 $v_i$ 的边（一个牛棚最大贡献为 $v_i$）。 对于样例所建出的图： 牛和牛棚之间的边呢？显然不能直接全部连上。 我们可以 二分答案（假设答案为 $x$），然后枚举所有牛的 最小不满意度 $i$，那么 最大不满意度 为 $i + x - 1$ 。 即每头牛不满意度所在的区间为 $[i,i + x - 1]$ 。也就是说，对于每一头牛，我们只需要在它与它第 $i \sim i + x - 1$ 喜欢的牛棚之间连一条流量为 $1$ 的边。接着用 $\rm dinic$ 跑一遍最大流，若最大流为 $n$，则这个答案可行。 不过由于数据范围比较小，暴力枚举也能过。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 2e3, MAXB = 20, MAXM = 1e5, INF = 0x3f3f3f3f;int n, b, ans, tot, head[MAXN + 5], cur[MAXN + 5], depth[MAXN + 5];int v[MAXB + 5], f[MAXN + 5][MAXB + 5];struct Edge &#123; int next, to, dis;&#125; e[MAXM + 5];inline void addEdge(int u, int v, int w) &#123; e[++tot] = (Edge) &#123; head[u], v, w &#125;; head[u] = tot;&#125;inline bool bfs(int s, int t) &#123; for (int i = 0; i &lt;= t; ++i) cur[i] = head[i]; memset(depth, 0, sizeof (depth)); queue&lt;int&gt; q; depth[s] = 1; q.push(s); for (; !q.empty(); ) &#123; int u = q.front(); q.pop(); for (int v, w, i = head[u]; v = e[i].to, w = e[i].dis, i; i = e[i].next) &#123; if (depth[v] || !w) continue; depth[v] = depth[u] + 1; if (v == t) return 1; q.push(v); &#125; &#125; return 0;&#125;int dinic(int u, int t, int flow) &#123; if (u == t) return flow; int rest = flow; for (int v, w, i = cur[u]; v = e[i].to, w = e[i].dis, i &amp;&amp; rest; i = e[i].next) &#123; cur[u] = i;//当前弧优化 if (depth[v] != depth[u] + 1 || !w) continue; int k = dinic(v, t, min(rest, w)); if (!k) depth[v] = 0; else &#123; e[i].dis -= k; e[i ^ 1].dis += k; rest -= k; &#125; &#125; return flow - rest;&#125;inline int maxFlow(int s, int t) &#123; int res = 0; for (; bfs(s, t); ) res += dinic(s, t, INF); return res;&#125;inline bool check(int x) &#123;//检查答案 x for (int i = 1; i + x - 1 &lt;= b; ++i) &#123; //最小满意度为 i，最大满意度为 i + x - 1 tot = 1; memset(head, 0, sizeof (head)); int s = 0, t = n + b + 1;//源点编号和汇点编号 for (int j = 1; j &lt;= n; ++j)//源点与牛连一条流量为 1 的边 addEdge(s, j, 1), addEdge(j, s, 0); for (int j = 1; j &lt;= b; ++j)//牛棚与汇点连一条流量为 v[j] 的边 addEdge(j + n, t, v[j]), addEdge(t, j + n, 0); //与第 i ~ i + x - 1 喜欢的牛棚连一条流量为 1 的边 for (int j = 1; j &lt;= n; ++j) for (int k = i; k &lt;= i + x - 1; ++k) addEdge(j, f[j][k] + n, 1), addEdge(f[j][k] + n, j, 0); if (maxFlow(s, t) == n) return 1;//若最大流为 n，则该答案可行 &#125; return 0;&#125;int main() &#123; read(n), read(b); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= b; ++j) read(f[i][j]);//第 i 头牛第 j 喜欢的牛棚是 f[i][j] for (int i = 1; i &lt;= b; ++i) read(v[i]); for (int mid, l = 1, r = b; l &lt;= r; ) &#123;//二分答案 mid = (l + r) &gt;&gt; 1; if (check(mid)) &#123; r = mid - 1; ans = mid; &#125; else l = mid + 1; &#125; write(ans); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>二分图</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>USACO</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 1433」「ZJOI2009」假期的宿舍]]></title>
    <url>%2Fproblems%2Fbzoj-1433%2F</url>
    <content type="text"><![CDATA[Description$T$ 组数据。给定 $n$ 个人和若干人际关系，有些人有床。如果某两人 $A,B$ 互相认识且 $B$ 有床，则 $A$ 可以睡 $B$ 的床，自己也可以睡自己的床。求能否让所有指定的人都有床睡。$(1 \leq n \leq 50,1 \leq T \leq 20)$ Source[BZOJ]1433 Solution考虑建立一个 二分图 模型。 左部点表示不回家的学生（晚上要留宿），右部点表示在校学生（这些学生有床），接着对于 左部点 $A$ 与 右部点 $B$，若 $A,B$ 互相认识，则在它们之间连一条边，表示 $A$ 可以睡 $B$ 的床。不要忘记自己与自己连边，因为自己可以睡自己的床。最后判断最大匹配是否为左部点的数量即可。 网络流 模型同理，最后跑一遍 $\rm dinic$ 最大流也同样能得到答案。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;const int MAXN = 100, MAXM = 1e4, INF = 0x3f3f3f3f;int t, n, tot, head[MAXN + 5], cur[MAXN + 5], depth[MAXN + 5];bool atsch[MAXN + 5], leave[MAXN + 5];struct Edge &#123; int next, to, dis; &#125; e[MAXM + 5];inline void addEdge(int u, int v, int w) &#123; e[++tot] = (Edge) &#123; head[u], v, w &#125;; head[u] = tot;&#125;inline bool bfs(int s, int t) &#123; for (int i = 0; i &lt;= t; ++i) cur[i] = head[i]; memset(depth, 0, sizeof (depth)); queue&lt;int&gt; q; depth[s] = 1; q.push(s); for (; !q.empty(); ) &#123; int u = q.front(); q.pop(); for (int v, w, i = head[u]; v = e[i].to, w = e[i].dis, i; i = e[i].next) &#123; if (depth[v] || !w) continue; depth[v] = depth[u] + 1; if (v == t) return 1; q.push(v); &#125; &#125; return 0;&#125;int dinic(int u, int t, int flow) &#123; if (u == t) return flow; int rest = flow; for (int v, w, i = cur[u]; v = e[i].to, w = e[i].dis, i &amp;&amp; rest; i = e[i].next) &#123; cur[u] = i;//当前弧优化 if (depth[v] != depth[u] + 1 || !w) continue; int k = dinic(v, t, min(rest, w)); if (!k) depth[v] = 0; else &#123; e[i].dis -= k; e[i ^ 1].dis += k; rest -= k; &#125; &#125; return flow - rest;&#125;inline int maxFlow(int s, int t) &#123; int res = 0; for (; bfs(s, t); ) res += dinic(s, t, INF); return res;&#125;int main() &#123; for (read(t); t; --t) &#123; read(n); tot = 1;//清空 memset(head, 0, sizeof (head)); int cnt = 0, s = 0, t = 2 * n + 1; for (int i = 1; i &lt;= n; ++i) &#123; read(atsch[i]);//是否在校 if (atsch[i]) addEdge(i + n, t, 1), addEdge(t, i + n, 0);//连向汇点 &#125; for (int i = 1; i &lt;= n; ++i) &#123; read(leave[i]);//是否回家 if (!(leave[i] &amp;&amp; atsch[i])) &#123;//在校学生 addEdge(s, i, 1), addEdge(i, s, 0);//连向源点 ++cnt;//在校学生数量 &#125; &#125; for (int i = 1; i &lt;= n; ++i) for (int x, j = 1; j &lt;= n; ++j) &#123; read(x); if (i == j || x)//互相认识，或自己和自己连边 addEdge(i, j + n, 1), addEdge(j + n, i, 0); &#125; puts(maxFlow(s, t) == cnt ? "^_^" : "T_T"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>2009</tag>
        <tag>ZJOI</tag>
        <tag>二分图</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2055」「ZJOI2009」假期的宿舍]]></title>
    <url>%2Fproblems%2Fluogu-p2055%2F</url>
    <content type="text"><![CDATA[Description$T$ 组数据。给定 $n$ 个人和若干人际关系，有些人有床。如果某两人 $A,B$ 互相认识且 $B$ 有床，则 $A$ 可以睡 $B$ 的床，自己也可以睡自己的床。求能否让所有指定的人都有床睡。$(1 \leq n \leq 50,1 \leq T \leq 20)$ Source[Luogu]P2055 Solution考虑建立一个 二分图 模型。 左部点表示不回家的学生（晚上要留宿），右部点表示在校学生（这些学生有床），接着对于 左部点 $A$ 与 右部点 $B$，若 $A,B$ 互相认识，则在它们之间连一条边，表示 $A$ 可以睡 $B$ 的床。不要忘记自己与自己连边，因为自己可以睡自己的床。最后判断最大匹配是否为左部点的数量即可。 网络流 模型同理，最后跑一遍 $\rm dinic$ 最大流也同样能得到答案。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;const int MAXN = 100, MAXM = 1e4, INF = 0x3f3f3f3f;int t, n, tot, head[MAXN + 5], cur[MAXN + 5], depth[MAXN + 5];bool atsch[MAXN + 5], leave[MAXN + 5];struct Edge &#123; int next, to, dis; &#125; e[MAXM + 5];inline void addEdge(int u, int v, int w) &#123; e[++tot] = (Edge) &#123; head[u], v, w &#125;; head[u] = tot;&#125;inline bool bfs(int s, int t) &#123; for (int i = 0; i &lt;= t; ++i) cur[i] = head[i]; memset(depth, 0, sizeof (depth)); queue&lt;int&gt; q; depth[s] = 1; q.push(s); for (; !q.empty(); ) &#123; int u = q.front(); q.pop(); for (int v, w, i = head[u]; v = e[i].to, w = e[i].dis, i &amp;&amp; rest; i = e[i].next) &#123; if (depth[v] || !w) continue; depth[v] = depth[u] + 1; if (v == t) return 1; q.push(v); &#125; &#125; return 0;&#125;int dinic(int u, int t, int flow) &#123; if (u == t) return flow; int rest = flow; for (int v, w, i = cur[u]; v = e[i].to, w = e[i].dis, i; i = e[i].next) &#123; cur[u] = i;//当前弧优化 if (depth[v] != depth[u] + 1 || !w) continue; int k = dinic(v, t, min(rest, w)); if (!k) depth[v] = 0; else &#123; e[i].dis -= k; e[i ^ 1].dis += k; rest -= k; &#125; &#125; return flow - rest;&#125;inline int maxFlow(int s, int t) &#123; int res = 0; for (; bfs(s, t); ) res += dinic(s, t, INF); return res;&#125;int main() &#123; for (read(t); t; --t) &#123; read(n); tot = 1;//清空 memset(head, 0, sizeof (head)); int cnt = 0, s = 0, t = 2 * n + 1; for (int i = 1; i &lt;= n; ++i) &#123; read(atsch[i]);//是否在校 if (atsch[i]) addEdge(i + n, t, 1), addEdge(t, i + n, 0);//连向汇点 &#125; for (int i = 1; i &lt;= n; ++i) &#123; read(leave[i]);//是否回家 if (!(leave[i] &amp;&amp; atsch[i])) &#123;//在校学生 addEdge(s, i, 1), addEdge(i, s, 0);//连向源点 ++cnt;//在校学生数量 &#125; &#125; for (int i = 1; i &lt;= n; ++i) for (int x, j = 1; j &lt;= n; ++j) &#123; read(x); if (i == j || x)//互相认识，或自己和自己连边 addEdge(i, j + n, 1), addEdge(j + n, i, 0); &#125; puts(maxFlow(s, t) == cnt ? "^_^" : "T_T"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>2009</tag>
        <tag>ZJOI</tag>
        <tag>二分图</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 3175」「TJOI2013」攻击装置]]></title>
    <url>%2Fproblems%2Fbzoj-3175%2F</url>
    <content type="text"><![CDATA[Description给定一个大小为 $n \times n$ 的 $01$ 矩阵，其中你可以在 $0$ 的位置放置攻击装置。每一个攻击装置 $(x,y)$ 都可以按照“日”字攻击其周围的 $8$ 个位置。求在装置互不攻击的情况下，最多可以放置多少个装置。 $(1 \leq n \leq 200)$ Source[BZOJ]3175 Solution与 网络流 24 题 中的 骑士共存问题 几乎一样。 我们可以先将棋盘染色，得到 对于格子 $(x,y)$，若 $x + y$ 是奇数，则该格子为白色，否则为黑色。 很容易发现，放在白（黑）色格子上的攻击装置只能攻击到黑（白）色格子。 那么显然这是一个二分图。 我们把白色格子和黑色格子分成两部分。 如果某个白色格子可以攻击到某个黑色格子，则在它们之间连一条边。 一条边所连接的两个格子只能取其中一个（否则会互相攻击），所以问题变为求这个二分图的 最大独立集 。 最大独立集 = 总点数 - 最小点覆盖 = 总点数 - 最大匹配数 至于不能放攻击装置的格子，我们不把它当做二分图中的点即可，最后答案要减去这些点。 所以用 $\rm dinic$ 跑一遍最小割（最大流）就能够得到答案了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;inline void readDigit(bool &amp;x) &#123; x = 0; char c = getchar(); for (; !isdigit(c); c = getchar()); x = c ^ 48;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXP = 200, MAXN = 5e4, MAXM = 1e6, INF = 0x3f3f3f3f;const int dx[8] = &#123; 1, 2, -1, -2, -1, 2, 1, -2 &#125;;const int dy[8] = &#123; 2, 1, -2, -1, 2, -1, -2, 1 &#125;;int n, tot = 1, sum, id[MAXP + 5][MAXP + 5], head[MAXN + 5];int cur[MAXN + 5], depth[MAXN + 5];bool f[MAXP + 5][MAXP + 5];struct Edge &#123; int next, to, dis;&#125; e[MAXM + 5];inline void addEdge(int u, int v, int w) &#123; e[++tot] = (Edge) &#123; head[u], v, w &#125;; head[u] = tot;&#125;inline void build(int x, int y) &#123; for (int i = 0; i &lt; 8; ++i) &#123; int tx = x + dx[i], ty = y + dy[i]; if (tx &lt; 1 || ty &lt; 1 || tx &gt; n || ty &gt; n || f[tx][ty]) continue; addEdge(id[x][y], id[tx][ty], INF), addEdge(id[tx][ty], id[x][y], 0); //如果 (x,y) 能攻击到点 (tx,ty)，则在它们之间连一条边 &#125;&#125;inline bool bfs(int s, int t) &#123;//找增广路 for (int i = 0; i &lt;= t; ++i) cur[i] = head[i]; memset(depth, 0, sizeof (depth)); queue&lt;int&gt; q; depth[s] = 1; q.push(s); for (; !q.empty(); ) &#123; int u = q.front(); q.pop(); for (int v, w, i = head[u]; v = e[i].to, w = e[i].dis, i; i = e[i].next) &#123; if (depth[v] || !w) continue; depth[v] = depth[u] + 1; if (v == t) return 1; q.push(v); &#125; &#125; return 0;&#125;int dinic(int u, int t, int flow) &#123; if (u == t) return flow; int rest = flow; for (int v, w, i = cur[u]; v = e[i].to, w = e[i].dis, i &amp;&amp; rest; i = e[i].next) &#123; cur[u] = i;//当前弧优化 if (depth[v] != depth[u] + 1 || !w) continue; int k = dinic(v, t, min(rest, w)); if (!k) depth[v] = 0; else &#123; e[i].dis -= k; e[i ^ 1].dis += k; rest -= k; &#125; &#125; return flow - rest;&#125;inline int minCut(int s, int t) &#123;//求最小割 int res = 0; for (; bfs(s, t); ) res += dinic(s, t, INF); return res;&#125;int main() &#123; read(n); int s = 0, t = n * n + 1;//超级源点 s 与 超级汇点 t for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) &#123; readDigit(f[i][j]); sum += f[i][j];//不能放攻击装置的点的数量 &#125; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) &#123; id[i][j] = (i - 1) * n + j;//点的编号 if (f[i][j]) continue; if ((i + j) &amp; 1)//源点向白色格子连一条流量为 1 的边 addEdge(s, id[i][j], 1), addEdge(id[i][j], s, 0); else //黑色格子向汇点连一条流量为 1 的边 addEdge(id[i][j], t, 1), addEdge(t, id[i][j], 0); &#125; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) if ((i + j) &amp; 1) build(i, j);//白色格子与黑色格子连边 write(n * n - sum - minCut(s, t));//最大独立集 putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>二分图</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>TJOI</tag>
        <tag>2013</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P4304」「TJOI2013」攻击装置]]></title>
    <url>%2Fproblems%2Fluogu-p4304%2F</url>
    <content type="text"><![CDATA[Description给定一个大小为 $n \times n$ 的 $01$ 矩阵，其中你可以在 $0$ 的位置放置攻击装置。每一个攻击装置 $(x,y)$ 都可以按照“日”字攻击其周围的 $8$ 个位置。求在装置互不攻击的情况下，最多可以放置多少个装置。 $(1 \leq n \leq 200)$ Source[Luogu]P4304 Solution与 网络流 24 题 中的 骑士共存问题 几乎一样。 我们可以先将棋盘染色，得到 对于格子 $(x,y)$，若 $x + y$ 是奇数，则该格子为白色，否则为黑色。 很容易发现，放在白（黑）色格子上的攻击装置只能攻击到黑（白）色格子。 那么显然这是一个二分图。 我们把白色格子和黑色格子分成两部分。 如果某个白色格子可以攻击到某个黑色格子，则在它们之间连一条边。 一条边所连接的两个格子只能取其中一个（否则会互相攻击），所以问题变为求这个二分图的 最大独立集 。 最大独立集 = 总点数 - 最小点覆盖 = 总点数 - 最大匹配数 至于不能放攻击装置的格子，我们不把它当做二分图中的点即可，最后答案要减去这些点。 所以用 $\rm dinic$ 跑一遍最小割（最大流）就能够得到答案了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;inline void readDigit(bool &amp;x) &#123; x = 0; char c = getchar(); for (; !isdigit(c); c = getchar()); x = c ^ 48;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXP = 200, MAXN = 5e4, MAXM = 1e6, INF = 0x3f3f3f3f;const int dx[8] = &#123; 1, 2, -1, -2, -1, 2, 1, -2 &#125;;const int dy[8] = &#123; 2, 1, -2, -1, 2, -1, -2, 1 &#125;;int n, tot = 1, sum, id[MAXP + 5][MAXP + 5], head[MAXN + 5];int cur[MAXN + 5], depth[MAXN + 5];bool f[MAXP + 5][MAXP + 5];struct Edge &#123; int next, to, dis;&#125; e[MAXM + 5];inline void addEdge(int u, int v, int w) &#123; e[++tot] = (Edge) &#123; head[u], v, w &#125;; head[u] = tot;&#125;inline void build(int x, int y) &#123; for (int i = 0; i &lt; 8; ++i) &#123; int tx = x + dx[i], ty = y + dy[i]; if (tx &lt; 1 || ty &lt; 1 || tx &gt; n || ty &gt; n || f[tx][ty]) continue; addEdge(id[x][y], id[tx][ty], INF), addEdge(id[tx][ty], id[x][y], 0); //如果 (x,y) 能攻击到点 (tx,ty)，则在它们之间连一条边 &#125;&#125;inline bool bfs(int s, int t) &#123;//找增广路 for (int i = 0; i &lt;= t; ++i) cur[i] = head[i]; memset(depth, 0, sizeof (depth)); queue&lt;int&gt; q; depth[s] = 1; q.push(s); for (; !q.empty(); ) &#123; int u = q.front(); q.pop(); for (int v, w, i = head[u]; v = e[i].to, w = e[i].dis, i; i = e[i].next) &#123; if (depth[v] || !w) continue; depth[v] = depth[u] + 1; if (v == t) return 1; q.push(v); &#125; &#125; return 0;&#125;int dinic(int u, int t, int flow) &#123; if (u == t) return flow; int rest = flow; for (int v, w, i = cur[u]; v = e[i].to, w = e[i].dis, i &amp;&amp; rest; i = e[i].next) &#123; cur[u] = i;//当前弧优化 if (depth[v] != depth[u] + 1 || !w) continue; int k = dinic(v, t, min(rest, w)); if (!k) depth[v] = 0; else &#123; e[i].dis -= k; e[i ^ 1].dis += k; rest -= k; &#125; &#125; return flow - rest;&#125;inline int minCut(int s, int t) &#123;//求最小割 int res = 0; for (; bfs(s, t); ) res += dinic(s, t, INF); return res;&#125;int main() &#123; read(n); int s = 0, t = n * n + 1;//超级源点 s 与 超级汇点 t for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) &#123; readDigit(f[i][j]); sum += f[i][j];//不能放攻击装置的点的数量 &#125; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) &#123; id[i][j] = (i - 1) * n + j;//点的编号 if (f[i][j]) continue; if ((i + j) &amp; 1)//源点向白色格子连一条流量为 1 的边 addEdge(s, id[i][j], 1), addEdge(id[i][j], s, 0); else //黑色格子向汇点连一条流量为 1 的边 addEdge(id[i][j], t, 1), addEdge(t, id[i][j], 0); &#125; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) if ((i + j) &amp; 1) build(i, j);//白色格子与黑色格子连边 write(n * n - sum - minCut(s, t));//最大独立集 putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>二分图</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>TJOI</tag>
        <tag>2013</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AtCoder ABC128-D」equeue]]></title>
    <url>%2Fproblems%2Fatcoder-abc128-d%2F</url>
    <content type="text"><![CDATA[Description给定一个长度为 $n$ 的序列 $\{v\}$，你最多可以进行 $m$ 次操作，操作有 $4$ 种： 把最左端的数放在手里； 把最右端的数放在手里； 把手中的某个数放回序列最左端； 把手中的某个数放回序列最右端。 求手中数的总和最大是多少。$(1 \leq n \leq 50,1 \leq m \leq 100,-10^7 \leq v_i \leq 10^7)$ Source[AtCoder]ABC128-D Solution显然答案一定是先从左边取若干数，放回取走的若干数；再从右边取若干数，放回取走的若干数。取和放的操作总数不超过 $m$ 。 尝试 动态规划 。 我们用 $f_{i,j}$ 表示取前 $i$ 个数，其中放回 $j$ 个数的最大价值，$g_{i,j}$ 表示取末尾 $i$ 个数，其中放回 $j$ 个数的最大价值。 其实只要会求 $f$，翻转数组求能用同样的方法求 $g$ 了。 对于 $f_{i,j}$，考虑第 $i$ 个数选还是不选。 如果选，取前 $i - 1$ 个数放回 $j$ 个数的最大价值为 $f_{i-1,j}$，还要加上 $v_i$ 。 如果不选，那么只能取前 $i - 1$ 个数并放回 $j - 1$ 个数，最大价值为 $f_{i-1,j-1}$ 。 取上述两个值的较大值即可。 即 \large { f_{i,j} = \max\left(f_{i-1,j-1}, f_{i - 1,j} + v_i \right) }最后通过 $f$ 和 $g$ 合并答案即可，注意 $m$ 次操作不一定要用完。$\rm DP$ 时间复杂度为 $O(nm)$，合并复杂度为 $O(n^2m^2)$ 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 100;const LL INF = 0x7fffffffffffffff;int n, m;LL ans, v[MAXN + 5], f[MAXN + 5][MAXN + 5], g[MAXN + 5][MAXN + 5];int main() &#123; read(n), read(m); for (int i = 1; i &lt;= n; ++i) read(v[i]); for (int i = 1; i &lt;= min(n, m); ++i)//取的数不能超过 n for (int j = 0; j &lt;= i &amp;&amp; i + j &lt;= m; ++j) &#123; //放的操作不能多于取的操作，且加起来不能超过 m 次操作 f[i][j] = -INF; if (j &gt;= 1) f[i][j] = max(f[i][j], f[i - 1][j - 1]);//注意边界 if (j &lt;= i - 1) f[i][j] = max(f[i][j], f[i - 1][j] + v[i]); &#125; reverse(v + 1, v + n + 1);//翻转后做同样的 DP for (int i = 1; i &lt;= min(n, m); ++i) for (int j = 0; j &lt;= i &amp;&amp; i + j &lt;= m; ++j) &#123; g[i][j] = -INF; if (j &gt;= 1) g[i][j] = max(g[i][j], g[i - 1][j - 1]); if (j &lt;= i - 1) g[i][j] = max(g[i][j], g[i - 1][j] + v[i]); &#125; for (int i = 0; i &lt;= min(n, m); ++i) for (int j = 0; j &lt;= i; ++j) for (int k = 0; k &lt;= min(n, m); ++k) for (int l = 0; l &lt;= k; ++l) &#123; if (i + j + k + l &gt; m || i + k &gt; n) break; //加起来不能超过 m 次操作， //且前面的数和后面的数不能重叠（加起来超过 n） ans = max(ans, f[i][j] + g[k][l]);//合并答案 &#125; write(ans); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 15C」Industrial Nim]]></title>
    <url>%2Fproblems%2Fcodeforces-15c%2F</url>
    <content type="text"><![CDATA[Description现在有很多石子，可以分为 $n$ 个区。第 $i$ 个区中有 $m_i$ 堆石子，且这个区的第 $j$ 堆石子共有 $x_i + j - 1$ 个石子。现两个人每次从任意一堆石子中取正整数个石子，取完石子的人获胜，他们都会做出最优的选择。若先手赢输出 “tolik”，后手赢输出 “bolik”（不包含引号）。$(1 \leq n \leq 10^5,1 \leq m_i,x_i \leq 10^{16})$ Source[Luogu]CF15C [Codeforces]15C Solution很显然这是一个 Nim 游戏，也就是说只要把每一堆中的石子个数异或起来，不为 $0$ 则先手必胜（$\rm SG$ 定理）。 但石子最多可能有 $\sum\limits_{i = 1}^n m_i$ 堆，直接异或会超时，所以要结合每一个区中石子个数的特性。 对于第 $i$ 个区，我们设 $l = x_i,r = x_i + m_i - 1,pre_i = 0 \oplus 1 \oplus 2 \oplus \cdots \oplus i$，那么这个区中每一堆石子个数的异或和为 $pre_r \oplus pre_{l - 1}$ 。 $x_i$ 和 $m_i$ 很大，所以考虑找规律。 首先易证 $a \oplus (a + 1) = 1$，其中 $a \in \{ x \mid x \in {\rm N},x = 2k \}$（因为二进制下 $a$ 的右起第一位为 $0$，而 $a + 1$ 为 $1$，其余二进制位都相同）。 假如我们现在要求 $pre_x$，可以分成 $4$ 种情况： $x \bmod 4 = 0$，$0 \oplus 1 \oplus 2 \oplus \cdots \oplus (x - 1)$ 可以变为 $\frac{x}{2}$ 个 $1$ 的异或和，且 $\frac{x}{2}$ 一定是一个偶数，所以前 $x - 1$ 个数的异或和为 $0$，$0 \oplus x = x$，此时 $pre_x = x$ 。 $x \bmod 4 = 1$，$0 \oplus 1 \oplus 2 \oplus \cdots \oplus x$ 可以变为 $\frac{x+1}{2}$ 个 $1$ 的异或和，且 $\frac{x+1}{2}$ 一定是一个奇数，所以此时 $pre_x = 1$ 。 $x \bmod 4 = 2$，$0 \oplus 1 \oplus 2 \oplus \cdots \oplus (x - 1)$ 可以变为 $\frac{x}{2}$ 个 $1$ 的异或和，且 $\frac{x}{2}$ 一定是一个奇数，所以前 $x - 1$ 个数的异或和为 $0$，而 $x$ 是偶数，$1 \oplus x = x + 1$，此时 $pre_x = x + 1$ 。 $x \bmod 4 = 3$，$0 \oplus 1 \oplus 2 \oplus \cdots \oplus x$ 可以变为 $\frac{x+1}{2}$ 个 $1$ 的异或和，且 $\frac{x+1}{2}$ 一定是一个偶数，所以此时 $pre_x = 0$ 。 这样就可以在 $O(1)$ 的时间内求出 $pre_x$，总时间复杂度为 $O(n)$ 。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;int n;LL ans;inline LL solve(LL x) &#123;//求 0 xor 1 xor 2 xor ... xor x 的值 LL res = 0; switch (x % 4) &#123;//分四种情况 case 0 : &#123; res = x; break; &#125; case 1 : &#123; res = 1; break; &#125; case 2 : &#123; res = x + 1; break; &#125; case 3 : &#123; res = 0; break; &#125; &#125; return res;&#125;int main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) &#123; LL x, m, l, r; read(x), read(m); l = x, r = x + m - 1; ans ^= solve(r) ^ solve(l - 1);//求异或和 &#125; puts(ans ? "tolik" : "bolik"); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HDU 1847」Good Luck in CET-4 Everybody]]></title>
    <url>%2Fproblems%2Fhdu-1847%2F</url>
    <content type="text"><![CDATA[Description一个公平组合游戏： 总共 $n$ 张牌； 双方轮流抓牌，两人都足够聪明； 每人每次抓牌的个数只能是 $2$ 的幂次（即：$1,2,4,8,16\ldots$）； 最后抓完牌的人为胜者。 $\rm Kiki$ 先手，$\rm Cici$ 后手，求最后谁能获胜。$(1 \leq n \leq 10^3)$ Source[hdu]1847 Solution$\rm SG$ 函数经典例题。 我们把这个游戏放到一个 DAG 上。 最终取完牌的状态是 $0$，$0$ 没有后继状态，所以 $sg_0 = {\rm mex}(\varnothing ) = 0$，且这个点是必败点。 剩 $1$ 张牌的时候只能取走 $1$ 张，即 $1$ 的后继状态只有 $0$，所以 $sg_1 = {\rm mex}(\{sg_0\}) = {\rm mex}(\{0\})=1$ 。 剩 $2$ 张牌的时候能取走 $1$ 张或 $2$ 张，即 $2$ 的后继状态有 $1$ 和 $0$，所以 $sg_2 = {\rm mex}(\{sg_0,sg_1\}) = {\rm mex}(\{0,1\})=2$ 。 剩 $3$ 张牌的时候也能取走 $1$ 张或 $2$ 张，即 $3$ 的后继状态有 $2$ 和 $1$，所以 $sg_3 = {\rm mex}(\{sg_1,sg_2\}) = {\rm mex}(\{1,2\})=0$ 。 剩 $4$ 张牌的时候能取走 $1$ 张，$2$ 张或 $4$ 张，即 $4$ 的后继状态有 $3,2$ 和 $0$，所以 $sg_4 = {\rm mex}(\{sg_0,sg_2,sg_3\}) = {\rm mex}(\{0,2\})=1$ 。 同理我们能得到 $sg_5 = 2,sg_6 = 0,sg_7 = 1$ 。 $sg_0$ $sg_1$ $sg_2$ $sg_3$ $sg_4$ $sg_5$ $sg_6$ $sg_7$ $0$ $1$ $2$ $0$ $1$ $2$ $0$ $1$ 综上所述我们可以列出一个表格，很容易发现规律：$sg_n = n \bmod 3$ 。 所以当 $n$ 能被 $3$ 整除时，它的 $\rm SG$ 函数值为 $0$，即先手必败。 反之则先手必胜。 Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline bool read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) &#123; if (c == EOF) return 0; f ^= c == '-'; &#125; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x; return 1;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;int main() &#123; for (int n; read(n); ) &#123; if (n % 3) puts("Kiki"); else puts("Cici"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析SG函数与SG定理]]></title>
    <url>%2Fnotes%2Fqian-xi-sg-han-shu-yu-sg-ding-li%2F</url>
    <content type="text"><![CDATA[前言$\rm SG$ 函数与 $\rm SG$ 定理在博弈论中的 公平组合游戏 里起了不可或缺的作用。本文将简单介绍它们的原理及作用。 公平组合游戏公平组合游戏 与平常的游戏类似，但是需要满足以下要求： 有两个玩家轮流行动。 双方的游戏方式一致。 双方均知道游戏的完整信息。 以玩家无法行动为游戏结束。 游戏在有限步数内结束，并且一定能分出胜负。 经典的 Nim游戏 就是公平组合游戏的代表，但是围棋、象棋以及井字棋这些不属于，因为这三种双方的行动不同，且可能存在平局。 必胜与必败必胜点：常用字母 $\rm N$ 表示（意为 ”Next”，即执行这一步的人会赢），若某一方在此状态，且接下来双方操作均最优，则该方必胜。 必败点：常用字母 $\rm P$ 表示（意为 “Previous”，即执行上一步的人会赢），若某一方在此状态，且接下来双方操作均最优，则该方必败。 性质：我们定义一个点的 后继状态 为从该点通过一次操作得到的新状态。显然最后游戏结束的点没有后继状态，所以一般都已知是必败点，同时这个点也一定是其它某些点的后继状态。如果某个点的后继状态中有一个是必败点，则该点必胜。如果某个点的后继状态全部是必胜点，则该点必败。因此我们通过已知的点可以推出其它点是必胜点还是必败点。 $\rm SG$ 函数我们可以把一个 公平组合游戏 放到 DAG 上。 对于任意一个点，它指向它的所有后继状态，即连一条单向边。 若当前的图为 $G(V,E)$，则对于一个点 $u$，它的 $\rm SG$ 函数值为： g(u) = {\rm mex}(\{ g(v) \mid \forall (u,v) \in E \})其中 $\rm mex$ 是定义域在集合上的函数。设 $S$ 表示一个自然数集合，${\rm mex}(S)$ 返回集合 $S$ 中最小没出现过的自然数。 \begin{aligned} {\rm mex}(\varnothing ) &= 0\\[1ex] {\rm mex}(\{0\} ) &= 1\\[1ex] {\rm mex}(\{0,1,3,4\}) &= 2 \end{aligned}结论： 有向图游戏的某个局面必胜，当且仅当该局面对应节点的 $\rm SG$ 函数值大于 $0$ 。 有向图游戏的某个局面必败，当且仅当该局面对应节点的 $\rm SG$ 函数值等于 $0$ 。 解释： 对于一个出度为 $0$ 的节点，它的 $\rm SG$ 函数值为 $0$，对应必败点。 若一个节点的某个后继节点的 $\rm SG$ 函数值为 $0$，则在 $\rm mex$ 运算后该节点的 $\rm SG$ 函数值大于 $0$ 。等价于该点的后继状态中有一个是必败点，该点必胜。 若一个节点的所有后继节点的 $\rm SG$ 函数值均大于 $0$，则在 $\rm mex$ 运算后该节点的 $\rm SG$ 函数值等于 $0$ 。等价于该点的后继状态全部是必胜点，该点必败。 应用举例：[hdu]1847 $\rm SG$ 定理令 $G = G_1 + G_2 + \cdots + G_n$，设 $G_i$ 的 $\rm SG$ 函数值为 $g_i$，$G$ 的 $\rm SG$ 函数值为 $g$，则 g(X) = g((x_1,x_2,\ldots,x_n)) = g_1(x_1) \oplus g_2(x_2) \oplus \cdots \oplus g_n(x_n)其中 $X \in V,x_i \in V_i$，$\oplus$ 是异或运算。]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AtCoder ABC126-F」XOR Matching]]></title>
    <url>%2Fproblems%2Fatcoder-abc126-f%2F</url>
    <content type="text"><![CDATA[Description构造一个序列 $\{a\}$，这个序列的长度是 $2^{m + 1}$，且 $0 \sim 2^m - 1$ 中的每一个整数都必须出现 $2$ 次。对于任何 $a_i = a_j\ (i &lt; j)$，都满足 $a_i \oplus a_{i + 1} \oplus \cdots \oplus a_{j - 1} \oplus a_j = k$ 。 如果不存在这样的序列输出 -1 。$(0 \leq m \leq 17,0 \leq k \leq 10^9)$ Source[AtCoder]ABC126-F Solution显然当 $k &gt; 2^m - 1$ 时无解，因为 $2^m - 1$ 的每一个二进制位都是 $1$，与比它小的数异或后不可能大于 $2^m - 1$ 。 考虑构造一个合法的序列。 我们在中间放一个数 $k$，然后在其两边放相同的数，比如： 0,1,2,3,\ldots ,2^m - 1,k,2^m - 1,\ldots,3,2,1,0这显然是没有问题的，因为对于任意两个相同的数，它们中间两两相同的数能互相抵消为 $0$，最终的异或和一定是 $k$ 。如果按这种方法构造，可以让除了 $k$ 之外的所有数符合条件，但是还多了一个 $k$，考虑这个 $k$ 应该放在哪里。 我们可以通过异或运算的性质得到一个结论： $n$ 为大于 $1$ 的整数时，存在 0 \oplus 1 \oplus 2 \oplus \cdots \oplus (2^n - 1) = 0证明： 将它们两两异或得到一个新的序列。 \begin{aligned} 0 \oplus (2^n - 1) &= 2^n - 1\\[1ex] 1 \oplus (2^n - 2) &= 2^n - 1\\[1ex] 2 \oplus (2^n - 3) &= 2^n - 1\\[1ex] \cdots &\cdots\\[1ex] (2^{n - 1} -1) \oplus 2^{n - 1} &= 2^n - 1 \end{aligned}显然异或后只剩下 $2^{n - 1}$ 个 $2^n - 1$，根据异或运算的性质（偶数个相同数的异或和为 $0$）得到：当 $n &gt; 1$ 时，$2^{n - 1}$ 一定为偶数，该式子的值为 $0$ 得证。 因此我们只需要将另一个 $k$ 放在最后即可，这样两个 $k$ 中间的数与其中一个 $k$ 的异或和刚好为 $0$，$0$ 异或另一个 $k$ 的值为 $k$ 。最后注意 $n = 1$ 时结论不成立需要特判。时间复杂度为 $O(n)$ 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = (1 &lt;&lt; 18) + 5;int n, m, k, maxn, ans[MAXN + 5];int main() &#123; read(m), read(k); maxn = (1 &lt;&lt; m) - 1, n = 1 &lt;&lt; (m + 1); if (m == 1) &#123;//特判 m = 1 if (k == 0) puts("0 0 1 1"); else puts("-1"); return 0; &#125; if (k &gt; maxn) &#123;//无解 puts("-1"); return 0; &#125; ans[n / 2] = ans[n] = k;//中间和末项都是 k for (int p = 0, i = 1; i &lt;= maxn; ++i, ++p) &#123; if (p == k) ++p;//k 已经被占用，k 的两边不能放 k ans[i] = ans[n - i] = p;//对称地在 k 两边放数 &#125; for (int i = 1; i &lt;= n; ++i) &#123; write(ans[i]); putchar(' '); &#125; putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 3261」最大异或和]]></title>
    <url>%2Fproblems%2Fbzoj-3261%2F</url>
    <content type="text"><![CDATA[Description给定一个非负整数序列 $\{a\}$，初始长度为 $N$ 。 有 $M$ 个操作，有以下两种操作类型： A x：添加操作，表示在序列末尾添加一个数 $x$，序列的长度 $N+1$ 。 Q l r x：询问操作，你需要找到一个位置 $p$，满足 $l \le p \le r$，使得 $a_p \oplus a_{p+1} \oplus \cdots \oplus a_N \oplus x$ 最大，输出最大是多少。 $(1 \leq N,M \leq 3 \times 10^5,0 \leq a_i \leq 10^7)$ Source[BZOJ]3261 Solution先考虑简化问题。 我们可以像前缀和一样预处理出 $pre_i = a_1 \oplus a_2 \oplus \cdots \oplus a_i$，再根据异或运算的性质，可以得到： a_l \oplus a_{l + 1} \oplus \cdots \oplus a_{r - 1} \oplus a_r = pre_{r} \oplus pre_{l - 1}问题就变为找到一个位置 $p - 1$，满足 $l - 1 \le p - 1 \le r - 1$，使得 $pre_n \oplus pre_{p - 1} \oplus x$ 最大。显然 $pre_n$ 和 $x$ 都已知，所以我们只需要找与 $x \oplus pre_n$ 在指定范围内且异或结果最大的 $pre_{p - 1}$ 即可。 看到这个问题，很容易想到用 0-1 Trie 来维护。但是因为限制了区间，一棵 Trie 是肯定不够用的，所以还要 可持久化 。 可持久化 Trie 和 主席树 的实现方法相似。我们每插入一个前缀异或和 $pre_i$，就建一棵 Trie 。由于第 $i$ 棵 Trie 与第 $i - 1$ 棵 Trie 最多只会有 $\log n$ 棵节点是不同的。所以插入时，我们只需要新建一个根，只对当前数的每一位新建节点，其余的点连向上一棵树。这样空间复杂度可以优化为 $O(n \log n)$ 。在上述插入的过程中，我们只需要记录第 $i$ 棵 Trie 每个节点的个数，就能判断一个区间内是否有该节点。查询也很容易，从第 $l - 2$ 与第 $r - 1$ 棵 Trie 的根开始（因为这两棵 Trie 之间的数为 $pre_{l - 1} \sim pre_{r - 1}$），判断是否存在与 $x$ 某一位取反的节点，具体过程类似 [LOJ]10050 。不要忘记在第 $0$ 棵 Trie 上插入 $0$，时间复杂度为 $O(n \log n)$ 。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;inline void readChar(char &amp;c) &#123; for (c = getchar(); c != 'A' &amp;&amp; c != 'Q'; c = getchar());&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 6e5;int n, m, pre[MAXN + 5];struct Trie &#123; int tot, root[MAXN + 5], sum[MAXN * 23 + 5], ch[MAXN * 23 + 5][2]; inline void update(int &amp;rt, int pre, int x) &#123; rt = ++tot;//建一个新的根 int u = rt;//当前节点 for (int i = 23; ~i; --i) &#123; bool v = x &amp; (1 &lt;&lt; i); ch[u][v] = ++tot, ch[u][v ^ 1] = ch[pre][v ^ 1]; //对当前数新建节点，另一分支连向上一棵树 u = ch[u][v], pre = ch[pre][v];//向下一层走 sum[u] = sum[pre] + 1;//记录该节点个数 &#125; &#125; inline int query(int ql, int qr, int x) &#123; int res = 0; for (int i = 23; ~i; --i) &#123; bool v = x &amp; (1 &lt;&lt; i); if (ch[ql][v ^ 1] &lt; ch[qr][v ^ 1]) &#123;//存在相反的节点 res += 1 &lt;&lt; i;//异或后第 i 位上是 1 ql = ch[ql][v ^ 1], qr = ch[qr][v ^ 1]; &#125; else ql = ch[ql][v], qr = ch[qr][v];//同时向下一层走 &#125; return res; &#125;&#125; tr;int main() &#123; read(n), read(m); tr.update(tr.root[0], 0, 0);//在第 0 棵 Trie 中插入 0 for (int x, i = 1; i &lt;= n; ++i) &#123; read(x); pre[i] = pre[i - 1] ^ x;//前缀异或和 tr.update(tr.root[i], tr.root[i - 1], pre[i]);//在上一棵 Trie 的基础上插入 pre[i] &#125; for (int l, r, x, i = 1; i &lt;= m; ++i) &#123; char opt; readChar(opt); if (opt == 'A') &#123; read(x); ++n; pre[n] = pre[n - 1] ^ x;//更新前缀异或和 tr.update(tr.root[n], tr.root[n - 1], pre[n]);//插入新数 &#125; else &#123; read(l), read(r), read(x); if (l == 1) write(tr.query(0, tr.root[r - 1], x ^ pre[n])); //l = 1 时，要把 p = 1 的情况算进去，也就是说 Trie 中还要有 0 这个数， //因为 x ^ pre[n] 可能是最大的 else write(tr.query(tr.root[l - 2], tr.root[r - 1], x ^ pre[n])); //区间为 [l - 1, r - 1]，所以起始的根应该为 l - 2 和 r - 1 putchar('\n'); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>Trie</tag>
        <tag>可持久化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P4735」最大异或和]]></title>
    <url>%2Fproblems%2Fluogu-p4735%2F</url>
    <content type="text"><![CDATA[Description给定一个非负整数序列 $\{a\}$，初始长度为 $N$ 。 有 $M$ 个操作，有以下两种操作类型： A x：添加操作，表示在序列末尾添加一个数 $x$，序列的长度 $N+1$ 。 Q l r x：询问操作，你需要找到一个位置 $p$，满足 $l \le p \le r$，使得 $a_p \oplus a_{p+1} \oplus \cdots \oplus a_N \oplus x$ 最大，输出最大是多少。 $(1 \leq N,M \leq 3 \times 10^5,0 \leq a_i \leq 10^7)$ Source[Luogu]P4735 Solution先考虑简化问题。 我们可以像前缀和一样预处理出 $pre_i = a_1 \oplus a_2 \oplus \cdots \oplus a_i$，再根据异或运算的性质，可以得到： a_l \oplus a_{l + 1} \oplus \cdots \oplus a_{r - 1} \oplus a_r = pre_{r} \oplus pre_{l - 1}问题就变为找到一个位置 $p - 1$，满足 $l - 1 \le p - 1 \le r - 1$，使得 $pre_n \oplus pre_{p - 1} \oplus x$ 最大。显然 $pre_n$ 和 $x$ 都已知，所以我们只需要找与 $x \oplus pre_n$ 在指定范围内且异或结果最大的 $pre_{p - 1}$ 即可。 看到这个问题，很容易想到用 0-1 Trie 来维护。但是因为限制了区间，一棵 Trie 是肯定不够用的，所以还要 可持久化 。 可持久化 Trie 和 主席树 的实现方法相似。我们每插入一个前缀异或和 $pre_i$，就建一棵 Trie 。由于第 $i$ 棵 Trie 与第 $i - 1$ 棵 Trie 最多只会有 $\log n$ 棵节点是不同的。所以插入时，我们只需要新建一个根，只对当前数的每一位新建节点，其余的点连向上一棵树。这样空间复杂度可以优化为 $O(n \log n)$ 。在上述插入的过程中，我们只需要记录第 $i$ 棵 Trie 每个节点的个数，就能判断一个区间内是否有该节点。查询也很容易，从第 $l - 2$ 与第 $r - 1$ 棵 Trie 的根开始（因为这两棵 Trie 之间的数为 $pre_{l - 1} \sim pre_{r - 1}$），判断是否存在与 $x$ 某一位取反的节点，具体过程类似 [LOJ]10050 。不要忘记在第 $0$ 棵 Trie 上插入 $0$，时间复杂度为 $O(n \log n)$ 。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;inline void readChar(char &amp;c) &#123; for (c = getchar(); c != 'A' &amp;&amp; c != 'Q'; c = getchar());&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 6e5;int n, m, pre[MAXN + 5];struct Trie &#123; int tot, root[MAXN + 5], sum[MAXN * 23 + 5], ch[MAXN * 23 + 5][2]; inline void update(int &amp;rt, int pre, int x) &#123; rt = ++tot;//建一个新的根 int u = rt;//当前节点 for (int i = 23; ~i; --i) &#123; bool v = x &amp; (1 &lt;&lt; i); ch[u][v] = ++tot, ch[u][v ^ 1] = ch[pre][v ^ 1]; //对当前数新建节点，另一分支连向上一棵树 u = ch[u][v], pre = ch[pre][v];//向下一层走 sum[u] = sum[pre] + 1;//记录该节点个数 &#125; &#125; inline int query(int ql, int qr, int x) &#123; int res = 0; for (int i = 23; ~i; --i) &#123; bool v = x &amp; (1 &lt;&lt; i); if (ch[ql][v ^ 1] &lt; ch[qr][v ^ 1]) &#123;//存在相反的节点 res += 1 &lt;&lt; i;//异或后第 i 位上是 1 ql = ch[ql][v ^ 1], qr = ch[qr][v ^ 1]; &#125; else ql = ch[ql][v], qr = ch[qr][v];//同时向下一层走 &#125; return res; &#125;&#125; tr;int main() &#123; read(n), read(m); tr.update(tr.root[0], 0, 0);//在第 0 棵 Trie 中插入 0 for (int x, i = 1; i &lt;= n; ++i) &#123; read(x); pre[i] = pre[i - 1] ^ x;//前缀异或和 tr.update(tr.root[i], tr.root[i - 1], pre[i]);//在上一棵 Trie 的基础上插入 pre[i] &#125; for (int l, r, x, i = 1; i &lt;= m; ++i) &#123; char opt; readChar(opt); if (opt == 'A') &#123; read(x); ++n; pre[n] = pre[n - 1] ^ x;//更新前缀异或和 tr.update(tr.root[n], tr.root[n - 1], pre[n]);//插入新数 &#125; else &#123; read(l), read(r), read(x); if (l == 1) write(tr.query(0, tr.root[r - 1], x ^ pre[n])); //l = 1 时，要把 p = 1 的情况算进去，也就是说 Trie 中还要有 0 这个数， //因为 x ^ pre[n] 可能是最大的 else write(tr.query(tr.root[l - 2], tr.root[r - 1], x ^ pre[n])); //区间为 [l - 1, r - 1]，所以起始的根应该为 l - 2 和 r - 1 putchar('\n'); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>Trie</tag>
        <tag>可持久化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 1117C」Magic Ship]]></title>
    <url>%2Fproblems%2Fcodeforces-1117c%2F</url>
    <content type="text"><![CDATA[Description坐标系上有一只小船，现在想从 $(x_1,y_1)$ 去 $(x_2,y_2)$ 。每时刻都有风，会把船往对应的风向吹一个单位，风是循环的，吹完 $s_1 \sim s_n$ 就又会从 $s_1$ 开始。船在每一时刻都可以向指定方向移动一个单位。求船到目的地的最少时间，如果不能到达输出 -1 。$(1 \leq n \leq 10^5,0 \leq x_1,x_2,y_1,y_2 \leq 10^9)$ Source[Luogu]CF1117C [Codeforces]1117C Solution考虑 二分答案 。 首先要想到一个转化。虽然风吹与船行同时进行，但我们可以先让风吹完了再让船走。由于我们已经二分得到了时间，所以风吹完后小船的坐标我们是已知的（可以用前缀和预处理 $s_1 \sim s_n$ 前 $i$ 时刻每种风的数量），而小船到目的地的最短距离就是该坐标与目的地的 曼哈顿距离 。如果这个距离不超过时间，说明船是可以在规定的时间之内到达的。 二分的下界显然是 $0$，上界怎么算呢？如果风一直把船往与目的地相反的方向吹，只有一个时刻的风是相同方向的，那样经过 $n$ 时刻才能移动 $2$ 格，因此最坏情况下需要 $10^{14}$ 的时间。总时间复杂度为 $O(\log \max\{ans\})$ 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;inline void readChar(char &amp;c) &#123; for (c = getchar(); c != 'U' &amp;&amp; c != 'D' &amp;&amp; c != 'L' &amp;&amp; c != 'R'; c = getchar());&#125;const int MAXN = 1e5;LL sx, sy, tx, ty, n, ans = -1;int sum[100][MAXN + 5];char d[MAXN + 5];inline LL dist(LL x1, LL y1, LL x2, LL y2) &#123;//曼哈顿距离 return abs(x1 - x2) + abs(y1 - y2);&#125;inline bool check(LL p) &#123; LL x = sx + sum['R'][n] * (p / n) + sum['R'][p % n] - sum['L'][n] * (p / n) - sum['L'][p % n];//一共 p / n 次循环，多余的单独处理 LL y = sy + sum['U'][n] * (p / n) + sum['U'][p % n] - sum['D'][n] * (p / n) - sum['D'][p % n]; return dist(x, y, tx, ty) &lt;= p;//判断是否在能规定时间内到达目的地&#125;int main() &#123; read(sx), read(sy), read(tx), read(ty), read(n); for (int i = 1; i &lt;= n; ++i) &#123; readChar(d[i]); sum['R'][i] = sum['R'][i - 1] + (d[i] == 'R'); sum['L'][i] = sum['L'][i - 1] + (d[i] == 'L'); sum['U'][i] = sum['U'][i - 1] + (d[i] == 'U'); sum['D'][i] = sum['D'][i - 1] + (d[i] == 'D');//前缀和预处理 &#125; for (LL l = 0, r = 1e14; l &lt;= r; ) &#123;//二分答案，注意上界 LL mid = (l + r) &gt;&gt; 1; if (check(mid)) &#123; r = mid - 1; ans = mid; &#125; else l = mid + 1; &#125; write(ans); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>Codeforces</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 2824」「AHOI2012」铁盘整理]]></title>
    <url>%2Fproblems%2Fbzoj-2824%2F</url>
    <content type="text"><![CDATA[Description给定一个长度为 $n$ 互不相同的序列 $a_i$，每次操作可以将第 $1 \sim i\ (1 \leq i \leq n)$ 个数翻转，求最少几次操作可以使它变成升序数列。$(1 \leq n \leq 50, 1 \leq a_i \leq 100)$ Source[BZOJ]2824 Solution考虑 IDA* 。 先离散化，保证最后得到的数列为 $1,2,3, \ldots, n$ 。 本题中的 最完美估价： 12345678a[n + 1] = n + 1;inline int h() &#123; int cnt = 0; for (int i = 1; i &lt;= n; ++i) cnt += abs(a[i] - a[i + 1]) != 1; return cnt;&#125; 显然一次翻转最多只能改变一对相邻数的差（比如翻转第 $1 \sim 3$ 个数只能改变第 $3$ 个数与第 $4$ 个数的差）。因此对于一个序列，有多少对相邻的数差不为 $1$，就至少要翻转多少次。不要忘记把第 $n + 1$ 个数设为 $n + 1$，因为如果翻转第 $1 \sim n$ 个数，我们也可以认为改变了第 $n$ 个数与第 $n + 1$ 个数的差。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 50;int n, a[MAXN + 5], b[MAXN + 5];bool sol;inline int h() &#123;//最完美估价 int cnt = 0; for (int i = 1; i &lt;= n; ++i) cnt += abs(a[i] - a[i + 1]) != 1; return cnt;&#125;void dfs(int g, int f, int pre) &#123; if (sol || g + h() &gt; f) return;//预估步数 if (!h()) &#123; sol = 1;//找到答案 return; &#125; for (int i = 1; i &lt;= n; ++i) &#123; if (i == pre) continue;//保证不与上一次翻转的长度相同 reverse(a + 1, a + i + 1);//翻转 dfs(g + 1, f, i); reverse(a + 1, a + i + 1);//回溯 &#125;&#125;int main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); b[i] = a[i]; &#125; sort(b + 1, b + n + 1); for (int i = 1; i &lt;= n; ++i) a[i] = lower_bound(b + 1, b + n + 1, a[i]) - b;//离散化 a[n + 1] = n + 1; for (int i = 0; ; ++i) &#123;//迭代加深 sol = 0; dfs(0, i, 0); if (sol) &#123; write(i); putchar('\n'); break; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>启发式搜索</tag>
        <tag>迭代加深</tag>
        <tag>搜索</tag>
        <tag>AHOI</tag>
        <tag>2012</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2534」「AHOI2012」铁盘整理]]></title>
    <url>%2Fproblems%2Fluogu-p2534%2F</url>
    <content type="text"><![CDATA[Description给定一个长度为 $n$ 互不相同的序列 $a_i$，每次操作可以将第 $1 \sim i\ (1 \leq i \leq n)$ 个数翻转，求最少几次操作可以使它变成升序数列。$(1 \leq n \leq 50, 1 \leq a_i \leq 100)$ Source[Luogu]P2534 Solution考虑 IDA* 。 先离散化，保证最后得到的数列为 $1,2,3, \ldots, n$ 。 本题中的 最完美估价： 12345678a[n + 1] = n + 1;inline int h() &#123; int cnt = 0; for (int i = 1; i &lt;= n; ++i) cnt += abs(a[i] - a[i + 1]) != 1; return cnt;&#125; 显然一次翻转最多只能改变一对相邻数的差（比如翻转第 $1 \sim 3$ 个数只能改变第 $3$ 个数与第 $4$ 个数的差）。因此对于一个序列，有多少对相邻的数差不为 $1$，就至少要翻转多少次。不要忘记把第 $n + 1$ 个数设为 $n + 1$，因为如果翻转第 $1 \sim n$ 个数，我们也可以认为改变了第 $n$ 个数与第 $n + 1$ 个数的差。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 50;int n, a[MAXN + 5], b[MAXN + 5];bool sol;inline int h() &#123;//最完美估价 int cnt = 0; for (int i = 1; i &lt;= n; ++i) cnt += abs(a[i] - a[i + 1]) != 1; return cnt;&#125;void dfs(int g, int f, int pre) &#123; if (sol || g + h() &gt; f) return;//预估步数 if (!h()) &#123; sol = 1;//找到答案 return; &#125; for (int i = 1; i &lt;= n; ++i) &#123; if (i == pre) continue;//保证不与上一次翻转的长度相同 reverse(a + 1, a + i + 1);//翻转 dfs(g + 1, f, i); reverse(a + 1, a + i + 1);//回溯 &#125;&#125;int main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); b[i] = a[i]; &#125; sort(b + 1, b + n + 1); for (int i = 1; i &lt;= n; ++i) a[i] = lower_bound(b + 1, b + n + 1, a[i]) - b;//离散化 a[n + 1] = n + 1; for (int i = 0; ; ++i) &#123;//迭代加深 sol = 0; dfs(0, i, 0); if (sol) &#123; write(i); putchar('\n'); break; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>启发式搜索</tag>
        <tag>迭代加深</tag>
        <tag>搜索</tag>
        <tag>AHOI</tag>
        <tag>2012</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 1085」「SCOI2005」骑士精神]]></title>
    <url>%2Fproblems%2Fbzoj-1085%2F</url>
    <content type="text"><![CDATA[Description在一个 $5 \times 5$ 的棋盘上有白色和黑色的骑士各 $12$ 个，以及一个空位（每个骑士都可以移动到和它横坐标相差 $2$，纵坐标相差 $1$ 或横坐标相差 $1$，纵坐标相差 $2$ 的空位上）。给定初始棋盘，求出至少移动多少次能得到目标棋盘（如下图）。如果 $15$ 步以内不能得到，输出 $-1$ 。 Source[BZOJ]1085 SolutionIDA* 经典题。 不管是 A* 还是 IDA*，最重要的就是 估价函数，定义为： f(n) = g(n) + h(n)其中 $f(n)$ 是节点 $n$ 的估价函数，$g(n)$ 是当前的实际步数，$h(n)$ 是对未来步数的最完美估价。 为什么是这样呢？ 假设你觉得到 $n$ 这个状态需要 $f(n)$ 步，你到当前状态已经花了 $g(n)$ 步，现在你想从当前状态到 $n$ 这个状态，在运气最好的情况下还需要 $h(n)$ 步。若 $g(n) + h(n) &gt; f(n)$，则显然当前状态不能再 $f(n)$ 步之内到达 $n$ 这个状态。 如果要让所有马归位，状态数会非常多，所以我们考虑移动空位，即让空位与马交换位置，直到当前状态与目标状态相同。除此之外，这道题有要求 $15$ 步之内完成，所以可以 迭代加深，即规定最大深度，超过这个深度就直接退出。换句话说，我们可以把这个最大深度作为 $f(n)$ 。 本题中的 最完美估价： 123456789101112131415161718192021const int goal[MAXN + 1][MAXN + 1] = &#123; //目标矩阵 &#123; 0, 0, 0, 0, 0, 0 &#125;, &#123; 0, 1, 1, 1, 1, 1 &#125;, &#123; 0, 0, 1, 1, 1, 1 &#125;, &#123; 0, 0, 0, -1, 1, 1 &#125;, &#123; 0, 0, 0, 0, 0, 1 &#125;, &#123; 0, 0, 0, 0, 0, 0 &#125; &#125;;inline int h() &#123;//最完美估价 int cnt = 0; for (int i = 1; i &lt;= 5; ++i) for (int j = 1; j &lt;= 5; ++j) cnt += a[i][j] != goal[i][j]; //我们统计了当前状态与目标状态不同的位置个数为 cnt， //但是我们实际要统计的是不在自己位置上的马的个数， //这里我们把空位也算了进去，若所有马都在自己位置上， //则此时空位也一定在自己的位置上，由此可得， //空位对结果没有影响，所以最后 cnt 要 -1 return cnt - 1;&#125; 对于一匹不在自己位置上的马，在最优的情况下，我们只需要一次移动就能使这匹马归位。假设每一匹这样的马都需要移动一次，所以我们统计这样的马的个数即可。 还有一个剪枝，就是记录上一步是空格在哪个位置，下一步再跳回上一步的位置显然不优，这样可以少掉很多无用递归。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;inline void readChar(char &amp;c) &#123; for (c = getchar(); c != '0' &amp;&amp; c != '1' &amp;&amp; c != '*'; c = getchar());&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 5;const int dx[8] = &#123; -2, -1, 2, 1, 2, 1, -1, -2 &#125;;const int dy[8] = &#123; 1, 2, 1, 2, -1, -2, -2, -1 &#125;;const int goal[MAXN + 1][MAXN + 1] = &#123; //目标矩阵，空位标记为 -1 &#123; 0, 0, 0, 0, 0, 0 &#125;, &#123; 0, 1, 1, 1, 1, 1 &#125;, &#123; 0, 0, 1, 1, 1, 1 &#125;, &#123; 0, 0, 0, -1, 1, 1 &#125;, &#123; 0, 0, 0, 0, 0, 1 &#125;, &#123; 0, 0, 0, 0, 0, 0 &#125; &#125;;int t, sx, sy, a[MAXN + 5][MAXN + 5];bool sol;inline int h() &#123;//最完美估价 int cnt = 0; for (int i = 1; i &lt;= 5; ++i) for (int j = 1; j &lt;= 5; ++j) cnt += a[i][j] != goal[i][j]; //我们统计了当前状态与目标状态不同的位置个数为 cnt， //但是我们实际要统计的是不在自己位置上的马的个数， //这里我们把空位也算了进去，若所有马都在自己位置上， //则此时空位也一定在自己的位置上，由此可得， //空位对结果没有影响，所以最后 cnt 要 -1 return cnt - 1;&#125;void dfs(int x, int y, int g, int f, int prex, int prey) &#123; if (sol || x &lt; 1 || x &gt; 5 || y &lt; 1 || y &gt; 5 || g + h() &gt; f) return; if (h() == -1) &#123;//若最完美估价为 -1，说明当前状态与目标状态重合 sol = 1;//标记为有解 return; &#125; for (int i = 0; i &lt; 8; ++i) &#123; int tx = x + dx[i], ty = y + dy[i]; if (tx == prex &amp;&amp; ty == prey) continue;//保证下一步不与上一步相同 swap(a[x][y], a[tx][ty]);//空格与马交换位置 dfs(tx, ty, g + 1, f, x, y);//继续搜，当前步数 +1 swap(a[x][y], a[tx][ty]);//回溯 &#125;&#125;int main() &#123; for (read(t); t; --t) &#123; for (int i = 1; i &lt;= 5; ++i) for (int j = 1; j &lt;= 5; ++j) &#123; char c; readChar(c); if (c == '*') &#123; sx = i, sy = j;//空位位置 a[i][j] = -1;//标记为 -1 &#125; else a[i][j] = c ^ 48;//字符转成数字 &#125; int ans = -1; for (int i = 0; i &lt;= 15; ++i) &#123;//迭代加深（规定深度搜索） sol = 0; dfs(sx, sy, 0, i, 0, 0); if (sol) &#123; ans = i;//深度为 i 时有解 break; &#125; &#125; write(ans); putchar('\n'); &#125; return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>SCOI</tag>
        <tag>2005</tag>
        <tag>启发式搜索</tag>
        <tag>迭代加深</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2324」「SCOI2005」骑士精神]]></title>
    <url>%2Fproblems%2Fluogu-p2324%2F</url>
    <content type="text"><![CDATA[Description在一个 $5 \times 5$ 的棋盘上有白色和黑色的骑士各 $12$ 个，以及一个空位（每个骑士都可以移动到和它横坐标相差 $2$，纵坐标相差 $1$ 或横坐标相差 $1$，纵坐标相差 $2$ 的空位上）。给定初始棋盘，求出至少移动多少次能得到目标棋盘（如下图）。如果 $15$ 步以内不能得到，输出 $-1$ 。 Source[Luogu]P2324 SolutionIDA* 经典题。 不管是 A* 还是 IDA*，最重要的就是 估价函数，定义为： f(n) = g(n) + h(n)其中 $f(n)$ 是节点 $n$ 的估价函数，$g(n)$ 是当前的实际步数，$h(n)$ 是对未来步数的最完美估价。 为什么是这样呢？ 假设你觉得到 $n$ 这个状态需要 $f(n)$ 步，你到当前状态已经花了 $g(n)$ 步，现在你想从当前状态到 $n$ 这个状态，在运气最好的情况下还需要 $h(n)$ 步。若 $g(n) + h(n) &gt; f(n)$，则显然当前状态不能再 $f(n)$ 步之内到达 $n$ 这个状态。 如果要让所有马归位，状态数会非常多，所以我们考虑移动空位，即让空位与马交换位置，直到当前状态与目标状态相同。除此之外，这道题有要求 $15$ 步之内完成，所以可以 迭代加深，即规定最大深度，超过这个深度就直接退出。换句话说，我们可以把这个最大深度作为 $f(n)$ 。 本题中的 最完美估价： 123456789101112131415161718192021const int goal[MAXN + 1][MAXN + 1] = &#123; //目标矩阵 &#123; 0, 0, 0, 0, 0, 0 &#125;, &#123; 0, 1, 1, 1, 1, 1 &#125;, &#123; 0, 0, 1, 1, 1, 1 &#125;, &#123; 0, 0, 0, -1, 1, 1 &#125;, &#123; 0, 0, 0, 0, 0, 1 &#125;, &#123; 0, 0, 0, 0, 0, 0 &#125; &#125;;inline int h() &#123;//最完美估价 int cnt = 0; for (int i = 1; i &lt;= 5; ++i) for (int j = 1; j &lt;= 5; ++j) cnt += a[i][j] != goal[i][j]; //我们统计了当前状态与目标状态不同的位置个数为 cnt， //但是我们实际要统计的是不在自己位置上的马的个数， //这里我们把空位也算了进去，若所有马都在自己位置上， //则此时空位也一定在自己的位置上，由此可得， //空位对结果没有影响，所以最后 cnt 要 -1 return cnt - 1;&#125; 对于一匹不在自己位置上的马，在最优的情况下，我们只需要一次移动就能使这匹马归位。假设每一匹这样的马都需要移动一次，所以我们统计这样的马的个数即可。 还有一个剪枝，就是记录上一步是空格在哪个位置，下一步再跳回上一步的位置显然不优，这样可以少掉很多无用递归。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;inline void readChar(char &amp;c) &#123; for (c = getchar(); c != '0' &amp;&amp; c != '1' &amp;&amp; c != '*'; c = getchar());&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 5;const int dx[8] = &#123; -2, -1, 2, 1, 2, 1, -1, -2 &#125;;const int dy[8] = &#123; 1, 2, 1, 2, -1, -2, -2, -1 &#125;;const int goal[MAXN + 1][MAXN + 1] = &#123; //目标矩阵，空位标记为 -1 &#123; 0, 0, 0, 0, 0, 0 &#125;, &#123; 0, 1, 1, 1, 1, 1 &#125;, &#123; 0, 0, 1, 1, 1, 1 &#125;, &#123; 0, 0, 0, -1, 1, 1 &#125;, &#123; 0, 0, 0, 0, 0, 1 &#125;, &#123; 0, 0, 0, 0, 0, 0 &#125; &#125;;int t, sx, sy, a[MAXN + 5][MAXN + 5];bool sol;inline int h() &#123;//最完美估价 int cnt = 0; for (int i = 1; i &lt;= 5; ++i) for (int j = 1; j &lt;= 5; ++j) cnt += a[i][j] != goal[i][j]; //我们统计了当前状态与目标状态不同的位置个数为 cnt， //但是我们实际要统计的是不在自己位置上的马的个数， //这里我们把空位也算了进去，若所有马都在自己位置上， //则此时空位也一定在自己的位置上，由此可得， //空位对结果没有影响，所以最后 cnt 要 -1 return cnt - 1;&#125;void dfs(int x, int y, int g, int f, int prex, int prey) &#123; if (sol || x &lt; 1 || x &gt; 5 || y &lt; 1 || y &gt; 5 || g + h() &gt; f) return; if (h() == -1) &#123;//若最完美估价为 -1，说明当前状态与目标状态重合 sol = 1;//标记为有解 return; &#125; for (int i = 0; i &lt; 8; ++i) &#123; int tx = x + dx[i], ty = y + dy[i]; if (tx == prex &amp;&amp; ty == prey) continue;//保证下一步不与上一步相同 swap(a[x][y], a[tx][ty]);//空格与马交换位置 dfs(tx, ty, g + 1, f, x, y);//继续搜，当前步数 +1 swap(a[x][y], a[tx][ty]);//回溯 &#125;&#125;int main() &#123; for (read(t); t; --t) &#123; for (int i = 1; i &lt;= 5; ++i) for (int j = 1; j &lt;= 5; ++j) &#123; char c; readChar(c); if (c == '*') &#123; sx = i, sy = j;//空位位置 a[i][j] = -1;//标记为 -1 &#125; else a[i][j] = c ^ 48;//字符转成数字 &#125; int ans = -1; for (int i = 0; i &lt;= 15; ++i) &#123;//迭代加深（规定深度搜索） sol = 0; dfs(sx, sy, 0, i, 0, 0); if (sol) &#123; ans = i;//深度为 i 时有解 break; &#125; &#125; write(ans); putchar('\n'); &#125; return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>SCOI</tag>
        <tag>2005</tag>
        <tag>启发式搜索</tag>
        <tag>迭代加深</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NowCoder 342C」筱玛的迷阵探险]]></title>
    <url>%2Fproblems%2Fnowcoder-342c%2F</url>
    <content type="text"><![CDATA[Description给定一个 $n \times n$ 的网格，每个格子的权值为 $a_{i,j}$，现在要从 $(1,1)$ 走到 $(n,m)$，初始值为 $e$，求路径最大异或和。$(1 \leq n \leq 20,0 \leq a_{i,j},e \leq 10^9)$ Source[NowCoder]342C Solution与 [Codeforces]1006F 相似，考虑 折半搜索 。从起点和终点分别开始搜，到对角线停止。 怎么求最大异或和呢？ 我们可以建 $n$ 棵 Trie 。当我们第一次搜到对角线上的点 $(x,y)$ 时，把此时的路径异或和插入到第 $x$ 棵 Trie 中。当我们第二次从终点搜到 $(x,y)$ 时，又得到了一个路径和 $val$，显然这时我们要从第 $x$ 棵 Trie 中找到一个数，使它与 $val$ 的异或值最大。这就变成了一个很经典的问题，具体操作详见 [LOJ]10050 。注意搜索的边界和 Trie 的空间大小。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 20, MAXM = 1e5;int n, e, ans, a[MAXN + 5][MAXN + 5];struct Trie &#123; int tot, ch[MAXM * 31 + 5][2]; inline void insert(int x) &#123; int u = 1; for (int i = 30; ~i; --i) &#123; bool v = x &amp; (1 &lt;&lt; i);//x 二进制下第 i 位的值 if (!ch[u][v]) ch[u][v] = ++tot;//新建节点 u = ch[u][v]; &#125; &#125; inline int find(int x) &#123; int u = 1, res = 0; for (int i = 30; ~i; --i) &#123; bool v = x &amp; (1 &lt;&lt; i);//x 二进制下第 i 位的值 if (!ch[u][v ^ 1]) u = ch[u][v];//如果没有相反的路，则沿相同的路走 else &#123; res += 1 &lt;&lt; i;//走相反的路 u = ch[u][v ^ 1];//这一位为 1，累加答案 &#125; &#125; return res; &#125;&#125; tr[MAXN + 5];void dfs1(int x, int y, int val) &#123; if (x + y == n + 1) &#123;//(x,y) 在对角线上，n + 1 是为了防止 n = 1 时出错 tr[x].insert(val);//把 val 插入到第 x 棵 Trie 中 return; &#125; if (x &lt; n) dfs1(x + 1, y, val ^ a[x + 1][y]); if (y &lt; n) dfs1(x, y + 1, val ^ a[x][y + 1]);//注意边界 &#125;void dfs2(int x, int y, int val) &#123; if (x + y == n + 1) &#123; ans = max(ans, tr[x].find(val ^ e ^ a[x][y])); //不要忘记异或上初始值 e //这里异或 a[x][y] 是因为第二次到这个点多异或了 (x,y) 一次， //而第一次到 (x,y) 时已经异或过了，再异或一次相当于只保留一次异或 return; &#125; if (x &gt; 1) dfs2(x - 1, y, val ^ a[x - 1][y]); if (y &gt; 1) dfs2(x, y - 1, val ^ a[x][y - 1]);&#125;int main() &#123; read(n), read(e); for (int i = 1; i &lt;= n; ++i) &#123; tr[i].tot = 1;//Trie 初始节点数为 1 for (int j = 1; j &lt;= n; ++j) read(a[i][j]); &#125; dfs1(1, 1, a[1][1]), dfs2(n, n, a[n][n]); write(ans); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>Trie</tag>
        <tag>NowCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 1006F」Xor-Paths]]></title>
    <url>%2Fproblems%2Fcodeforces-1006f%2F</url>
    <content type="text"><![CDATA[Description给定一个 $n \times m$ 的网格，每个格子的权值为 $a_{i,j}$，现在要从 $(1,1)$ 走到 $(n,m)$，求异或和等于 $k$ 的路径数。 $(1 \leq n,m \leq 20,0 \leq a_{i,j},k \leq 10^{18})$ Source[Luogu]CF1006F [Codeforces]1006F Solution$n,m$ 的范围很小，所以考虑搜索。 直接暴搜显然不行，因为路径数很多。 所以使用 折半搜索 。 从起点和终点开始分别搜索，搜到对角线停止，设路径总数为 $k$，则时间复杂度可以降为 $O(\sqrt k)$ 。 起点开始只能向下或向右走，终点开始只能向上或向左走，注意边界。 我们可以开一个 $\rm map$ 存下从 $(1,1)$ 到对角线上的点 $(x,y)$ 异或和为 $val$ 的路径数。第二次搜到 $(x,y)$ 时，若当前异或和为 $val$，则答案需要加上从 $(1,1)$ 到 $(x,y)$ 异或和为 $k \oplus val$ 的路径数（$\oplus$ 表示异或，异或的逆运算也是异或）。 怎么判断 $(x,y)$ 是否在对角线上？只要看 $x+y$ 是否与 $\left \lfloor \frac{n + m}{2} \right \rfloor + 1$ 相等即可（对角线是一次函数）。至于为什么 $+1$，是因为能够防止 $n = m = 1$ 的情况出错。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 20;int n, m;LL k, ans, a[MAXN + 5][MAXN + 5];map&lt;LL, LL&gt; cnt[MAXN + 5];void dfs1(int x, int y, LL val) &#123;//表示当前到点 (x,y)，路径异或和为 val if (x + y == (n + m) / 2 + 1) &#123; ++cnt[x][val];//统计 (1,1) -&gt; (x,y) 异或和为 val 的路径数 return; &#125; if (x &lt; n) dfs1(x + 1, y, val ^ a[x + 1][y]); if (y &lt; m) dfs1(x, y + 1, val ^ a[x][y + 1]);&#125;void dfs2(int x, int y, LL val) &#123; if (x + y == (n + m) / 2 + 1) &#123;//搜到对角线就停止 ans += cnt[x][k ^ val ^ a[x][y]]; //这里异或 a[x][y] 是因为第二次到这个点多异或了 (x,y) 一次， //而第一次到 (x,y) 时已经异或过了，再异或一次相当于只保留一次异或 return; &#125; if (x &gt; 1) dfs2(x - 1, y, val ^ a[x - 1][y]); if (y &gt; 1) dfs2(x, y - 1, val ^ a[x][y - 1]);&#125;int main() &#123; read(n), read(m), read(k); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) read(a[i][j]); dfs1(1, 1, a[1][1]), dfs2(n, m, a[n][m]); write(ans); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P4168」「Violet」蒲公英]]></title>
    <url>%2Fproblems%2Fluogu-p4168%2F</url>
    <content type="text"><![CDATA[Description给定 $n$ 个数 $a_i$，$m$ 个询问，求区间 $[l,r]$ 中的最小众数，强制在线。 $(1 \leq n \leq 4\times10^4,1 \leq m \leq 5 \times 10^4, 1 \leq a_i \leq 10^9)$ Source[Luogu]P4168 Solution 1考虑 分块 。我们可以预处理出 $f_{i,j}$ 为第 $i$ 个块到第 $j$ 个块的区间最小众数，那样区间 $[l,r]$ 的答案只有可能是 中间所有块的区间最小众数，左边多余块中的数 或 右边多余块中的数（如图）。 很容易在 $O(块的大小 \times n)$ 的时间内预处理出所有的 $f_{i,j}$，但是怎么求出左右多余块中的数在区间 $[l,r]$ 中的出现次数呢？我们可以用 $\rm vector$ 存下每一个 $a_i$ 在序列中的所有出现位置（要先离散化）。在询问时，对于左右多余块中的每一个数 $x$，我们可以二分找到端点 $l,r$ 在 $x$ 对应的 $\rm vector$ 中的位置（可以用 $\rm STL$ 中的 $\rm lower\_bound$ 和 $\rm upper\_bound$），相减即是 $x$ 在区间 $[l,r]$ 中的出现次数。注意如果该数的出现次数与当前答案的出现次数相同，但这个数更小，也要更新答案，因为要求的是最小众数。 设块的大小为 $S$，则总时间复杂度为 预处理 $O \left( \frac{n^2}{S} \right)$ + 查询 $O(mS\log n)$，根据 均值不等式，可知取 $S = \frac{n}{\sqrt{m \log n}}$ 时总时间复杂度最小，为 $O(n \sqrt{m \log n })$ 。 Code 1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 4e4, MAX_SIZE = 1e3;int n, m, blockSize, blockNum, lastans, a[MAXN + 5], b[MAXN + 5], cnt[MAXN + 5], bel[MAXN + 5];int blockL[MAX_SIZE + 5], blockR[MAX_SIZE + 5], f[MAX_SIZE + 5][MAX_SIZE + 5], num[MAX_SIZE + 5][MAX_SIZE + 5];vector&lt;int&gt; site[MAXN + 5];inline void init() &#123; blockSize = n / sqrt(m * log2(n)); blockNum = n / blockSize + (n % blockSize &gt; 0); sort(b + 1, b + n + 1); int len = unique(b + 1, b + n + 1) - b - 1; for (int i = 1; i &lt;= n; ++i) &#123; a[i] = lower_bound(b + 1, b + len + 1, a[i]) - b;//离散化 site[a[i]].push_back(i);//存下每一个 a[i] 出现的位置 bel[i] = (i - 1) / blockSize + 1; &#125; for (int i = 1; i &lt;= blockNum; ++i) blockL[i] = (i - 1) * blockSize + 1, blockR[i] = i * blockSize; blockR[blockNum] = n; for (int i = 1; i &lt;= blockNum; ++i) &#123; memset(cnt, 0, sizeof (cnt)); int maxn = 0, mode = 0;//maxn 记录众数出现次数，mode 记录最小众数 for (int j = i; j &lt;= blockNum; ++j) &#123; for (int k = blockL[j]; k &lt;= blockR[j]; ++k) &#123; ++cnt[a[k]]; if (cnt[a[k]] &gt; maxn || (cnt[a[k]] == maxn &amp;&amp; a[k] &lt; mode)) &#123; //如果出现次数比 maxn 大 或 出现次数与 maxn 相同但这个数比当前记录的 mode 小 maxn = cnt[a[k]]; mode = a[k];//更新最优值 &#125; &#125; num[i][j] = maxn;//记录第 i 个块到第 j 个块众数的出现次数 f[i][j] = mode;//记录第 i 个块到第 j 个块的最小众数 &#125; &#125;&#125;inline int query(int l, int r) &#123; int posL, posR, mode = 0, maxn = 0; if (bel[l] == bel[r]) &#123;//l,r 在同一个块 for (int i = l; i &lt;= r; ++i) &#123; posL = lower_bound(site[a[i]].begin(), site[a[i]].end(), l) - site[a[i]].begin(); posR = upper_bound(site[a[i]].begin(), site[a[i]].end(), r) - site[a[i]].begin();//二分找到 l,r 的位置 if (posR - posL &gt; maxn || (posR - posL == maxn &amp;&amp; a[i] &lt; mode)) &#123; //判断能否更新答案 maxn = posR - posL; mode = a[i]; &#125; &#125; return b[mode];//mode 是离散化后的值，b[mode] 才是原序列中的值 &#125; maxn = num[bel[l] + 1][bel[r] - 1];//中间完整块众数的出现次数 mode = f[bel[l] + 1][bel[r] - 1];//中间完整块的最小众数 for (int i = l; i &lt;= blockR[bel[l]]; ++i) &#123; posL = lower_bound(site[a[i]].begin(), site[a[i]].end(), l) - site[a[i]].begin(); posR = upper_bound(site[a[i]].begin(), site[a[i]].end(), r) - site[a[i]].begin(); if (posR - posL &gt; maxn || (posR - posL == maxn &amp;&amp; a[i] &lt; mode)) &#123; maxn = posR - posL; mode = a[i]; &#125; &#125;//处理左边多余块的每一个数 for (int i = blockL[bel[r]]; i &lt;= r; ++i) &#123; posL = lower_bound(site[a[i]].begin(), site[a[i]].end(), l) - site[a[i]].begin(); posR = upper_bound(site[a[i]].begin(), site[a[i]].end(), r) - site[a[i]].begin(); if (posR - posL &gt; maxn || (posR - posL == maxn &amp;&amp; a[i] &lt; mode)) &#123; maxn = posR - posL; mode = a[i]; &#125; &#125;//处理右边多余块的每一个数 return b[mode];&#125;int main() &#123; read(n), read(m); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); b[i] = a[i]; &#125; init(); for (int l, r, i = 1; i &lt;= m; ++i) &#123; read(l), read(r); l = (l + lastans - 1) % n + 1, r = (r + lastans - 1) % n + 1;//强制在线 if (l &gt; r) swap(l, r); write(lastans = query(l, r)); putchar('\n'); &#125; return 0;&#125; Solution 2考虑怎么优化上述做法（即减少查询的时间复杂度）。 很容易发现查询时答案在区间 $[l,r]$ 中的出现次数其实是单调不减的。 我们可以预处理出 $pos_i$，表示 $i$ 的位置在 $a_i$ 的 $\rm vector$ 中对应第几个数。假设当前我们已经知道当前的最小众数是 $mode$，且 $mode$ 的出现次数为 $maxn$ 。左边和右边多余的块分类讨论： 对于左边多余块中的某个数 $x$，$x$ 在其对应 $\rm vector$ 中的位置是 $pos_x$ 。我们只需要判断 $x$ 出现的次数是否大于或等于 $maxn$ 即可，因为如果这个数出现的次数小于 $maxn$，就不可能更新答案。如果 $x$ 第 $pos_x + maxn$ 次出现的位置 $\leq r$，就说明区间 $[l,r]$ 中 $x$ 的出现次数为 $maxn + 1$，比当前答案更优。如果 $x$ 第 $pos_x + maxn - 1$ 次出现的位置 $\leq r$，且 $x$ 比答案小，就说明 $x$ 也能更新答案。 右边多余的块同理，只是变成了判断 $x$ 第 $pos_x - maxn$ 次出现的位置是否 $\geq l$ 。 写代码时有很多细节需要注意。比如要先判断 $\rm vector$ 的下标是否小于 $0$ 或者超过 $size$，然后再访问。 很显然这种做法在查询时不需要二分，时间复杂度少一只 $\log$ 。设块的大小为 $S$，则总时间复杂度为 预处理 $O \left( \frac{n^2}{S} \right)$ + 查询 $O(mS)$，根据 均值不等式，可知取 $S = \frac{n}{\sqrt m}$ 时总时间复杂度最小，为 $O(n \sqrt m)$ 。 Code 2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 4e4, MAX_SIZE = 500;int n, m, blockSize, blockNum, lastans, a[MAXN + 5], b[MAXN + 5], cnt[MAXN + 5], bel[MAXN + 5], pos[MAXN + 5];int blockL[MAX_SIZE + 5], blockR[MAX_SIZE + 5], f[MAX_SIZE + 5][MAX_SIZE + 5], num[MAX_SIZE + 5][MAX_SIZE + 5];vector&lt;int&gt; site[MAXN + 5];inline void init() &#123; blockSize = n / sqrt(m); blockNum = n / blockSize + (n % blockSize &gt; 0); sort(b + 1, b + n + 1); int len = unique(b + 1, b + n + 1) - b - 1; for (int i = 1; i &lt;= n; ++i) &#123; a[i] = lower_bound(b + 1, b + len + 1, a[i]) - b;//离散化 pos[i] = site[a[i]].size();//pos[i] 表示 i 的位置在 a[i] 的 vector 中对应第几个数 site[a[i]].push_back(i);//存下每一个 a[i] 出现的位置 bel[i] = (i - 1) / blockSize + 1; &#125; for (int i = 1; i &lt;= blockNum; ++i) blockL[i] = (i - 1) * blockSize + 1, blockR[i] = i * blockSize; blockR[blockNum] = n; for (int i = 1; i &lt;= blockNum; ++i) &#123; memset(cnt, 0, sizeof (cnt)); int maxn = 0, mode = 0; for (int j = i; j &lt;= blockNum; ++j) &#123; for (int k = blockL[j]; k &lt;= blockR[j]; ++k) &#123; ++cnt[a[k]]; if (cnt[a[k]] &gt; maxn || (cnt[a[k]] == maxn &amp;&amp; a[k] &lt; mode)) &#123; maxn = cnt[a[k]]; mode = a[k]; &#125; &#125; num[i][j] = maxn;//记录第 i 个块到第 j 个块众数的出现次数 f[i][j] = mode;//记录第 i 个块到第 j 个块的最小众数 &#125; &#125;//预处理方法与之前相同&#125;inline int query(int l, int r) &#123; int mode = 0, maxn = 0; if (bel[l] == bel[r]) &#123;//l,r 在同个一块 for (int i = l; i &lt;= r; ++i) &#123; if (pos[i] + maxn - 1 &gt;= 0 &amp;&amp; pos[i] + maxn - 1 &lt; (int) site[a[i]].size() &amp;&amp; site[a[i]][pos[i] + maxn - 1] &gt;= l &amp;&amp; site[a[i]][pos[i] + maxn - 1] &lt;= r &amp;&amp; a[i] &lt; mode) mode = a[i];//判断出现次数相同但 a[i] 更小的情况，注意边界 for (; pos[i] + maxn &lt; (int) site[a[i]].size() &amp;&amp; site[a[i]][pos[i] + maxn] &lt;= r; ++maxn) mode = a[i];//判断 a[i] 出现次数比答案更多的情况，maxn 单调不减 &#125; return b[mode];//mode 是离散化后的值，b[mode] 才是原序列中的值 &#125; maxn = num[bel[l] + 1][bel[r] - 1];//中间完整块众数的出现次数 mode = f[bel[l] + 1][bel[r] - 1];//中间完整块的最小众数 for (int i = l; i &lt;= blockR[bel[l]]; ++i) &#123; if (pos[i] + maxn - 1 &gt;= 0 &amp;&amp; pos[i] + maxn - 1 &lt; (int) site[a[i]].size() &amp;&amp; site[a[i]][pos[i] + maxn - 1] &gt;= l &amp;&amp; site[a[i]][pos[i] + maxn - 1] &lt;= r &amp;&amp; a[i] &lt; mode) mode = a[i]; for (; pos[i] + maxn &lt; (int) site[a[i]].size() &amp;&amp; site[a[i]][pos[i] + maxn] &lt;= r; ++maxn)//判断第 pos[i] + maxn 个 a[i] 是否在询问范围内 mode = a[i]; &#125;//处理左边多余块的每一个数 for (int i = blockL[bel[r]]; i &lt;= r; ++i) &#123; if (pos[i] - maxn + 1 &gt;= 0 &amp;&amp; pos[i] - maxn + 1 &lt; (int) site[a[i]].size() &amp;&amp; site[a[i]][pos[i] - maxn + 1] &gt;= l &amp;&amp; site[a[i]][pos[i] - maxn + 1] &lt;= r &amp;&amp; a[i] &lt; mode) mode = a[i]; for (; pos[i] - maxn &gt;= 0 &amp;&amp; site[a[i]][pos[i] - maxn] &gt;= l; ++maxn)//判断第 pos[i] - maxn 个 a[i] 是否在询问范围内 mode = a[i]; &#125;//处理右边多余块的每一个数 return b[mode];&#125;int main() &#123; read(n), read(m); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); b[i] = a[i]; &#125; init(); for (int l, r, i = 1; i &lt;= m; ++i) &#123; read(l), read(r); l = (l + lastans - 1) % n + 1, r = (r + lastans - 1) % n + 1;//强制在线 if (l &gt; r) swap(l, r); write(lastans = query(l, r)); putchar('\n'); &#125; return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>二分</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 2724」「Violet 6」蒲公英]]></title>
    <url>%2Fproblems%2Fbzoj-2724%2F</url>
    <content type="text"><![CDATA[Description给定 $n$ 个数 $a_i$，$m$ 个询问，求区间 $[l,r]$ 中的最小众数，强制在线。 $(1 \leq n \leq 10^4,1 \leq m \leq 2 \times 10^4, 1 \leq a_i \leq 10^9)$ Source[BZOJ]2724 Solution 1考虑 分块 。我们可以预处理出 $f_{i,j}$ 为第 $i$ 个块到第 $j$ 个块的区间最小众数，那样区间 $[l,r]$ 的答案只有可能是 中间所有块的区间最小众数，左边多余块中的数 或 右边多余块中的数（如图）。 很容易在 $O(块的大小 \times n)$ 的时间内预处理出所有的 $f_{i,j}$，但是怎么求出左右多余块中的数在区间 $[l,r]$ 中的出现次数呢？我们可以用 $\rm vector$ 存下每一个 $a_i$ 在序列中的所有出现位置（要先离散化）。在询问时，对于左右多余块中的每一个数 $x$，我们可以二分找到端点 $l,r$ 在 $x$ 对应的 $\rm vector$ 中的位置（可以用 $\rm STL$ 中的 $\rm lower\_bound$ 和 $\rm upper\_bound$），相减即是 $x$ 在区间 $[l,r]$ 中的出现次数。注意如果该数的出现次数与当前答案的出现次数相同，但这个数更小，也要更新答案，因为要求的是最小众数。 设块的大小为 $S$，则总时间复杂度为 预处理 $O \left( \frac{n^2}{S} \right)$ + 查询 $O(mS\log n)$，根据 均值不等式，可知取 $S = \frac{n}{\sqrt{m \log n}}$ 时总时间复杂度最小，为 $O(n \sqrt{m \log n })$ 。 Code 1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 4e4, MAX_SIZE = 1e3;int n, m, blockSize, blockNum, lastans, a[MAXN + 5], b[MAXN + 5], cnt[MAXN + 5], bel[MAXN + 5];int blockL[MAX_SIZE + 5], blockR[MAX_SIZE + 5], f[MAX_SIZE + 5][MAX_SIZE + 5], num[MAX_SIZE + 5][MAX_SIZE + 5];vector&lt;int&gt; site[MAXN + 5];inline void init() &#123; blockSize = n / sqrt(m * log2(n)); blockNum = n / blockSize + (n % blockSize &gt; 0); sort(b + 1, b + n + 1); int len = unique(b + 1, b + n + 1) - b - 1; for (int i = 1; i &lt;= n; ++i) &#123; a[i] = lower_bound(b + 1, b + len + 1, a[i]) - b;//离散化 site[a[i]].push_back(i);//存下每一个 a[i] 出现的位置 bel[i] = (i - 1) / blockSize + 1; &#125; for (int i = 1; i &lt;= blockNum; ++i) blockL[i] = (i - 1) * blockSize + 1, blockR[i] = i * blockSize; blockR[blockNum] = n; for (int i = 1; i &lt;= blockNum; ++i) &#123; memset(cnt, 0, sizeof (cnt)); int maxn = 0, mode = 0;//maxn 记录众数出现次数，mode 记录最小众数 for (int j = i; j &lt;= blockNum; ++j) &#123; for (int k = blockL[j]; k &lt;= blockR[j]; ++k) &#123; ++cnt[a[k]]; if (cnt[a[k]] &gt; maxn || (cnt[a[k]] == maxn &amp;&amp; a[k] &lt; mode)) &#123; //如果出现次数比 maxn 大 或 出现次数与 maxn 相同但这个数比当前记录的 mode 小 maxn = cnt[a[k]]; mode = a[k];//更新最优值 &#125; &#125; num[i][j] = maxn;//记录第 i 个块到第 j 个块众数的出现次数 f[i][j] = mode;//记录第 i 个块到第 j 个块的最小众数 &#125; &#125;&#125;inline int query(int l, int r) &#123; int posL, posR, mode = 0, maxn = 0; if (bel[l] == bel[r]) &#123;//l,r 在同一个块 for (int i = l; i &lt;= r; ++i) &#123; posL = lower_bound(site[a[i]].begin(), site[a[i]].end(), l) - site[a[i]].begin(); posR = upper_bound(site[a[i]].begin(), site[a[i]].end(), r) - site[a[i]].begin();//二分找到 l,r 的位置 if (posR - posL &gt; maxn || (posR - posL == maxn &amp;&amp; a[i] &lt; mode)) &#123; //判断能否更新答案 maxn = posR - posL; mode = a[i]; &#125; &#125; return b[mode];//mode 是离散化后的值，b[mode] 才是原序列中的值 &#125; maxn = num[bel[l] + 1][bel[r] - 1];//中间完整块众数的出现次数 mode = f[bel[l] + 1][bel[r] - 1];//中间完整块的最小众数 for (int i = l; i &lt;= blockR[bel[l]]; ++i) &#123; posL = lower_bound(site[a[i]].begin(), site[a[i]].end(), l) - site[a[i]].begin(); posR = upper_bound(site[a[i]].begin(), site[a[i]].end(), r) - site[a[i]].begin(); if (posR - posL &gt; maxn || (posR - posL == maxn &amp;&amp; a[i] &lt; mode)) &#123; maxn = posR - posL; mode = a[i]; &#125; &#125;//处理左边多余块的每一个数 for (int i = blockL[bel[r]]; i &lt;= r; ++i) &#123; posL = lower_bound(site[a[i]].begin(), site[a[i]].end(), l) - site[a[i]].begin(); posR = upper_bound(site[a[i]].begin(), site[a[i]].end(), r) - site[a[i]].begin(); if (posR - posL &gt; maxn || (posR - posL == maxn &amp;&amp; a[i] &lt; mode)) &#123; maxn = posR - posL; mode = a[i]; &#125; &#125;//处理右边多余块的每一个数 return b[mode];&#125;int main() &#123; read(n), read(m); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); b[i] = a[i]; &#125; init(); for (int l, r, i = 1; i &lt;= m; ++i) &#123; read(l), read(r); l = (l + lastans - 1) % n + 1, r = (r + lastans - 1) % n + 1;//强制在线 if (l &gt; r) swap(l, r); write(lastans = query(l, r)); putchar('\n'); &#125; return 0;&#125; Solution 2考虑怎么优化上述做法（即减少查询的时间复杂度）。 很容易发现查询时答案在区间 $[l,r]$ 中的出现次数其实是单调不减的。 我们可以预处理出 $pos_i$，表示 $i$ 的位置在 $a_i$ 的 $\rm vector$ 中对应第几个数。假设当前我们已经知道当前的最小众数是 $mode$，且 $mode$ 的出现次数为 $maxn$ 。左边和右边多余的块分类讨论： 对于左边多余块中的某个数 $x$，$x$ 在其对应 $\rm vector$ 中的位置是 $pos_x$ 。我们只需要判断 $x$ 出现的次数是否大于或等于 $maxn$ 即可，因为如果这个数出现的次数小于 $maxn$，就不可能更新答案。如果 $x$ 第 $pos_x + maxn$ 次出现的位置 $\leq r$，就说明区间 $[l,r]$ 中 $x$ 的出现次数为 $maxn + 1$，比当前答案更优。如果 $x$ 第 $pos_x + maxn - 1$ 次出现的位置 $\leq r$，且 $x$ 比答案小，就说明 $x$ 也能更新答案。 右边多余的块同理，只是变成了判断 $x$ 第 $pos_x - maxn$ 次出现的位置是否 $\geq l$ 。 写代码时有很多细节需要注意。比如要先判断 $\rm vector$ 的下标是否小于 $0$ 或者超过 $size$，然后再访问。 很显然这种做法在查询时不需要二分，时间复杂度少一只 $\log$ 。设块的大小为 $S$，则总时间复杂度为 预处理 $O \left( \frac{n^2}{S} \right)$ + 查询 $O(mS)$，根据 均值不等式，可知取 $S = \frac{n}{\sqrt m}$ 时总时间复杂度最小，为 $O(n \sqrt m)$ 。 Code 2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 4e4, MAX_SIZE = 500;int n, m, blockSize, blockNum, lastans, a[MAXN + 5], b[MAXN + 5], cnt[MAXN + 5], bel[MAXN + 5], pos[MAXN + 5];int blockL[MAX_SIZE + 5], blockR[MAX_SIZE + 5], f[MAX_SIZE + 5][MAX_SIZE + 5], num[MAX_SIZE + 5][MAX_SIZE + 5];vector&lt;int&gt; site[MAXN + 5];inline void init() &#123; blockSize = n / sqrt(m); blockNum = n / blockSize + (n % blockSize &gt; 0); sort(b + 1, b + n + 1); int len = unique(b + 1, b + n + 1) - b - 1; for (int i = 1; i &lt;= n; ++i) &#123; a[i] = lower_bound(b + 1, b + len + 1, a[i]) - b;//离散化 pos[i] = site[a[i]].size();//pos[i] 表示 i 的位置在 a[i] 的 vector 中对应第几个数 site[a[i]].push_back(i);//存下每一个 a[i] 出现的位置 bel[i] = (i - 1) / blockSize + 1; &#125; for (int i = 1; i &lt;= blockNum; ++i) blockL[i] = (i - 1) * blockSize + 1, blockR[i] = i * blockSize; blockR[blockNum] = n; for (int i = 1; i &lt;= blockNum; ++i) &#123; memset(cnt, 0, sizeof (cnt)); int maxn = 0, mode = 0; for (int j = i; j &lt;= blockNum; ++j) &#123; for (int k = blockL[j]; k &lt;= blockR[j]; ++k) &#123; ++cnt[a[k]]; if (cnt[a[k]] &gt; maxn || (cnt[a[k]] == maxn &amp;&amp; a[k] &lt; mode)) &#123; maxn = cnt[a[k]]; mode = a[k]; &#125; &#125; num[i][j] = maxn;//记录第 i 个块到第 j 个块众数的出现次数 f[i][j] = mode;//记录第 i 个块到第 j 个块的最小众数 &#125; &#125;//预处理方法与之前相同&#125;inline int query(int l, int r) &#123; int mode = 0, maxn = 0; if (bel[l] == bel[r]) &#123;//l,r 在同个一块 for (int i = l; i &lt;= r; ++i) &#123; if (pos[i] + maxn - 1 &gt;= 0 &amp;&amp; pos[i] + maxn - 1 &lt; (int) site[a[i]].size() &amp;&amp; site[a[i]][pos[i] + maxn - 1] &gt;= l &amp;&amp; site[a[i]][pos[i] + maxn - 1] &lt;= r &amp;&amp; a[i] &lt; mode) mode = a[i];//判断出现次数相同但 a[i] 更小的情况，注意边界 for (; pos[i] + maxn &lt; (int) site[a[i]].size() &amp;&amp; site[a[i]][pos[i] + maxn] &lt;= r; ++maxn) mode = a[i];//判断 a[i] 出现次数比答案更多的情况，maxn 单调不减 &#125; return b[mode];//mode 是离散化后的值，b[mode] 才是原序列中的值 &#125; maxn = num[bel[l] + 1][bel[r] - 1];//中间完整块众数的出现次数 mode = f[bel[l] + 1][bel[r] - 1];//中间完整块的最小众数 for (int i = l; i &lt;= blockR[bel[l]]; ++i) &#123; if (pos[i] + maxn - 1 &gt;= 0 &amp;&amp; pos[i] + maxn - 1 &lt; (int) site[a[i]].size() &amp;&amp; site[a[i]][pos[i] + maxn - 1] &gt;= l &amp;&amp; site[a[i]][pos[i] + maxn - 1] &lt;= r &amp;&amp; a[i] &lt; mode) mode = a[i]; for (; pos[i] + maxn &lt; (int) site[a[i]].size() &amp;&amp; site[a[i]][pos[i] + maxn] &lt;= r; ++maxn)//判断第 pos[i] + maxn 个 a[i] 是否在询问范围内 mode = a[i]; &#125;//处理左边多余块的每一个数 for (int i = blockL[bel[r]]; i &lt;= r; ++i) &#123; if (pos[i] - maxn + 1 &gt;= 0 &amp;&amp; pos[i] - maxn + 1 &lt; (int) site[a[i]].size() &amp;&amp; site[a[i]][pos[i] - maxn + 1] &gt;= l &amp;&amp; site[a[i]][pos[i] - maxn + 1] &lt;= r &amp;&amp; a[i] &lt; mode) mode = a[i]; for (; pos[i] - maxn &gt;= 0 &amp;&amp; site[a[i]][pos[i] - maxn] &gt;= l; ++maxn)//判断第 pos[i] - maxn 个 a[i] 是否在询问范围内 mode = a[i]; &#125;//处理右边多余块的每一个数 return b[mode];&#125;int main() &#123; read(n), read(m); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); b[i] = a[i]; &#125; init(); for (int l, r, i = 1; i &lt;= m; ++i) &#123; read(l), read(r); l = (l + lastans - 1) % n + 1, r = (r + lastans - 1) % n + 1;//强制在线 if (l &gt; r) swap(l, r); write(lastans = query(l, r)); putchar('\n'); &#125; return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>二分</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 2453」维护队列]]></title>
    <url>%2Fproblems%2Fbzoj-2453%2F</url>
    <content type="text"><![CDATA[Description给定 $n$ 个数，$m$ 次操作，操作分两种： Q L R：询问区间 $[L,R]$ 中有多少个不同的数； R P Col：把第 $P$ 个数替换为 $Col$ 。 $(1 \leq n,m \leq 10^4$，数的大小均大于等于 $1$ 且不超过 $10^6)$ Source[BZOJ]2453 Solution看到这道题的询问，就很容易想到 莫队 。可是还有修改操作，普通的莫队不支持，怎么办呢？带修莫队 应运而生。 带修莫队，字面意思即是带修改的莫队。它与普通莫队不同的是，多了一个 时间戳，用来记录到当前这个询问时已经进行了多少次修改操作。 我们把询问和修改分别存下来。对于每一个询问，我们不仅要做到左右端点与当前询问一致，还要使修改次数与当前询问相同。如果我们修改得过多，那么应该删去多余的修改，修改过少则反之。 普通莫队写法： 1234for (; l &gt; ql; add(col[--l]));for (; r &lt; qr; add(col[++r]));for (; l &lt; ql; del(col[l++]));for (; r &gt; qr; del(col[r--])); 带修莫队新增的两句话： 12for (; t &lt; qt; upd(++t, i));for (; t &gt; qt; upd(t--, i)); 其中 $qt$ 表示这个询问已修改的次数，$t$ 表示当前已修改的次数，$i$ 表示排序后是第 $i$ 个询问。 upd 操作： 123456789inline void upd(int x, int i) &#123;//在第 i 个询问进行第 x 次修改 if (u[x].pos &gt;= q[i].l &amp;&amp; u[x].pos &lt;= q[i].r) &#123;//修改的位置在询问区间内才会产生影响 del(col[u[x].pos]);//删掉第 pos 位上的数 add(u[x].k);//增加修改完的数 &#125; swap(col[u[x].pos], u[x].k); //如果我们这一次修改把 x 变成了 y，下次如果要改回来就不是把 x 变成 y 了， //而是应当把 y 变成 x，所以我们修改完后我们要把 x 和 y 交换&#125; 至于排序，和普通莫队大致相同。 普通排序： 123if (x.l / blockSize != y.l / blockSize) return x.l &lt; y.l;else if (x.r / blockSize != y.r / blockSize) return x.r &lt; y.r;return x.t &lt; y.t; 若左端点不在同一块，则按左端点排序；若左端点在同一块，右端点不在同一块，则按右端点排序；若都在同一块，则按修改次数排序。 奇偶性排序： 1234if (x.l / blockSize != y.l / blockSize) return x.l &lt; y.l;else if (x.r / blockSize != y.r / blockSize) return ((x.l / blockSize) &amp; 1) ? x.r &lt; y.r : x.r &gt; y.r;return x.t &lt; y.t; 若左端点在同一块，右端点不在同一块，则根据左端点所在块编号的奇偶性对右端点排序。其它与普通排序相同。 在带修莫队中，块的大小（$blockSize$）设 $n^{\frac{2}{3}}$ 比较快。此时的时间复杂度约为 $O(n^{\frac{5}{3}})$，证明有些麻烦，这里暂不给出。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;inline void readChar(char &amp;c) &#123; for (c = getchar(); c != 'Q' &amp;&amp; c != 'R'; c = getchar());&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1e4, MAXM = 1e6;int n, m, cntQ, cntR, res, blockSize, ans[MAXN + 5], col[MAXN + 5], cnt[MAXM + 5];struct Query &#123; int l, r, t, id; //l = 左端点，r = 右端点，t = 已修改次数（时间戳），id = 询问编号 inline friend bool operator&lt;(Query x, Query y) &#123; if (x.l / blockSize != y.l / blockSize) return x.l &lt; y.l; else if (x.r / blockSize != y.r / blockSize) return ((x.l / blockSize) &amp; 1) ? x.r &lt; y.r : x.r &gt; y.r; return x.t &lt; y.t; &#125;&#125; q[MAXN + 5];struct Update &#123; int pos, k;//把第 pos 个数变为 k &#125; u[MAXN + 5];inline void add(int x) &#123; res += !cnt[x]; ++cnt[x];&#125;inline void del(int x) &#123; --cnt[x]; res -= !cnt[x];&#125;inline void upd(int x, int i) &#123;//在第 i 个询问进行第 x 次修改 if (u[x].pos &gt;= q[i].l &amp;&amp; u[x].pos &lt;= q[i].r) &#123;//修改的位置在询问区间内才会产生影响 del(col[u[x].pos]);//删掉第 pos 位上的数 add(u[x].k);//增加修改完的数 &#125; swap(col[u[x].pos], u[x].k); //如果我们这一次修改把 x 变成了 y，下次如果要改回来就不是把 x 变成 y 了， //而是应当把 y 变成 x，所以我们修改完后我们要把 x 和 y 交换&#125;inline void mo() &#123; sort(q + 1, q + cntQ + 1); int l = 1, r = 0, t = 0;//初始左端点为 1，右端点为 0，进行了 0 次修改 for (int i = 1; i &lt;= cntQ; ++i) &#123; int ql = q[i].l, qr = q[i].r, qt = q[i].t; for (; l &gt; ql; add(col[--l])); for (; r &lt; qr; add(col[++r])); for (; l &lt; ql; del(col[l++])); for (; r &gt; qr; del(col[r--])); for (; t &lt; qt; upd(++t, i)); for (; t &gt; qt; upd(t--, i)); ans[q[i].id] = res; &#125;&#125;int main() &#123; read(n), read(m); blockSize = pow(n, 2.0 / 3); for (int i = 1; i &lt;= n; ++i) read(col[i]);//初始颜色 for (int i = 1; i &lt;= m; ++i) &#123; char opt; readChar(opt); if (opt == 'Q') &#123;//记录共 cntQ 个修改 read(q[++cntQ].l), read(q[cntQ].r); q[cntQ].t = cntR, q[cntQ].id = cntQ; &#125; else read(u[++cntR].pos), read(u[cntR].k);//记录共 cntR 个修改 &#125; mo(); for (int i = 1; i &lt;= cntQ; ++i) &#123; write(ans[i]); putchar('\n'); &#125; return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 2120」数颜色]]></title>
    <url>%2Fproblems%2Fbzoj-2120%2F</url>
    <content type="text"><![CDATA[Description给定 $n$ 个数，$m$ 次操作，操作分两种： Q L R：询问区间 $[L,R]$ 中有多少个不同的数； R P Col：把第 $P$ 个数替换为 $Col$ 。 $(1 \leq n,m \leq 10^4$，数的大小均大于等于 $1$ 且不超过 $10^6)$ Source[BZOJ]2120 Solution看到这道题的询问，就很容易想到 莫队 。可是还有修改操作，普通的莫队不支持，怎么办呢？带修莫队 应运而生。 带修莫队，字面意思即是带修改的莫队。它与普通莫队不同的是，多了一个 时间戳，用来记录到当前这个询问时已经进行了多少次修改操作。 我们把询问和修改分别存下来。对于每一个询问，我们不仅要做到左右端点与当前询问一致，还要使修改次数与当前询问相同。如果我们修改得过多，那么应该删去多余的修改，修改过少则反之。 普通莫队写法： 1234for (; l &gt; ql; add(col[--l]));for (; r &lt; qr; add(col[++r]));for (; l &lt; ql; del(col[l++]));for (; r &gt; qr; del(col[r--])); 带修莫队新增的两句话： 12for (; t &lt; qt; upd(++t, i));for (; t &gt; qt; upd(t--, i)); 其中 $qt$ 表示这个询问已修改的次数，$t$ 表示当前已修改的次数，$i$ 表示排序后是第 $i$ 个询问。 upd 操作： 123456789inline void upd(int x, int i) &#123;//在第 i 个询问进行第 x 次修改 if (u[x].pos &gt;= q[i].l &amp;&amp; u[x].pos &lt;= q[i].r) &#123;//修改的位置在询问区间内才会产生影响 del(col[u[x].pos]);//删掉第 pos 位上的数 add(u[x].k);//增加修改完的数 &#125; swap(col[u[x].pos], u[x].k); //如果我们这一次修改把 x 变成了 y，下次如果要改回来就不是把 x 变成 y 了， //而是应当把 y 变成 x，所以我们修改完后我们要把 x 和 y 交换&#125; 至于排序，和普通莫队大致相同。 普通排序： 123if (x.l / blockSize != y.l / blockSize) return x.l &lt; y.l;else if (x.r / blockSize != y.r / blockSize) return x.r &lt; y.r;return x.t &lt; y.t; 若左端点不在同一块，则按左端点排序；若左端点在同一块，右端点不在同一块，则按右端点排序；若都在同一块，则按修改次数排序。 奇偶性排序： 1234if (x.l / blockSize != y.l / blockSize) return x.l &lt; y.l;else if (x.r / blockSize != y.r / blockSize) return ((x.l / blockSize) &amp; 1) ? x.r &lt; y.r : x.r &gt; y.r;return x.t &lt; y.t; 若左端点在同一块，右端点不在同一块，则根据左端点所在块编号的奇偶性对右端点排序。其它与普通排序相同。 在带修莫队中，块的大小（$blockSize$）设 $n^{\frac{2}{3}}$ 比较快。此时的时间复杂度约为 $O(n^{\frac{5}{3}})$，证明有些麻烦，这里暂不给出。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;inline void readChar(char &amp;c) &#123; for (c = getchar(); c != 'Q' &amp;&amp; c != 'R'; c = getchar());&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1e4, MAXM = 1e6;int n, m, cntQ, cntR, res, blockSize, ans[MAXN + 5], col[MAXN + 5], cnt[MAXM + 5];struct Query &#123; int l, r, t, id; //l = 左端点，r = 右端点，t = 已修改次数（时间戳），id = 询问编号 inline friend bool operator&lt;(Query x, Query y) &#123; if (x.l / blockSize != y.l / blockSize) return x.l &lt; y.l; else if (x.r / blockSize != y.r / blockSize) return ((x.l / blockSize) &amp; 1) ? x.r &lt; y.r : x.r &gt; y.r; return x.t &lt; y.t; &#125;&#125; q[MAXN + 5];struct Update &#123; int pos, k;//把第 pos 个数变为 k &#125; u[MAXN + 5];inline void add(int x) &#123; res += !cnt[x]; ++cnt[x];&#125;inline void del(int x) &#123; --cnt[x]; res -= !cnt[x];&#125;inline void upd(int x, int i) &#123;//在第 i 个询问进行第 x 次修改 if (u[x].pos &gt;= q[i].l &amp;&amp; u[x].pos &lt;= q[i].r) &#123;//修改的位置在询问区间内才会产生影响 del(col[u[x].pos]);//删掉第 pos 位上的数 add(u[x].k);//增加修改完的数 &#125; swap(col[u[x].pos], u[x].k); //如果我们这一次修改把 x 变成了 y，下次如果要改回来就不是把 x 变成 y 了， //而是应当把 y 变成 x，所以我们修改完后我们要把 x 和 y 交换&#125;inline void mo() &#123; sort(q + 1, q + cntQ + 1); int l = 1, r = 0, t = 0;//初始左端点为 1，右端点为 0，进行了 0 次修改 for (int i = 1; i &lt;= cntQ; ++i) &#123; int ql = q[i].l, qr = q[i].r, qt = q[i].t; for (; l &gt; ql; add(col[--l])); for (; r &lt; qr; add(col[++r])); for (; l &lt; ql; del(col[l++])); for (; r &gt; qr; del(col[r--])); for (; t &lt; qt; upd(++t, i)); for (; t &gt; qt; upd(t--, i)); ans[q[i].id] = res; &#125;&#125;int main() &#123; read(n), read(m); blockSize = pow(n, 2.0 / 3); for (int i = 1; i &lt;= n; ++i) read(col[i]);//初始颜色 for (int i = 1; i &lt;= m; ++i) &#123; char opt; readChar(opt); if (opt == 'Q') &#123;//记录共 cntQ 个修改 read(q[++cntQ].l), read(q[cntQ].r); q[cntQ].t = cntR, q[cntQ].id = cntQ; &#125; else read(u[++cntR].pos), read(u[cntR].k);//记录共 cntR 个修改 &#125; mo(); for (int i = 1; i &lt;= cntQ; ++i) &#123; write(ans[i]); putchar('\n'); &#125; return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P1903」「国家集训队」数颜色/维护队列]]></title>
    <url>%2Fproblems%2Fluogu-p1903%2F</url>
    <content type="text"><![CDATA[Description给定 $n$ 个数，$m$ 次操作，操作分两种： Q L R：询问区间 $[L,R]$ 中有多少个不同的数； R P Col：把第 $P$ 个数替换为 $Col$ 。 $(1 \leq n,m \leq 5 \times 10^4$，数的大小均大于等于 $1$ 且不超过 $10^6)$ Source[Luogu]P1903 Solution看到这道题的询问，就很容易想到 莫队 。可是还有修改操作，普通的莫队不支持，怎么办呢？带修莫队 应运而生。 带修莫队，字面意思即是带修改的莫队。它与普通莫队不同的是，多了一个 时间戳，用来记录到当前这个询问时已经进行了多少次修改操作。 我们把询问和修改分别存下来。对于每一个询问，我们不仅要做到左右端点与当前询问一致，还要使修改次数与当前询问相同。如果我们修改得过多，那么应该删去多余的修改，修改过少则反之。 普通莫队写法： 1234for (; l &gt; ql; add(col[--l]));for (; r &lt; qr; add(col[++r]));for (; l &lt; ql; del(col[l++]));for (; r &gt; qr; del(col[r--])); 带修莫队新增的两句话： 12for (; t &lt; qt; upd(++t, i));for (; t &gt; qt; upd(t--, i)); 其中 $qt$ 表示这个询问已修改的次数，$t$ 表示当前已修改的次数，$i$ 表示排序后是第 $i$ 个询问。 upd 操作： 123456789inline void upd(int x, int i) &#123;//在第 i 个询问进行第 x 次修改 if (u[x].pos &gt;= q[i].l &amp;&amp; u[x].pos &lt;= q[i].r) &#123;//修改的位置在询问区间内才会产生影响 del(col[u[x].pos]);//删掉第 pos 位上的数 add(u[x].k);//增加修改完的数 &#125; swap(col[u[x].pos], u[x].k); //如果我们这一次修改把 x 变成了 y，下次如果要改回来就不是把 x 变成 y 了， //而是应当把 y 变成 x，所以我们修改完后我们要把 x 和 y 交换&#125; 至于排序，和普通莫队大致相同。 普通排序： 123if (x.l / blockSize != y.l / blockSize) return x.l &lt; y.l;else if (x.r / blockSize != y.r / blockSize) return x.r &lt; y.r;return x.t &lt; y.t; 若左端点不在同一块，则按左端点排序；若左端点在同一块，右端点不在同一块，则按右端点排序；若都在同一块，则按修改次数排序。 奇偶性排序： 1234if (x.l / blockSize != y.l / blockSize) return x.l &lt; y.l;else if (x.r / blockSize != y.r / blockSize) return ((x.l / blockSize) &amp; 1) ? x.r &lt; y.r : x.r &gt; y.r;return x.t &lt; y.t; 若左端点在同一块，右端点不在同一块，则根据左端点所在块编号的奇偶性对右端点排序。其它与普通排序相同。 在带修莫队中，块的大小（$blockSize$）设 $n^{\frac{2}{3}}$ 比较快。此时的时间复杂度约为 $O(n^{\frac{5}{3}})$，证明有些麻烦，这里暂不给出。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;inline void readChar(char &amp;c) &#123; for (c = getchar(); c != 'Q' &amp;&amp; c != 'R'; c = getchar());&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 5e4, MAXM = 1e6;int n, m, cntQ, cntR, res, blockSize, ans[MAXN + 5], col[MAXN + 5], cnt[MAXM + 5];struct Query &#123; int l, r, t, id; //l = 左端点，r = 右端点，t = 已修改次数（时间戳），id = 询问编号 inline friend bool operator&lt;(Query x, Query y) &#123; if (x.l / blockSize != y.l / blockSize) return x.l &lt; y.l; else if (x.r / blockSize != y.r / blockSize) return ((x.l / blockSize) &amp; 1) ? x.r &lt; y.r : x.r &gt; y.r; return x.t &lt; y.t; &#125;&#125; q[MAXN + 5];struct Update &#123; int pos, k;//把第 pos 个数变为 k &#125; u[MAXN + 5];inline void add(int x) &#123; res += !cnt[x]; ++cnt[x];&#125;inline void del(int x) &#123; --cnt[x]; res -= !cnt[x];&#125;inline void upd(int x, int i) &#123;//在第 i 个询问进行第 x 次修改 if (u[x].pos &gt;= q[i].l &amp;&amp; u[x].pos &lt;= q[i].r) &#123;//修改的位置在询问区间内才会产生影响 del(col[u[x].pos]);//删掉第 pos 位上的数 add(u[x].k);//增加修改完的数 &#125; swap(col[u[x].pos], u[x].k); //如果我们这一次修改把 x 变成了 y，下次如果要改回来就不是把 x 变成 y 了， //而是应当把 y 变成 x，所以我们修改完后我们要把 x 和 y 交换&#125;inline void mo() &#123; sort(q + 1, q + cntQ + 1); int l = 1, r = 0, t = 0;//初始左端点为 1，右端点为 0，进行了 0 次修改 for (int i = 1; i &lt;= cntQ; ++i) &#123; int ql = q[i].l, qr = q[i].r, qt = q[i].t; for (; l &gt; ql; add(col[--l])); for (; r &lt; qr; add(col[++r])); for (; l &lt; ql; del(col[l++])); for (; r &gt; qr; del(col[r--])); for (; t &lt; qt; upd(++t, i)); for (; t &gt; qt; upd(t--, i)); ans[q[i].id] = res; &#125;&#125;int main() &#123; read(n), read(m); blockSize = pow(n, 2.0 / 3); for (int i = 1; i &lt;= n; ++i) read(col[i]);//初始颜色 for (int i = 1; i &lt;= m; ++i) &#123; char opt; readChar(opt); if (opt == 'Q') &#123;//记录共 cntQ 个修改 read(q[++cntQ].l), read(q[cntQ].r); q[cntQ].t = cntR, q[cntQ].id = cntQ; &#125; else read(u[++cntR].pos), read(u[cntR].k);//记录共 cntR 个修改 &#125; mo(); for (int i = 1; i &lt;= cntQ; ++i) &#123; write(ans[i]); putchar('\n'); &#125; return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>集训队</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「LOJ 10056」The XOR-longest Path]]></title>
    <url>%2Fproblems%2Floj-10056%2F</url>
    <content type="text"><![CDATA[Description给定一棵 $n\ (1 \leq n \leq 10^5)$ 个点的带权树，求树上最长的异或和路径。$(0 \leq 边权 &lt; 2^{31})$ Source[LOJ]10056 Solution$a,b$ 的树上路径异或和其实就是 $a$ 到根的路径异或和 与 $b$ 到根的路径异或和 的异或值。原因是：根据异或运算的性质 $x \oplus x = 0$ 可知，两个点到根重复的路径会互相抵消为 $0$，对答案不影响。 所以我们可以先用 搜索 求出每个点到根的路径异或和，然后把这些值插入到 Trie 中，从中选出两点使其异或和最大，这就和另外一题 [LOJ]10050 一样了，不会的话自行阅读，这里不再赘述过程。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1e5, MAXM = 2e5;int n, tot, ans, head[MAXN + 5], val[MAXN + 5];struct Edge &#123; int next, to, dis;&#125; e[MAXM + 5];struct Trie &#123; int tot, ch[MAXN * 31 + 5][2]; inline void insert(int x) &#123; int u = 1; for (int i = 30; ~i; --i) &#123; bool v = x &amp; (1 &lt;&lt; i);//x 二进制下第 i 位的值 if (!ch[u][v]) ch[u][v] = ++tot;//新建节点 u = ch[u][v]; &#125; &#125; inline int find(int x) &#123; int u = 1, res = 0; for (int i = 30; ~i; --i) &#123; bool v = x &amp; (1 &lt;&lt; i);//x 二进制下第 i 位的值 if (!ch[u][v ^ 1]) u = ch[u][v];//如果没有相反的路，则沿相同的路走 else &#123; res += 1 &lt;&lt; i;//走相反的路 u = ch[u][v ^ 1];//这一位为 1，累加答案 &#125; &#125; return res; &#125;&#125; tr;inline void addEdge(int u, int v, int w) &#123; e[++tot] = (Edge) &#123; head[u], v, w &#125;; head[u] = tot;&#125;void dfs(int u, int fa) &#123; for (int v, w, i = head[u]; v = e[i].to, w = e[i].dis, i; i = e[i].next) &#123; if (v == fa) continue; val[v] = val[u] ^ w;//预处理出每个节点到根的路径异或和 dfs(v, u); &#125;&#125;int main() &#123; read(n); for (int u, v, w, i = 1; i &lt; n; ++i) &#123; read(u), read(v), read(w); addEdge(u, v, w), addEdge(v, u, w);//连无向边 &#125; dfs(1, 0); tr.tot = 1; for (int i = 1; i &lt;= n; ++i) &#123; ans = max(ans, tr.find(val[i]));//查找 x 与 Trie 中已有数的异或最大值 tr.insert(val[i]);//把 x 插入到 Trie 中 &#125; write(ans); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>Trie</tag>
        <tag>LibreOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P4551」最长异或路径]]></title>
    <url>%2Fproblems%2Fluogu-p4551%2F</url>
    <content type="text"><![CDATA[Description给定一棵 $n\ (1 \leq n \leq 10^5)$ 个点的带权树，求树上最长的异或和路径。$(0 \leq 边权 &lt; 2^{31})$ Source[Luogu]P4551 Solution$a,b$ 的树上路径异或和其实就是 $a$ 到根的路径异或和 与 $b$ 到根的路径异或和 的异或值。原因是：根据异或运算的性质 $x \oplus x = 0$ 可知，两个点到根重复的路径会互相抵消为 $0$，对答案不影响。 所以我们可以先用 搜索 求出每个点到根的路径异或和，然后把这些值插入到 Trie 中，从中选出两点使其异或和最大，这就和另外一题 [LOJ]10050 一样了，不会的话自行阅读，这里不再赘述过程。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1e5, MAXM = 2e5;int n, tot, ans, head[MAXN + 5], val[MAXN + 5];struct Edge &#123; int next, to, dis;&#125; e[MAXM + 5];struct Trie &#123; int tot, ch[MAXN * 31 + 5][2]; inline void insert(int x) &#123; int u = 1; for (int i = 30; ~i; --i) &#123; bool v = x &amp; (1 &lt;&lt; i);//x 二进制下第 i 位的值 if (!ch[u][v]) ch[u][v] = ++tot;//新建节点 u = ch[u][v]; &#125; &#125; inline int find(int x) &#123; int u = 1, res = 0; for (int i = 30; ~i; --i) &#123; bool v = x &amp; (1 &lt;&lt; i);//x 二进制下第 i 位的值 if (!ch[u][v ^ 1]) u = ch[u][v];//如果没有相反的路，则沿相同的路走 else &#123; res += 1 &lt;&lt; i;//走相反的路 u = ch[u][v ^ 1];//这一位为 1，累加答案 &#125; &#125; return res; &#125;&#125; tr;inline void addEdge(int u, int v, int w) &#123; e[++tot] = (Edge) &#123; head[u], v, w &#125;; head[u] = tot;&#125;void dfs(int u, int fa) &#123; for (int v, w, i = head[u]; v = e[i].to, w = e[i].dis, i; i = e[i].next) &#123; if (v == fa) continue; val[v] = val[u] ^ w;//预处理出每个节点到根的路径异或和 dfs(v, u); &#125;&#125;int main() &#123; read(n); for (int u, v, w, i = 1; i &lt; n; ++i) &#123; read(u), read(v), read(w); addEdge(u, v, w), addEdge(v, u, w);//连无向边 &#125; dfs(1, 0); tr.tot = 1; for (int i = 1; i &lt;= n; ++i) &#123; ans = max(ans, tr.find(val[i]));//查找 x 与 Trie 中已有数的异或最大值 tr.insert(val[i]);//把 x 插入到 Trie 中 &#125; write(ans); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>搜索</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「LOJ 10050」The XOR Largest Pair]]></title>
    <url>%2Fproblems%2Floj-10050%2F</url>
    <content type="text"><![CDATA[Description在给定的 $n$ 个整数 $a_1,a_2,\ldots,a_n$ 中选出两个进行异或运算，得到的结果最大是多少？$(1 \leq n \leq 10^5,0 \leq a_i \leq 2^{31})$ Source[LOJ]10050 Solution转化问题：对于每个 $i\ (1 \leq i \leq n)$，我们需要找到一个 $j\ (1 \leq j &lt; i)$，使得 $a_i \oplus a_j$ 的值最大（$\oplus $ 表示异或）。 我们可以建一棵 0-1 Trie 。 把每个数二进制分解，从高位到低位依次插入到 Trie 中（注意这道题中的二进制位不超过 $30$，高位补 $0$ ）。 在插入第 $i$ 个数之前，我们要先找到前 $i - 1$ 个数与 $a_i$ 异或的最大值来更新答案。 怎么找呢？我们从最高位开始，如果 $a_i$ 二进制下某一位是 $1$，就选择走 Trie 对应深度的 $0$ 的子树，反之则走 $1$ 的子树。这是根据异或运算的性质来使异或后的值这一位为 $1$，最大化答案。若不能取相反，则只能取相同，异或后这一位将为 $0$ 。 举例分析。假如我们已经在 Trie 中插入了 $5$ 个数：$1,2,4,5,7$，转化为二进制分别对应 $001,010,100,101,111$ 。（如图） 若我们要求 $3(011)$ 与这 $5$ 个数的最大异或值，则考虑走 $1-0-0$ 这一条路线，因为这样能使每一位都是 $1$ 。 若我们要求 $4(100)$ 与这 $5$ 个数的最大异或值，则考虑走 $0-1-0$ 这一条路线，本来选 $0-1-1$ 这条路线能得到异或最大值，但是在第 $2$ 个 $1$ 的位置时发现没有 $1$ 这条路，所以只能走 $0$ 。 对于每一个数我们都需要 $O(\log n)$ 的时间计算它与前面的数的最大异或值，所以时间复杂度为 $O(n \log n)$，空间复杂度为 $O(n \log n)$ 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1e5;int n, ans;struct Trie &#123; int tot, ch[MAXN * 30 + 5][2]; inline void insert(int x) &#123; int u = 1; for (int i = 30; ~i; --i) &#123; bool v = x &amp; (1 &lt;&lt; i);//x 二进制下第 i 位的值 if (!ch[u][v]) ch[u][v] = ++tot;//新建节点 u = ch[u][v]; &#125; &#125; inline int find(int x) &#123; int u = 1, res = 0; for (int i = 30; ~i; --i) &#123; bool v = x &amp; (1 &lt;&lt; i);//x 二进制下第 i 位的值 if (!ch[u][v ^ 1]) u = ch[u][v];//如果没有相反的路，则沿相同的路走 else &#123; u = ch[u][v ^ 1];//走相反的路 res += 1 &lt;&lt; i;//这一位为 1，累加答案 &#125; &#125; return res; &#125;&#125; tr;int main() &#123; read(n); tr.tot = 1; for (int x, i = 1; i &lt;= n; ++i) &#123; read(x); ans = max(ans, tr.find(x));//查找 x 与 Trie 中已有数的异或最大值 tr.insert(x);//把 x 插入到 Trie 中 &#125; write(ans); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Trie</tag>
        <tag>LibreOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 1164I」Maximum Value]]></title>
    <url>%2Fproblems%2Fcodeforces-1164i%2F</url>
    <content type="text"><![CDATA[Description实数 $a,b$ 满足 $\left(a + b - 1\right) ^2 = ab + 1$，求 $a^2 + b^2$ 的最大值。 Source[Codeforces]1164I Solution提交答案 题。 化简式子，使等式左边变为要求的值，等式右边存在完全平方项。 \left(a + b - 1\right) ^2 = ab + 1\\ a^2+b^2+2ab+1-2a-2b=ab+1\\ a^2+b^2+ab-2a-2b=0\\ 2a^2+2b^2+2ab-4a-4b=0\\ \begin{aligned} a^2+b^2 &= -a^2 - b^2 - 2ab + 4a + 4b\\ &= -\left( a + b \right)^2 + 4a + 4b\\ &= 4 - \left[ \left( a + b \right)^2 - 4\left( a + b \right) + 4\right]\\ &= 4 - \left( a + b - 2\right)^2 \end{aligned}\\ \begin{aligned} &\because \left( a + b - 2 \right)^2 \geq 0\\ &\therefore a^2 + b^2 \leq 4 \end{aligned}即 $a^2 + b^2$ 的最大值为 $4$ 。 Answer14]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>数论数学</tag>
        <tag>Codeforces</tag>
        <tag>提交答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 1164O」Greatest Prime Divisor]]></title>
    <url>%2Fproblems%2Fcodeforces-1164o%2F</url>
    <content type="text"><![CDATA[Description设 $S = 1 \cdot 1! + 2 \cdot 2! + 3\cdot 3! + \cdots + 100 \cdot 100!$，求 $S + 1$ 最大的质因子。 Source[Codeforces]1164O Solution提交答案 题。 化简 $S$ 。 \begin{aligned} S + 1 &= 1 + 1 \cdot 1! + 2 \cdot 2! + 3\cdot 3! + \cdots + 100 \cdot 100!\\[1ex] &= 2! + 2 \cdot 2! + 3\cdot 3! + \cdots + 100 \cdot 100!\\[1ex] &= 3! + 3\cdot 3! + \cdots + 100 \cdot 100!\\[1ex] &= 4! + \cdots + 100 \cdot 100!\\[1ex] &= \cdots \cdots\\[1ex] &= 100! + 100 \cdot 100!\\[1ex] &= 101! \end{aligned}显然 $101!$ 中最大的质因子为 $101$ 。 Answer1101]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>数论数学</tag>
        <tag>Codeforces</tag>
        <tag>提交答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 1164B」Triangle Area]]></title>
    <url>%2Fproblems%2Fcodeforces-1164b%2F</url>
    <content type="text"><![CDATA[Description已知 $S_{\bigtriangleup ABC} = 16$，$M,N,P$ 分别在边 $AB,BC,CA$ 上，且 $\frac{AM}{MB} = \frac{BN}{NC} = \frac{CP}{PA} = \frac{1}{3}$，求 $S_{\bigtriangleup MNP}$ 。 Source[Codeforces]1164B Solution提交答案 题。 先画出图： 连结 $CM$ 。 \begin{aligned} \because &\frac{AM}{MB} = \frac{1}{3}\\[2ex] \therefore &\frac{MB}{AB} = \frac{S_{\bigtriangleup MBC}}{S_{\bigtriangleup ABC}} = \frac{3}{4}\\[2ex] &S_{\bigtriangleup MBC} = 16 \times \frac{3}{4} = 12\\[2ex] \because &\frac{BN}{NC} = \frac{1}{3}\\[2ex] \therefore &\frac{BN}{BC} = \frac{S_{\bigtriangleup MBN}}{S_{\bigtriangleup MBC}} = \frac{1}{4}\\[2ex] &S_{\bigtriangleup MBN} = 12 \times \frac{1}{4} = 3\\[2ex] 同理可以求出，&S_{\bigtriangleup AMP} = S_{\bigtriangleup PNC} = 3\\[2ex] \therefore &S_{\bigtriangleup MNP} = S_{\bigtriangleup ABC} - S_{\bigtriangleup MBN} - S_{\bigtriangleup AMP} - S_{\bigtriangleup PNC} = 16 - 3 \times 3 = 7 \end{aligned}Answer17]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>数论数学</tag>
        <tag>Codeforces</tag>
        <tag>提交答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 3012」「USACO2012 Dec」First!]]></title>
    <url>%2Fproblems%2Fbzoj-3012%2F</url>
    <content type="text"><![CDATA[Description给定 $n\ (1 \leq n \leq 3 \times 10^4)$ 个总长不超过 $m\ (1 \leq m \leq 3 \times 10^5)$ 的互不相同的字符串，现在你可以任意指定字符之间的大小关系。问有多少个串可能成为字典序最小的串，并输出这些串。 Source[BZOJ]3012 Solution看到与字典序有关的问题，很容易想到建一棵 Trie(字典树) 。 对于每一个字符串，我们可以设它的字典序是所有字符串中最小的。 也就是说，这个字符串的第 $i$ 个字母 在 Trie 的第 $i$ 层（根节点算第 $0$ 层）的所有字母中 字典序最小。 设这个字符串的第 $i$ 个字母为 $u$，我们可以连单向边 $u \to v$，表示我们指定了 $u$ 的字典序比 $v$ 小，其中 $v$ 是第 $i$ 层的其它字母。若这个字符串是其它某个字符串的前缀，则这个字符串不可能成为字典序最小的串，比如说 $abba$ 的字典序一定比 $ab$ 大。当 $26$ 个字母间的关系形成环时，也一定不能成为字典序最小的串。 怎么判断是否形成环呢？可以用 $\rm tarjan$ 或者 拓扑排序 。 这里我采用了 拓扑排序 。我们从入度为 $0$ 的点开始，不断删去与它相连的边，并修改其它点的入度，将新的入度为 $0$ 的点加入队列。若队列已空，但还存在入度不为 $0$ 的点，则说明图存在环，反之则有解。 时间复杂度为 $O(26m)$ 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 3e4, MAXM = 3e5;int n, ans;string s[MAXN + 5];bool ok[MAXN + 5];struct Trie &#123; int tot, in[26], e[26][26], ch[MAXM + 5][26]; bool ed[MAXM + 5]; queue&lt;int&gt; q; inline void insert(string x) &#123; int u = 1, len = x.size(); for (int i = 0; i &lt; len; ++i) &#123; int v = x[i] - 'a'; if (!ch[u][v]) ch[u][v] = ++tot; u = ch[u][v]; &#125; ed[u] = 1; &#125;//插入 inline void topoSort() &#123; for (; !q.empty(); q.pop()); for (int i = 0; i &lt; 26; ++i) if (!in[i]) q.push(i); for (; !q.empty(); ) &#123; int u = q.front(); q.pop(); for (int v = 0; v &lt; 26; ++v) if (e[u][v]) &#123; --in[v]; if (!in[v]) q.push(v); &#125; &#125; &#125;//拓扑排序 inline bool find(string x) &#123; int u = 1, len = x.size(); memset(e, 0, sizeof (e)); memset(in, 0, sizeof (in)); for (int i = 0; i &lt; len; ++i) &#123; if (ed[u]) return 0;//是其它字符串的前缀，无解 int v = x[i] - 'a'; for (int j = 0; j &lt; 26; ++j) if (v != j &amp;&amp; ch[u][j] &amp;&amp; !e[v][j]) &#123; e[v][j] = 1;//与同一层其它字母连边 ++in[j];//统计入度 &#125; u = ch[u][v]; &#125; topoSort(); for (int i = 0; i &lt; 26; ++i) if (in[i]) return 0;//存在环，无解 return 1; &#125;//检验字符串 &#125; tr;int main() &#123; read(n); tr.tot = 1; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; s[i]; tr.insert(s[i]);//插入到 Trie 中 &#125; for (int i = 1; i &lt;= n; ++i) if (tr.find(s[i])) &#123; ++ans;//统计个数 ok[i] = 1;//标记合法字符串 &#125; write(ans); putchar('\n'); for (int i = 1; i &lt;= n; ++i) if (ok[i]) cout &lt;&lt; s[i] &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>USACO</tag>
        <tag>Trie</tag>
        <tag>拓扑排序</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P3065」「USACO12DEC」第一!First!]]></title>
    <url>%2Fproblems%2Fluogu-p3065%2F</url>
    <content type="text"><![CDATA[Description给定 $n\ (1 \leq n \leq 3 \times 10^4)$ 个总长不超过 $m\ (1 \leq m \leq 3 \times 10^5)$ 的互不相同的字符串，现在你可以任意指定字符之间的大小关系。问有多少个串可能成为字典序最小的串，并输出这些串。 Source[Luogu]P3065 Solution看到与字典序有关的问题，很容易想到建一棵 Trie(字典树) 。 对于每一个字符串，我们可以设它的字典序是所有字符串中最小的。 也就是说，这个字符串的第 $i$ 个字母 在 Trie 的第 $i$ 层（根节点算第 $0$ 层）的所有字母中 字典序最小。 设这个字符串的第 $i$ 个字母为 $u$，我们可以连单向边 $u \to v$，表示我们指定了 $u$ 的字典序比 $v$ 小，其中 $v$ 是第 $i$ 层的其它字母。若这个字符串是其它某个字符串的前缀，则这个字符串不可能成为字典序最小的串，比如说 $abba$ 的字典序一定比 $ab$ 大。当 $26$ 个字母间的关系形成环时，也一定不能成为字典序最小的串。 怎么判断是否形成环呢？可以用 $\rm tarjan$ 或者 拓扑排序 。 这里我采用了 拓扑排序 。我们从入度为 $0$ 的点开始，不断删去与它相连的边，并修改其它点的入度，将新的入度为 $0$ 的点加入队列。若队列已空，但还存在入度不为 $0$ 的点，则说明图存在环，反之则有解。 时间复杂度为 $O(26m)$ 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 3e4, MAXM = 3e5;int n, ans;string s[MAXN + 5];bool ok[MAXN + 5];struct Trie &#123; int tot, in[26], e[26][26], ch[MAXM + 5][26]; bool ed[MAXM + 5]; queue&lt;int&gt; q; inline void insert(string x) &#123; int u = 1, len = x.size(); for (int i = 0; i &lt; len; ++i) &#123; int v = x[i] - 'a'; if (!ch[u][v]) ch[u][v] = ++tot; u = ch[u][v]; &#125; ed[u] = 1; &#125;//插入 inline void topoSort() &#123; for (; !q.empty(); q.pop()); for (int i = 0; i &lt; 26; ++i) if (!in[i]) q.push(i); for (; !q.empty(); ) &#123; int u = q.front(); q.pop(); for (int v = 0; v &lt; 26; ++v) if (e[u][v]) &#123; --in[v]; if (!in[v]) q.push(v); &#125; &#125; &#125;//拓扑排序 inline bool find(string x) &#123; int u = 1, len = x.size(); memset(e, 0, sizeof (e)); memset(in, 0, sizeof (in)); for (int i = 0; i &lt; len; ++i) &#123; if (ed[u]) return 0;//是其它字符串的前缀，无解 int v = x[i] - 'a'; for (int j = 0; j &lt; 26; ++j) if (v != j &amp;&amp; ch[u][j] &amp;&amp; !e[v][j]) &#123; e[v][j] = 1;//与同一层其它字母连边 ++in[j];//统计入度 &#125; u = ch[u][v]; &#125; topoSort(); for (int i = 0; i &lt; 26; ++i) if (in[i]) return 0;//存在环，无解 return 1; &#125;//检验字符串 &#125; tr;int main() &#123; read(n); tr.tot = 1; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; s[i]; tr.insert(s[i]);//插入到 Trie 中 &#125; for (int i = 1; i &lt;= n; ++i) if (tr.find(s[i])) &#123; ++ans;//统计个数 ok[i] = 1;//标记合法字符串 &#125; write(ans); putchar('\n'); for (int i = 1; i &lt;= n; ++i) if (ok[i]) cout &lt;&lt; s[i] &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>USACO</tag>
        <tag>Trie</tag>
        <tag>拓扑排序</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P5343」「XR-1」分块]]></title>
    <url>%2Fproblems%2Fluogu-p5343%2F</url>
    <content type="text"><![CDATA[Description给定一个长度为 $n\ (1 \leq n \leq 10^{18})$ 的序列和 $2$ 个 可重 集合：$PR$ 和 $NF$ 。现在要把它分成若干块，块的大小有限制，允许的块长为 $PR \cap NF$。求有多少种不同的分块方案，答案对 $10^9 + 7$ 取模。（设最大块长为 $x$，$1 \leq |PR|,|NF|,x \leq 100$）。 Source[Luogu]P5343 Solution$60 \rm pts$： 考虑 动态规划 。 先预处理出所有可能的块长 $a_1 \sim a_m$（注意要去重）。 用 $f_i$ 表示长度为 $i$ 的序列的分块方案数。 初始 $f_0 = 1$ 。（长度为 $0$ 的序列一定有 $1$ 种分块方案） 状态转移方程（考虑分出来最后一块的块长为 $a_j$）： \large{ f_i = \sum\limits_{j = 1}^m f_{i - a_j} }直接转移是 $O(n)$ 的。 $100\rm pts$： 发现块长最大只有 $100$（$\max\limits_{i = 1}^m \{a_i\} \leq 100$），所以考虑用 矩阵乘法 优化上述 DP 。 若矩阵的大小为 $size \times size$，则有 $size = \max\limits_{i = 1}^m \{a_i\}$（因为 $f_i$ 不可能由 $f_{i - 100}$ 之前的转移过来）。 先构造初始矩阵。根据 $f_0 = 1$，DP 预处理出 $f_1 \sim f_{size - 1}$，然后才能转移。 \large { \begin{bmatrix} f_{size - 1}\\[1ex] f_{size-2}\\[1ex] \cdots\\[1ex] f_{1}\\[1ex] f_{0}\\[1ex] \end{bmatrix} }接下来构造转移矩阵。首先根据 $f_i = \sum\limits_{j = 1}^m f_{i - a_j}$ 得知，矩阵第一行中，第 $a_i$ 个数为 $1$，其余为 $0$ 。剩下的 $f_{i-1} \sim f_{i - size + 1}$ 都可以在上一个矩阵中找到，所以对应的标为 $1$，其它为 $0$ 。 \large{ \begin{bmatrix} \\[1ex] 1 & 0 & \cdots & \cdots & \cdots & 0\\[1ex] 0 & 1 & 0 & \cdots & \cdots & 0\\[1ex] 0 & \cdots & 0 & 1 & 0 & 0\\[1ex] 0 & \cdots & \cdots & 0 & 1 & 0\\[1ex] \end{bmatrix} \times\begin{bmatrix} f_{i-1}\\[1ex] f_{i-2}\\[1ex] \cdots\\[1ex] f_{i-size + 1}\\[1ex] f_{i-size}\\[1ex] \end{bmatrix}=\begin{bmatrix} f_i\\[1ex] f_{i-1}\\[1ex] \cdots\\[1ex] f_{i-size + 2}\\[1ex] f_{i-size + 1}\\[1ex] \end{bmatrix} }最后是答案矩阵。 \large{ \begin{bmatrix} \\[1ex] 1 & 0 & \cdots & \cdots & \cdots & 0\\[1ex] 0 & 1 & 0 & \cdots & \cdots & 0\\[1ex] 0 & \cdots & 0 & 1 & 0 & 0\\[1ex] 0 & \cdots & \cdots & 0 & 1 & 0\\[1ex] \end{bmatrix}^{n-size + 1} \times\begin{bmatrix} f_{size - 1}\\[1ex] f_{size-2}\\[1ex] \cdots\\[1ex] f_{1}\\[1ex] f_{0}\\[1ex] \end{bmatrix}=\begin{bmatrix} f_n\\[1ex] f_{n-1}\\[1ex] \cdots\\[1ex] f_{n-size + 2}\\[1ex] f_{n-size + 1}\\[1ex] \end{bmatrix} }答案矩阵的第 $1$ 行第 $1$ 列即是最终答案。时间复杂度为 $O(size^3\log n)$ 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 100;const int MOD = 1e9 + 7;LL n;int pr, nf, m, size, f[MAXN + 5];bool a[MAXN + 5], b[MAXN + 5];struct Matrix &#123; int mat[MAXN + 5][MAXN + 5]; inline void clear() &#123; memset(mat, 0, sizeof (mat)); &#125; inline Matrix friend operator*(Matrix a, Matrix b) &#123; Matrix c; c.clear(); for (int i = 1; i &lt;= size; ++i) for (int j = 1; j &lt;= size; ++j) for (int k = 1; k &lt;= size; ++k) c.mat[i][j] = (c.mat[i][j] + (LL) a.mat[i][k] * b.mat[k][j]) % MOD; return c; &#125;//矩阵乘法 &#125; ans, base;inline Matrix quickPow(Matrix x, LL p) &#123; Matrix res; res.clear(); for (int i = 1; i &lt;= size; ++i) res.mat[i][i] = 1; for (; p; p &gt;&gt;= 1, x = x * x) if (p &amp; 1) res = res * x; return res;&#125;//矩阵快速幂 int main() &#123; read(n), read(pr); for (int x, i = 1; i &lt;= pr; ++i) &#123; read(x); a[x] = 1; &#125; read(nf); for (int x, i = 1; i &lt;= nf; ++i) &#123; read(x); b[x] = 1; &#125;//用两个桶标记允许的块长 for (int i = 1; i &lt;= 100; ++i) if (a[i] &amp;&amp; b[i]) &#123;//若同时满足 a,b base.mat[1][i] = 1;//转移矩阵第一行 size = i;//矩阵大小 &#125; for (int i = 1; i &lt; size; ++i) base.mat[i + 1][i] = 1;//转移矩阵第 2 ~ size 行 f[0] = 1;//初始状态 for (int i = 1; i &lt; size; ++i) for (int j = 1; j &lt;= i; ++j) if (a[j] &amp;&amp; b[j]) f[i] = (f[i] + f[i - j]) % MOD;//DP 预处理 f[1] ~ f[size - 1] for (int i = 1; i &lt;= size; ++i) ans.mat[i][1] = f[size - i];//初始矩阵 ans = quickPow(base, n - size + 1) * ans;//得到答案矩阵 write(ans.mat[1][1]); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>动态规划</tag>
        <tag>矩阵加速</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 1120C」Compress String]]></title>
    <url>%2Fproblems%2Fcodeforces-1120c%2F</url>
    <content type="text"><![CDATA[Description给定一个长度为 $n$ 的字符串 $s$，现在有一个打字机，每次你可以花费 $a$ 的代价打出一个字符，或者花费 $b$ 的代价打出一个 已经打出的字符串 的子串，求打出 $s$ 的最小代价。$(1 \leq n,a,b \leq 5 \times 10^3)$ Source[Luogu]CF1120C [Codeforces]1120C Solution很容易想到 $O(n^3)$ 的 DP 。 我们用 $f_i$ 表示打完前 $i$ 个字符所需要的最小代价，状态转移方程为 \large { f_i = \min \left( f_{i - 1} + a,\min \{ f_{i - k}\} + b \right) }考虑第 $i$ 个字符是怎么打出来的。 可以先打出前 $i - 1$ 个字符，然后花费 $a$ 的代价打出第 $i$ 个字符。 设子串的末尾为第 $j$ 个字符，子串的长度为 $k$，则可以先打出前 $i - k$ 个字符，再花费 $b$ 的代价打出 $k$ 个字符。前提是 $s_{i-k + 1, i}$ 与 $s_{j - k + 1, j}$ 相等，可以用 $\rm hash$ 判断。 最后取上述两种情况的最小值即可。 如何优化？ 不难发现，$f$ 数组的值其实是单调不减的。 换句话说，方程中 $k$ 的值要尽可能大。 而 $k$ 的最大值其实是 $s_{1,i}$ 与 $s_{1,j}$ 的 最长公共后缀 长度。 于是我们可以省去对 $k$ 的枚举，同样的状态，新转移方程为 \large { f_i = \min \left( f_{i - 1} + a, \min \{f_{\min\left(i - LPS_{i,j}, j\right)} \} + b \right) }其中 $LPS_{i,j}$ 表示 $s_{1, i}$ 与 $s_{1,j}$ 的最长公共后缀长度。之所以要与 $j$ 取 $\min$，是因为已经假设子串末尾为第 $j$ 个字符，$i - LPS_{i,j}$ 的值肯定不能比 $j$ 小，否则就等于取了 还没打出来的字符串 的子串。 图示： $\rm LPS(最长公共后缀)$ 可以用 $O(n^2)$ DP 预处理，考虑第 $s_i$ 和 $s_j$ 是否相等即可。 \large { LPS_{i,j} = \left\{\begin{matrix} LPS_{i - 1,j - 1} + 1 & (s_i = s_j)\\[2ex] 0 & (s_i \neq s_j) \end{matrix}\right. }当然这道题也可以用 $\rm SA(后缀数组)$ 维护 DP，只不过写起来麻烦一点。 总时间复杂度为 $O(n^2)$ 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 5e3;int n, a, b, f[MAXN + 5], lps[MAXN + 5][MAXN + 5];char s[MAXN + 5];int main() &#123; read(n), read(a), read(b); scanf("%s", s + 1); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= i; ++j) lps[i][j] = s[i] == s[j] ? lps[i - 1][j - 1] + 1 : 0;//预处理最长公共后缀 memset(f, 0x3f, sizeof (f)); f[0] = 0;//初始状态：不打字花费的代价为 0 for (int i = 1; i &lt;= n; ++i) &#123; f[i] = f[i - 1] + a; for (int j = 1; j &lt; i; ++j) f[i] = min(f[i], f[max(i - lps[i][j], j)] + b);//转移 &#125; write(f[n]); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>字符串</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 2834」回家的路]]></title>
    <url>%2Fproblems%2Fbzoj-2834%2F</url>
    <content type="text"><![CDATA[Description给定一个 $n \times n\ (1 \leq n \leq 2 \times 10^4)$ 的网格图，走一条边用时 $2$，只能在特定的 $m\ (1 \leq m \leq 10^5)$ 个点转向，转向用时 $1$，求从 $(x_1,x_2)$ 到 $(y_1, y_2)$ 的最短用时。 Source[BZOJ]2834 Solution考虑 分层图最短路 。 对于样例： Sample Input12345678910116 92 12 53 24 45 25 66 16 36 41 1 4 6 Sample Output127 题目所给的图： 我们按照输入的顺序给这些点标上号（包括起点和终点），共 $m + 2$ 个点。 设 $n = m + 2$，表示点的数量。起点为 $10$ 号节点，终点为 $11$ 号节点。 我们可以把图分成两层，其中第 $1$ 层为横向走，第 $2$ 层为纵向走。 先考虑横向走。将所有点以横坐标为第 $1$ 关键字，纵坐标为第 $2$ 关键字从小到大排序。排完序后，判断相邻两个点的横坐标是否相同，如果相同，则在它们两个点之间连一条边权为 两点纵坐标之差的两倍 的双向边。若可以连边 $u \leftrightarrow v$，则说明从点 $u$ 可以横向走到点 $v$，亦可以从点 $v$ 横向走到点 $u$ 。 图中可以连的边有： $1 \leftrightarrow 2\\4 \leftrightarrow 11\\5 \leftrightarrow 6\\7 \leftrightarrow 8\\8 \leftrightarrow 9$ 边权分别为 $8,4,8,4,2$ 。 纵向走同理。因为纵向走在第 $2$ 层，节点编号不能与第 $1$ 层相同，所以给第 $2$ 层编号全部 $+n$ 。然后将所有点以纵坐标为第 $1$ 关键字，横坐标为第 $2$ 关键字从小到大排序。比较相邻两点纵坐标，连边。若可以连边 $u \leftrightarrow v$，则说明从点 $u$ 可以纵向走到点 $v$，也可以从点 $v$ 纵向走到点 $u$ 。 图中可以连的边有： $10+11 \leftrightarrow 1+11\\1+11 \leftrightarrow 7+11\\3+11 \leftrightarrow 5+11\\4+11 \leftrightarrow 9+11\\11+11 \leftrightarrow 6+11$ 边权分别为 $2,8,4,4,2$ 。 接下来在两层 表示同个节点的点 之间连一条权值为 $1$ 的双向边，表示可以在该点改变方向，用时为 $1$ 。 注意起点和终点改变方向不需要 $1$ 的时间，所以在 起点 与 起点$ + n$ 之间，终点 与 终点$ + n$ 之间连一条边权为 $0$ 的双向边。 最后跑一遍起点到终点的最短路即是答案，时间复杂度为 $O(m\log m)$。 完整的图： Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 3e5, MAXM = 3e6;int n, m, s, t, tot, head[MAXN + 5], dis[MAXN + 5];bool vis[MAXN + 5];struct Station &#123; int x, y, id;&#125; a[MAXN + 5];struct Edge &#123; int next, to, dis;&#125; e[MAXM + 5];struct Node &#123; int val, id; inline friend bool operator&lt;(Node x, Node y) &#123; return x.val &gt; y.val; &#125;&#125;;inline void addEdge(int u, int v, int w) &#123; e[++tot] = (Edge) &#123; head[u], v, w &#125;; head[u] = tot;&#125;inline bool cmpx(Station a, Station b) &#123;//按横坐标排序 return a.x == b.x ? a.y &lt; b.y : a.x &lt; b.x;&#125;inline bool cmpy(Station a, Station b) &#123;//按纵坐标排序 return a.y == b.y ? a.x &lt; b.x : a.y &lt; b.y;&#125;inline void dijkstra(int s) &#123;//堆优化 dijkstra priority_queue&lt;Node&gt; q; memset(dis, 0x3f, sizeof (dis)); dis[s] = 0; q.push((Node) &#123; 0, s &#125;); for (; !q.empty(); ) &#123; int u = q.top().id; q.pop(); if (vis[u]) continue; vis[u] = 1; for (int v, w, i = head[u]; v = e[i].to, w = e[i].dis, i; i = e[i].next) if (dis[v] &gt; dis[u] + w) &#123; dis[v] = dis[u] + w; if (!vis[v]) q.push((Node) &#123; dis[v], v &#125;); &#125; &#125;&#125;int main() &#123; read(n), read(m); n = m + 2;//点的总数 s = n - 1, t = n;//起点 和 终点 for (int i = 1; i &lt;= n; ++i) &#123; read(a[i].x), read(a[i].y); a[i].id = i;//点的编号 &#125; sort(a + 1, a + n + 1, cmpx); for (int i = 1; i &lt; n; ++i) if (a[i].x == a[i + 1].x) &#123; addEdge(a[i].id, a[i + 1].id, (a[i + 1].y - a[i].y) &lt;&lt; 1); addEdge(a[i + 1].id, a[i].id, (a[i + 1].y - a[i].y) &lt;&lt; 1); &#125; //第一层：横向边 sort(a + 1, a + n + 1, cmpy); for (int i = 1; i &lt; n; ++i) if (a[i].y == a[i + 1].y) &#123; addEdge(a[i].id + n, a[i + 1].id + n, (a[i + 1].x - a[i].x) &lt;&lt; 1); addEdge(a[i + 1].id + n, a[i].id + n, (a[i + 1].x - a[i].x) &lt;&lt; 1); &#125; //第二层：纵向边 for (int i = 1; i &lt;= n - 2; ++i) addEdge(i, i + n, 1), addEdge(i + n, i, 1); //两层之间：改变方向用时 1 addEdge(s, s + n, 0), addEdge(s + n, s, 0); addEdge(t, t + n, 0), addEdge(t + n, t, 0);//起点和终点改变方向不需要时间 dijkstra(s);//求 s -&gt; t 最短路 write(dis[t] == 0x3f3f3f3f ? -1 : dis[t]);//判断是否有解 putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P3831」「SHOI2012」回家的路]]></title>
    <url>%2Fproblems%2Fluogu-p3831%2F</url>
    <content type="text"><![CDATA[Description给定一个 $n \times n\ (1 \leq n \leq 2 \times 10^4)$ 的网格图，走一条边用时 $2$，只能在特定的 $m\ (1 \leq m \leq 10^5)$ 个点转向，转向用时 $1$，求从 $(x_1,x_2)$ 到 $(y_1, y_2)$ 的最短用时。 Source[Luogu]P3831 Solution考虑 分层图最短路 。 对于样例： Sample Input12345678910116 92 12 53 24 45 25 66 16 36 41 1 4 6 Sample Output127 题目所给的图： 我们按照输入的顺序给这些点标上号（包括起点和终点），共 $m + 2$ 个点。 设 $n = m + 2$，表示点的数量。起点为 $10$ 号节点，终点为 $11$ 号节点。 我们可以把图分成两层，其中第 $1$ 层为横向走，第 $2$ 层为纵向走。 先考虑横向走。将所有点以横坐标为第 $1$ 关键字，纵坐标为第 $2$ 关键字从小到大排序。排完序后，判断相邻两个点的横坐标是否相同，如果相同，则在它们两个点之间连一条边权为 两点纵坐标之差的两倍 的双向边。若可以连边 $u \leftrightarrow v$，则说明从点 $u$ 可以横向走到点 $v$，亦可以从点 $v$ 横向走到点 $u$ 。 图中可以连的边有： $1 \leftrightarrow 2\\4 \leftrightarrow 11\\5 \leftrightarrow 6\\7 \leftrightarrow 8\\8 \leftrightarrow 9$ 边权分别为 $8,4,8,4,2$ 。 纵向走同理。因为纵向走在第 $2$ 层，节点编号不能与第 $1$ 层相同，所以给第 $2$ 层编号全部 $+n$ 。然后将所有点以纵坐标为第 $1$ 关键字，横坐标为第 $2$ 关键字从小到大排序。比较相邻两点纵坐标，连边。若可以连边 $u \leftrightarrow v$，则说明从点 $u$ 可以纵向走到点 $v$，也可以从点 $v$ 纵向走到点 $u$ 。 图中可以连的边有： $10+11 \leftrightarrow 1+11\\1+11 \leftrightarrow 7+11\\3+11 \leftrightarrow 5+11\\4+11 \leftrightarrow 9+11\\11+11 \leftrightarrow 6+11$ 边权分别为 $2,8,4,4,2$ 。 接下来在两层 表示同个节点的点 之间连一条权值为 $1$ 的双向边，表示可以在该点改变方向，用时为 $1$ 。 注意起点和终点改变方向不需要 $1$ 的时间，所以在 起点 与 起点$ + n$ 之间，终点 与 终点$ + n$ 之间连一条边权为 $0$ 的双向边。 最后跑一遍起点到终点的最短路即是答案，时间复杂度为 $O(m\log m)$。 完整的图： Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 3e5, MAXM = 3e6;int n, m, s, t, tot, head[MAXN + 5], dis[MAXN + 5];bool vis[MAXN + 5];struct Station &#123; int x, y, id;&#125; a[MAXN + 5];struct Edge &#123; int next, to, dis;&#125; e[MAXM + 5];struct Node &#123; int val, id; inline friend bool operator&lt;(Node x, Node y) &#123; return x.val &gt; y.val; &#125;&#125;;inline void addEdge(int u, int v, int w) &#123; e[++tot] = (Edge) &#123; head[u], v, w &#125;; head[u] = tot;&#125;inline bool cmpx(Station a, Station b) &#123;//按横坐标排序 return a.x == b.x ? a.y &lt; b.y : a.x &lt; b.x;&#125;inline bool cmpy(Station a, Station b) &#123;//按纵坐标排序 return a.y == b.y ? a.x &lt; b.x : a.y &lt; b.y;&#125;inline void dijkstra(int s) &#123;//堆优化 dijkstra priority_queue&lt;Node&gt; q; memset(dis, 0x3f, sizeof (dis)); dis[s] = 0; q.push((Node) &#123; 0, s &#125;); for (; !q.empty(); ) &#123; int u = q.top().id; q.pop(); if (vis[u]) continue; vis[u] = 1; for (int v, w, i = head[u]; v = e[i].to, w = e[i].dis, i; i = e[i].next) if (dis[v] &gt; dis[u] + w) &#123; dis[v] = dis[u] + w; if (!vis[v]) q.push((Node) &#123; dis[v], v &#125;); &#125; &#125;&#125;int main() &#123; read(n), read(m); n = m + 2;//点的总数 s = n - 1, t = n;//起点 和 终点 for (int i = 1; i &lt;= n; ++i) &#123; read(a[i].x), read(a[i].y); a[i].id = i;//点的编号 &#125; sort(a + 1, a + n + 1, cmpx); for (int i = 1; i &lt; n; ++i) if (a[i].x == a[i + 1].x) &#123; addEdge(a[i].id, a[i + 1].id, (a[i + 1].y - a[i].y) &lt;&lt; 1); addEdge(a[i + 1].id, a[i].id, (a[i + 1].y - a[i].y) &lt;&lt; 1); &#125; //第一层：横向边 sort(a + 1, a + n + 1, cmpy); for (int i = 1; i &lt; n; ++i) if (a[i].y == a[i + 1].y) &#123; addEdge(a[i].id + n, a[i + 1].id + n, (a[i + 1].x - a[i].x) &lt;&lt; 1); addEdge(a[i + 1].id + n, a[i].id + n, (a[i + 1].x - a[i].x) &lt;&lt; 1); &#125; //第二层：纵向边 for (int i = 1; i &lt;= n - 2; ++i) addEdge(i, i + n, 1), addEdge(i + n, i, 1); //两层之间：改变方向用时 1 addEdge(s, s + n, 0), addEdge(s + n, s, 0); addEdge(t, t + n, 0), addEdge(t + n, t, 0);//起点和终点改变方向不需要时间 dijkstra(s);//求 s -&gt; t 最短路 write(dis[t] == 0x3f3f3f3f ? -1 : dis[t]);//判断是否有解 putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>2012</tag>
        <tag>最短路</tag>
        <tag>SHOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 2763」「JLOI2011」飞行路线]]></title>
    <url>%2Fproblems%2Fbzoj-2763%2F</url>
    <content type="text"><![CDATA[Description给定一个 $n\ (2 \leq n \leq 10^4)$ 个点（编号为 $0 \sim n - 1$），$m\ (1 \leq m \leq 5 \times 10^4)$ 条边的无向图，其中最多可以把 $k\ (0 \leq k \leq 10)$ 条边的边权变成 $0$，求 $s$ 到 $t\ (0 \leq s,t &lt; n)$ 的最短路。 Source[BZOJ]2763 Solution分层图最短路 模板题。 这类题目主要难在建图。 比如说，对于样例 Sample Input123456785 6 10 40 1 51 2 52 3 53 4 52 3 30 2 100 Sample Output18 建出来的图： 我们可以考虑把图分成 $k + 1$ 层，每往下一层，边权变成 $0$ 的边就增加 $1$ 条。编号为 $i$ 的点在第 $j$ 层的编号为 $i + j \times n\ (0 \leq i &lt; n,0 \leq j \leq k)$ 。 每一层都有同样的 $n$ 个点，$m$ 条边。 在层与层之间有单向边，边权为 $0$，且不能从下层到上层。 对于一条边权为 $w$ 的无向边 $u \leftrightarrow v$，我们可以在第 $i = 0 \sim k$ 层连无向边 $u + i \times n \leftrightarrow v + i \times n$，边权为 $w$，表示每一层里的 $u$ 和 $v$ 能互相到达，且花费的代价为 $w$ 。 紧接着，在第 $i - 1$ 层和第 $i$ 层之间连两条边权为 $0$ 的有向边 $u + (i-1) \times n \to v + i \times n$ 和 $v + (i-1) \times n \to u + i \times n$，表示可以把边 $u \to v$ 或 $v \to u$ 的边权变成 $0$，然后到下一层的 $v$ 点或 $u$ 点。 建图后，$s$ 到 $t + k \times n$ 的最短路即是用完 $k$ 次机会的最少花费。 最后可能没有用完 $k$ 次机会，所以到每层终点的最短路都有可能成为答案，取最小值即可。时间复杂度为 $O\left(mk\log (nk) \right)$ 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 2e5, MAXM = 5e6;int n, m, k, s, t, tot, ans = 0x7fffffff, head[MAXN + 5], dis[MAXN + 5];bool vis[MAXN + 5];struct Edge &#123; int next, to, dis;&#125; e[MAXM + 5];struct Node &#123; int val, id; inline friend bool operator&lt;(Node x, Node y) &#123; return x.val &gt; y.val; &#125; &#125;;inline void addEdge(int u, int v, int w) &#123; e[++tot] = (Edge) &#123; head[u], v, w &#125;; head[u] = tot;&#125;inline void dijkstra(int s) &#123;//堆优化 dijkstra memset(dis, 0x3f, sizeof (dis)); priority_queue&lt;Node&gt; q; dis[s] = 0; q.push((Node) &#123; 0, s &#125;); for (; !q.empty(); ) &#123; int u = q.top().id; q.pop(); if (vis[u]) continue; vis[u] = 1; for (int v, w, i = head[u]; v = e[i].to, w = e[i].dis, i; i = e[i].next) if (dis[v] &gt; dis[u] + w) &#123; dis[v] = dis[u] + w; if (!vis[v]) q.push((Node) &#123; dis[v], v &#125;); &#125; &#125;&#125;int main() &#123; read(n), read(m), read(k), read(s), read(t); ++s, ++t;//点的编号改为 1 ~ n for (int u, v, w, i = 1; i &lt;= m; ++i) &#123; read(u), read(v), read(w); ++u, ++v; addEdge(u, v, w), addEdge(v, u, w); for (int j = 1; j &lt;= k; ++j) &#123;//一共 k 层 addEdge(u + (j - 1) * n, v + j * n, 0), addEdge(v + (j - 1) * n, u + j * n, 0); //层与层之间对应的点连一条权值为 0 的边 addEdge(u + j * n, v + j * n, w), addEdge(v + j * n, u + j * n, w); //每一层中对应的点连边 &#125; &#125; dijkstra(s); for (int i = 0; i &lt;= k; ++i) ans = min(ans, dis[t + i * n]); //可能没有用完 k 次机会，所以要取 到每一层终点最短路 的最小值 write(ans); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>最短路</tag>
        <tag>JLOI</tag>
        <tag>2011</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P4568」「JLOI2011」飞行路线]]></title>
    <url>%2Fproblems%2Fluogu-p4568%2F</url>
    <content type="text"><![CDATA[Description给定一个 $n\ (2 \leq n \leq 10^4)$ 个点（编号为 $0 \sim n - 1$），$m\ (1 \leq m \leq 5 \times 10^4)$ 条边的无向图，其中最多可以把 $k\ (0 \leq k \leq 10)$ 条边的边权变成 $0$，求 $s$ 到 $t\ (0 \leq s,t &lt; n)$ 的最短路。 Source[Luogu]P4568 Solution分层图最短路 模板题。 这类题目主要难在建图。 比如说，对于样例 Sample Input123456785 6 10 40 1 51 2 52 3 53 4 52 3 30 2 100 Sample Output18 建出来的图： 我们可以考虑把图分成 $k + 1$ 层，每往下一层，边权变成 $0$ 的边就增加 $1$ 条。编号为 $i$ 的点在第 $j$ 层的编号为 $i + j \times n\ (0 \leq i &lt; n,0 \leq j \leq k)$ 。 每一层都有同样的 $n$ 个点，$m$ 条边。 在层与层之间有单向边，边权为 $0$，且不能从下层到上层。 对于一条边权为 $w$ 的无向边 $u \leftrightarrow v$，我们可以在第 $i = 0 \sim k$ 层连无向边 $u + i \times n \leftrightarrow v + i \times n$，边权为 $w$，表示每一层里的 $u$ 和 $v$ 能互相到达，且花费的代价为 $w$ 。 紧接着，在第 $i - 1$ 层和第 $i$ 层之间连两条边权为 $0$ 的有向边 $u + (i-1) \times n \to v + i \times n$ 和 $v + (i-1) \times n \to u + i \times n$，表示可以把边 $u \to v$ 或 $v \to u$ 的边权变成 $0$，然后到下一层的 $v$ 点或 $u$ 点。 建图后，$s$ 到 $t + k \times n$ 的最短路即是用完 $k$ 次机会的最少花费。 最后可能没有用完 $k$ 次机会，所以到每层终点的最短路都有可能成为答案，取最小值即可。时间复杂度为 $O\left(mk\log (nk) \right)$ 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 2e5, MAXM = 5e6;int n, m, k, s, t, tot, ans = 0x7fffffff, head[MAXN + 5], dis[MAXN + 5];bool vis[MAXN + 5];struct Edge &#123; int next, to, dis;&#125; e[MAXM + 5];struct Node &#123; int val, id; inline friend bool operator&lt;(Node x, Node y) &#123; return x.val &gt; y.val; &#125; &#125;;inline void addEdge(int u, int v, int w) &#123; e[++tot] = (Edge) &#123; head[u], v, w &#125;; head[u] = tot;&#125;inline void dijkstra(int s) &#123;//堆优化 dijkstra memset(dis, 0x3f, sizeof (dis)); priority_queue&lt;Node&gt; q; dis[s] = 0; q.push((Node) &#123; 0, s &#125;); for (; !q.empty(); ) &#123; int u = q.top().id; q.pop(); if (vis[u]) continue; vis[u] = 1; for (int v, w, i = head[u]; v = e[i].to, w = e[i].dis, i; i = e[i].next) if (dis[v] &gt; dis[u] + w) &#123; dis[v] = dis[u] + w; if (!vis[v]) q.push((Node) &#123; dis[v], v &#125;); &#125; &#125;&#125;int main() &#123; read(n), read(m), read(k), read(s), read(t); ++s, ++t;//点的编号改为 1 ~ n for (int u, v, w, i = 1; i &lt;= m; ++i) &#123; read(u), read(v), read(w); ++u, ++v; addEdge(u, v, w), addEdge(v, u, w); for (int j = 1; j &lt;= k; ++j) &#123;//一共 k 层 addEdge(u + (j - 1) * n, v + j * n, 0), addEdge(v + (j - 1) * n, u + j * n, 0); //层与层之间对应的点连一条权值为 0 的边 addEdge(u + j * n, v + j * n, w), addEdge(v + j * n, u + j * n, w); //每一层中对应的点连边 &#125; &#125; dijkstra(s); for (int i = 0; i &lt;= k; ++i) ans = min(ans, dis[t + i * n]); //可能没有用完 k 次机会，所以要取 到每一层终点最短路 的最小值 write(ans); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>最短路</tag>
        <tag>JLOI</tag>
        <tag>2011</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 2118」墨墨的等式]]></title>
    <url>%2Fproblems%2Fbzoj-2118%2F</url>
    <content type="text"><![CDATA[Description对于等式 $a_1x_1 + a_2x_2 + \cdots + a_nx_n = B\ \left(B \in \left[l,r \right] \right)$，已知 $n\ (1 \leq n \leq 12)$，$a_i\ (0 \leq a_i \leq 5 \times 10^5)$，$l, r\ (1 \leq l \leq r \leq 10^{12})$，求有多少 $B$ 可以使该等式存在非负整数解。 Source[BZOJ]2118 Solution很容易想到 完全背包，用 $f_i$ 表示 $B$ 的值能否为 $i$，那么转移方程为 \large { f_j = f_j \mid f_{j - a_i} }还可以用 $\rm bitset$ 优化，时间复杂度为 $O(\frac{nr}{w})$ 。 $l, r$ 很大，上述方法显然行不通。 我们可以分别求出 $0 \sim r$ 中符合条件的 $B$ 的数量 和 $0 \sim l - 1$ 中符合条件的 $B$ 的数量，前者减去后者即是答案。现在假设 $mn$ 是 $a_i$ 中的一个数，那么对于 $a_1x_1 + a_2x_2 + \cdots + a_nx_n = i$，都满足 $a_1x_1 + a_2x_2 + \cdots + a_nx_n = i + k \times mn\ (k \in \rm N)$ 。在这个式子中，显然 $i$ 越小，符合条件的数就会越多。 我们可以用 $dis_i$ 表示 $B$ 模 $mn$ 等于 $i$ 时的最小值。接下来连有向边 $i \to (i + a_j) \bmod mn$，其中 $0 \leq i &lt; mn$，边权为 $a_j$，表示从 $i$ 变为 $i + a_j$ 所花费的代价是 $a_j$ 。$0$ 到 $i$ 的最短路即是 $B$ 模 $mn$ 等于 $i$ 时的最小值。假定现在要求 $0 \sim x$ 中符合条件的 $B$ 的数量，若这个最小值不大于 $x$，则所有的 $i + k \times mn\ (i + k \times mn \leq x,k \in \rm N)$ 都符合条件，一共有 $\left \lfloor \frac{x - dis_i}{mn} \right \rfloor + 1$ 个。 所以枚举 $i$，累加就能得到答案。同时 $mn$ 取所有 $a_i$ 的最小值最优，因为这样边数最少。时间复杂度为 $O(kn\max\limits_{i = 1}^n\{ a_i \})$ 。由于特殊的连边，$\rm SPFA$ 不会被卡，可以放心使用。 我们一般称这种算法为 同余最短路 。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 5e5, MAXM = 6e6;const LL INF = 1e12;int n, m, mn = MAXN + 5, tot, a[MAXN + 5], head[MAXN + 5];LL l, r, dis[MAXN + 5];bool vis[MAXN + 5];struct Edge &#123; int next, to, dis;&#125; e[MAXM + 5];inline void addEdge(int u, int v, int w) &#123; e[++tot] = (Edge) &#123; head[u], v, w &#125;; head[u] = tot;&#125;inline void spfa(int s) &#123; for (int i = 0; i &lt; mn; ++i) dis[i] = INF + 1;//初始化 queue&lt;int&gt; q; dis[s] = 0;//满足模 mn 等于 0 的最小的 B 是 0 q.push(s); for (; !q.empty(); ) &#123; int u = q.front(); q.pop(); vis[u] = 0; for (int v, w, i = head[u]; v = e[i].to, w = e[i].dis, i; i = e[i].next) if (dis[v] &gt; dis[u] + w) &#123; dis[v] = dis[u] + w; if (!vis[v]) &#123; q.push(v); vis[v] = 1; &#125; &#125; &#125;&#125;inline LL query(LL x) &#123;//求出 0 ~ x 中符合条件的 B 的数量 LL res = 0; for (int i = 0; i &lt; mn; ++i) if (dis[i] &lt;= x) res += (x - dis[i]) / mn + 1;//累加答案 return res;&#125;int main() &#123; read(n), read(l), read(r); for (int x, i = 1; i &lt;= n; ++i) &#123; read(x); if (x) &#123;//a[i] = 0 可以跳过，因为没有贡献 a[++m] = x; mn = min(mn, x);//求出最小且非 0 的 a[i] 作为 mn 的值 &#125; &#125; n = m; for (int i = 0; i &lt; mn; ++i) for (int j = 1; j &lt;= n; ++j) if (a[j] != mn)//自己向自己没必要连边 addEdge(i, (i + a[j]) % mn, a[j]);//连有向边 spfa(0);//从 0 开始 write(query(r) - query(l - 1)); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>集训队</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2371」「国家集训队」墨墨的等式]]></title>
    <url>%2Fproblems%2Fluogu-p2371%2F</url>
    <content type="text"><![CDATA[Description对于等式 $a_1x_1 + a_2x_2 + \cdots + a_nx_n = B\ \left(B \in \left[l,r \right] \right)$，已知 $n\ (1 \leq n \leq 12)$，$a_i\ (0 \leq a_i \leq 5 \times 10^5)$，$l, r\ (1 \leq l \leq r \leq 10^{12})$，求有多少 $B$ 可以使该等式存在非负整数解。 Source[Luogu]P2371 Solution很容易想到 完全背包，用 $f_i$ 表示 $B$ 的值能否为 $i$，那么转移方程为 \large { f_j = f_j \mid f_{j - a_i} }还可以用 $\rm bitset$ 优化，时间复杂度为 $O(\frac{nr}{w})$ 。 $l, r$ 很大，上述方法显然行不通。 我们可以分别求出 $0 \sim r$ 中符合条件的 $B$ 的数量 和 $0 \sim l - 1$ 中符合条件的 $B$ 的数量，前者减去后者即是答案。现在假设 $mn$ 是 $a_i$ 中的一个数，那么对于 $a_1x_1 + a_2x_2 + \cdots + a_nx_n = i$，都满足 $a_1x_1 + a_2x_2 + \cdots + a_nx_n = i + k \times mn\ (k \in \rm N)$ 。在这个式子中，显然 $i$ 越小，符合条件的数就会越多。 我们可以用 $dis_i$ 表示 $B$ 模 $mn$ 等于 $i$ 时的最小值。接下来连有向边 $i \to (i + a_j) \bmod mn$，其中 $0 \leq i &lt; mn$，边权为 $a_j$，表示从 $i$ 变为 $i + a_j$ 所花费的代价是 $a_j$ 。$0$ 到 $i$ 的最短路即是 $B$ 模 $mn$ 等于 $i$ 时的最小值。假定现在要求 $0 \sim x$ 中符合条件的 $B$ 的数量，若这个最小值不大于 $x$，则所有的 $i + k \times mn\ (i + k \times mn \leq x,k \in \rm N)$ 都符合条件，一共有 $\left \lfloor \frac{x - dis_i}{mn} \right \rfloor + 1$ 个。 所以枚举 $i$，累加就能得到答案。同时 $mn$ 取所有 $a_i$ 的最小值最优，因为这样边数最少。时间复杂度为 $O(kn\max\limits_{i = 1}^n\{ a_i \})$ 。由于特殊的连边，$\rm SPFA$ 不会被卡，可以放心使用。 我们一般称这种算法为 同余最短路 。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 5e5, MAXM = 6e6;const LL INF = 1e12;int n, m, mn = MAXN + 5, tot, a[MAXN + 5], head[MAXN + 5];LL l, r, dis[MAXN + 5];bool vis[MAXN + 5];struct Edge &#123; int next, to, dis;&#125; e[MAXM + 5];inline void addEdge(int u, int v, int w) &#123; e[++tot] = (Edge) &#123; head[u], v, w &#125;; head[u] = tot;&#125;inline void spfa(int s) &#123; for (int i = 0; i &lt; mn; ++i) dis[i] = INF + 1;//初始化 queue&lt;int&gt; q; dis[s] = 0;//满足模 mn 等于 0 的最小的 B 是 0 q.push(s); for (; !q.empty(); ) &#123; int u = q.front(); q.pop(); vis[u] = 0; for (int v, w, i = head[u]; v = e[i].to, w = e[i].dis, i; i = e[i].next) if (dis[v] &gt; dis[u] + w) &#123; dis[v] = dis[u] + w; if (!vis[v]) &#123; q.push(v); vis[v] = 1; &#125; &#125; &#125;&#125;inline LL query(LL x) &#123;//求出 0 ~ x 中符合条件的 B 的数量 LL res = 0; for (int i = 0; i &lt; mn; ++i) if (dis[i] &lt;= x) res += (x - dis[i]) / mn + 1;//累加答案 return res;&#125;int main() &#123; read(n), read(l), read(r); for (int x, i = 1; i &lt;= n; ++i) &#123; read(x); if (x) &#123;//a[i] = 0 可以跳过，因为没有贡献 a[++m] = x; mn = min(mn, x);//求出最小且非 0 的 a[i] 作为 mn 的值 &#125; &#125; n = m; for (int i = 0; i &lt; mn; ++i) for (int j = 1; j &lt;= n; ++j) if (a[j] != mn)//自己向自己没必要连边 addEdge(i, (i + a[j]) % mn, a[j]);//连有向边 spfa(0);//从 0 开始 write(query(r) - query(l - 1)); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>集训队</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P3403」跳楼机]]></title>
    <url>%2Fproblems%2Fluogu-p3403%2F</url>
    <content type="text"><![CDATA[Description现在有一座 $h\ (1 \leq h \leq 2^{63} - 1)$ 层的大楼，你站在第 $1$ 层，每次可以选择向上移动 $x,y,z\ (1 \leq x,y,z \leq 10^5)$ 层，求能到达的楼层数。 Source[Luogu]P3403 Solution其实问题就是求 $ax + by + cz\ (a, b, c \in\rm N)$ 有多少个小于等于 $h$ 的值。 很容易想到 $O(h)$ 的做法，就是用 $f_i$ 表示第 $i$ 层能否到达，那么转移方程就是 \large { f_i = f_{i - x} \mid f_{i - y} \mid f_{i - z} }但是 $h$ 很大，所以换一种思路。 显然如果某一层楼 $i$ 能到达，那么 $i + kx$ 也一定能到达，因此只需要考虑模 $x$ 等于 $i$ 的最小层数。我们可以连有向边 $i \to (i + y) \bmod x$ 以及 $i \to (i +z) \bmod x$，其中 $0 \leq i &lt; x$，边权分别为 $y$ 和 $z$，表示从第 $i$ 层到第 $i + y$ 层需要走 $y$ 层，$z$ 同理。建图后，从 $1$ 到 $i$ 的最短路即是模 $x$ 等于 $i$ 的最小层数。如果最早在第 $j\ (1 \leq j \leq h)$ 层满足 $j \bmod x = i$，则 $j + kx$ 层都能够到达，但又必须满足 $j + kx \leq h$，所以一共有 $\left \lfloor \frac{h - j}{x} \right \rfloor + 1$ 层能到达。枚举 $i = 0 \sim x - 1$，然后累加答案即可。时间复杂度为 $O(kx)$ 。这种算法叫做 同余最短路 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long ULL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1e5, MAXM = 2e5;ULL h, ans, dis[MAXN + 5];int x, y, z, tot, head[MAXN + 5];bool vis[MAXN + 5];struct Edge &#123; int next, to, dis;&#125; e[MAXM + 5];inline void addEdge(int u, int v, int w) &#123; e[++tot] = (Edge) &#123; head[u], v, w &#125;; head[u] = tot;&#125;inline void spfa(int s) &#123;//求 1 到其它点的最短路 for (int i = 0; i &lt; x; ++i) dis[i] = h + 1;//初始化 queue&lt;int&gt; q; dis[s] = 1;//模 x 等于 1 的最小层数是 1 q.push(s); for (; !q.empty(); ) &#123; int u = q.front(); q.pop(); vis[u] = 0; for (int v, w, i = head[u]; v = e[i].to, w = e[i].dis, i; i = e[i].next) if (dis[v] &gt; dis[u] + w) &#123; dis[v] = dis[u] + w; if (!vis[v]) &#123; q.push(v); vis[v] = 1; &#125; &#125; &#125;&#125;int main() &#123; read(h), read(x), read(y), read(z); if (x == 1 || y == 1 || z == 1) &#123; write(h); putchar('\n'); return 0; &#125;//特判，防止出现 x mod 1 = 0 的情况 for (int i = 0; i &lt; x; ++i) addEdge(i, (i + y) % x, y), addEdge(i, (i + z) % x, z);//连有向边 spfa(1);//起点为 1 for (int i = 0; i &lt; x; ++i) if (dis[i] &lt;= h)//第 i mod x 层必须在 h 层之前 ans += (h - dis[i]) / x + 1;//累加答案 write(ans); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2807」三角形计数]]></title>
    <url>%2Fproblems%2Fluogu-p2807%2F</url>
    <content type="text"><![CDATA[Description$n$ 等分大三角形的每条边，将对应的等分点连接起来（连接线分别平行于三条边），求有多少个三角形。 Source[Luogu]P2807 Solution看似很简单的数学题，实际上让人摸不着头发（？？？ 不妨设$\triangle ABC$ 的边长为 $n$，这样 $n$ 等分每一条边后，每个小三角形的边长为 $1$ 。 先考虑头朝上的三角形（$\triangle$）： 边长为 $1$ 的三角形有多少个呢？ （如图）显然第一层有 $1$ 个，第二层有 $2$ 个，一直到第 $n$ 层有 $n$ 个，共 1 + 2 + \cdots + n = \frac{n\left( n + 1\right)}{2}那边长为 $2$ 的三角形呢？ （如图）我们可以数它左下角那个边长为 $1$ 的三角形，因为有大小限制，最右侧一列就不能数了，所以问题变为求边长为 $n - 1$ 的三角形中有几个边长为 $1$ 的三角形，与上面的求法一样，共 1 + 2 + \cdots + n - 1 = \frac{n \left( n - 1\right)}{2}同理，边长为 $i\ \left(1 \leq i \leq n\right)$ 的三角形共 1 + 2 + \cdots + n - i + 1 = \frac{\left(n - i + 1 \right)\left( n - i + 2 \right)}{2}由此可以得出结论，边长 $1 \sim n$ 头朝上的三角形共 \frac{\sum\limits_{i = 1}^n\left(n - i + 1 \right)\left( n - i + 2 \right)}{2} = \frac{\sum\limits_{i = 1}^n i\left( i + 1\right)}{2} = \frac{n \left( n + 1\right)\left(n + 2 \right)}{6}至于第 $2$ 步到第 $3$ 步怎么得出来的，这里给出详细解释。 定理： \sum\limits_{i = 1}^n i^2 = 1^2+2^2+ \cdots + n^2 = \frac{n\left( n + 1 \right) \left( 2n + 1\right)}{6}证明： 首先需要知道 \left( n + 1 \right)^3 = n^3 + 3n^2 + 3n + 1那么 \left( n + 1 \right)^3 - n^3 = 3n^2 + 3n + 1因此我们可以列出 $n$ 个式子 \left\{\begin{matrix} \begin{aligned} \left( n + 1 \right)^3 - n^3 &= 3n^2 + 3n + 1\\[2ex] n^3 - \left( n - 1 \right)^3 &= 3\left( n - 1 \right)^2 + 3\left( n - 1 \right) + 1\\[2ex] &\cdots \cdots\\[2ex] 3^3 - 2^3 &= 3 \times 2^2 + 3 \times 2 + 1\\[2ex] 2^3 - 1^3 &= 3 \times 1^2 + 3 \times 1 + 1 \end{aligned} \end{matrix}\right.把这 $n$ 个式子相加，得到 \left( n + 1\right)^3 - 1^3 = 3\sum\limits_{i=1}^n i^2 + 3\sum\limits_{i=1}^n i + n化简 n^3 + 3n^2 + 2n = 3\sum\limits_{i = 1}^ni^2 + \frac{3n\left(n + 1\right)}{2} 2n^3 + 6n^2 + 4n = 6\sum\limits_{i = 1}^ni^2 + 3n^2 + 3n \sum\limits_{i = 1}^ni^2 = \frac{2n^3 + 3n^2 + n}{6}因式分解，得 \sum\limits_{i = 1}^ni^2 = \frac{2n^3 + 3n^2 + n}{6} = \frac{n\left(2n^2 + 3n + 1 \right)}{6} = \frac{n\left( n + 1 \right) \left( 2n + 1\right)}{6}证毕。 于是乎，我们就可以推出 \begin{aligned} 原式&=\frac{\sum\limits_{i = 1}^n i\left( i + 1\right)}{2} \\[2ex] &= \frac{\sum\limits_{i = 1}^n i^2 + \sum\limits_{i = 1}^n i}{2} \\[2ex] &= \frac{n\left( n + 1 \right) \left( 2n + 1\right)}{12} + \frac{n\left(n + 1\right)}{4}\\[2ex] &= \frac{n\left( n + 1 \right) \left( 2n + 1\right) + 3n\left(n + 1\right)}{12}\\[2ex] &= \frac{n\left( n + 1 \right) \left( 2n + 4\right)}{12}\\[2ex] &= \frac{n\left( n + 1 \right) \left( n + 2\right)}{6} \end{aligned}再考虑头朝下的三角形（$\bigtriangledown $）： （如图）边长为 $1$ 的三角形第 $1$ 行没有，第二行有 $1$ 个，第三行有 $2$ 个，一直到第 $n$ 行有 $n - 1$ 个，所以共 1 + 2 + \cdots + n - 1 = \frac{n \left( n - 1\right)}{2}接下来数边长为 $2$ 的三角形。 （如图）我们考虑数它下方的三角形。前三行没有，第 $4$ 行有 $1$ 个，第 $5$ 行有 $2$ 个，一直到第 $n$ 行有 $n - 3$ 个，共 1 + 2 + \cdots + n - 3 = \frac{\left( n - 2 \right)\left( n - 3 \right)}{2}同理，边长为 $3$ 的三角形共 1 + 2 + \cdots + n - 5 = \frac{\left( n - 4 \right)\left( n - 5 \right)}{2}边长为 $i\ \left( 2 \leq 2i \leq n \right)$ 的三角形共 1 + 2 + \cdots + n - 2 i + 1 = \frac{\left( n - 2i + 1 \right)\left( n - 2i + 2 \right)}{2}头朝下的三角形共（第一行式子表示 $n$ 是奇数，第二行式子表示 $n$ 是偶数） \left\{\begin{matrix} \begin{aligned} & \frac{2 \times 3 + 4 \times 5 + \cdots + n\left( n - 1 \right)}{2} = \frac{\left( n - 1 \right)\left( n + 1 \right)\left( 2n + 3 \right)}{24} & \{n \mid n = 2m + 1,m \in \rm N^* \}\\[2ex] & \frac{1 \times 2 + 3 \times 4 + \cdots + n\left( n - 1 \right)}{2} = \frac{n\left( n + 2 \right)\left( 2n-1 \right)}{24} & \{n \mid n = 2m,m \in \rm N^* \} \end{aligned} \end{matrix}\right.推导一下。 先考虑 $n$ 是奇数的情况。 \begin{aligned} 原式&=\frac{2 \times 3 + 4 \times 5 + \cdots + n\left( n - 1 \right)}{2}\\[2ex] &= \frac{2^2 + 2 + 4^2 + 4 + \cdots + \left( n-1 \right)^2 + n - 1}{2}\\[2ex] &= \frac{\left( n + 1 \right)\left( n - 1 \right)}{8} + \frac{2^2 + 4^2 + \cdots + \left( n-1 \right)^2}{2}\\[2ex] &= \frac{\left( n + 1 \right)\left( n - 1 \right)}{8} + 2\left[ 1^2 + 2^2 + \cdots + \left( \frac{n - 1}{2} \right)^2 \right]\\[2ex] &= \frac{\left( n + 1 \right)\left( n - 1 \right)}{8} + \frac{2 \times \left( \frac{n-1}{2} \right) \times \left( \frac{n+1}{2}\right)\times n}{6}\\[2ex] &= \frac{\left( n + 1 \right)\left( n - 1 \right)}{8} + \frac{n\left( n + 1 \right)\left( n - 1\right)}{12}\\[2ex] &= \frac{3\left( n + 1 \right)\left( n - 1 \right) + 2n\left( n + 1 \right)\left( n - 1\right)}{24}\\[2ex] &= \frac{\left( n - 1 \right)\left( n + 1 \right)\left( 2n + 3 \right)}{24} \end{aligned}$n$ 为偶数也是同样的道理。 \begin{aligned} 原式&=\frac{1 \times 2 + 3 \times 4 + \cdots + n\left( n - 1 \right)}{2}\\[2ex] &= \frac{2^2 - 2 + 4^2 - 4 + \cdots + n^2 - n}{2}\\[2ex] &= \frac{2^2 + 4^2 + \cdots + n^2}{2} - \frac{n \left( n + 2 \right)}{8}\\[2ex] &= 2\left[ 1^2 + 2^2 + \cdots + \left( \frac{n}{2} \right)^2 \right] - \frac{n \left( n + 2 \right)}{8}\\[2ex] &= \frac{2 \times \left( \frac{n}{2} \right) \times \left( \frac{n+2}{2}\right)\times \left(n + 1 \right)}{6} - \frac{n \left( n + 2 \right)}{8}\\[2ex] &= \frac{n\left(n + 1 \right)\left( n + 2 \right)}{12} - \frac{n \left( n + 2 \right)}{8}\\[2ex] &= \frac{2n\left(n + 1 \right)\left( n + 2 \right) - 3n \left( n + 2 \right)}{24}\\[2ex] &= \frac{n\left( n + 2 \right)\left( 2n-1 \right)}{24} \end{aligned}把头朝上和头朝下的三角形加起来，得到 tot = \left\{\begin{matrix} \begin{aligned} & \frac{\left( n + 1 \right)\left( 2n^2 + 3n - 1 \right)}{8} & \{n \mid n = 2m + 1,m \in \rm N^* \}\\[2ex] & \frac{n\left( n + 2 \right)\left( 2n+1 \right)}{8} & \{n \mid n = 2m,m \in \rm N^* \} \end{aligned} \end{matrix}\right.这就是最后的答案，每次都可以 $O(1)$ 求了，总时间复杂度为 $O(T)$ 。 Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;int t, n;int main() &#123; for (read(t); t; --t) &#123; read(n); if (n &amp; 1) write((n + 1) * (2 * n * n + 3 * n - 1) / 8);//奇数 else write(n * (n + 2) * (2 * n + 1) / 8);//偶数 putchar('\n'); &#125; return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>数论数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2746」「USACO5.3」校园网Network of Schools]]></title>
    <url>%2Fproblems%2Fluogu-p2746%2F</url>
    <content type="text"><![CDATA[Description给定一个 $n$ 个点的有向图，求 $2$ 个问题： 如果一个点能覆盖所有与它连通的点，现在需要选择最少的点来覆盖所有的点。 最少增加几条边能使这个有向图变成 强连通分量 。 Source[Luogu]P2746 Solution先考虑第 $1$ 个问题。 一个 强连通分量 里的点可以互相到达，选择强连通分量里的任何一个点都能覆盖整个强连通分量，因此可以把它们缩成一个点。缩完点后图变成一个 DAG（有向无环图至少存在一个入度为 $0$ 的点），入度为 $0$ 的点是必须要选的，因为没有点能覆盖它们，而入度不为 $0$ 的点都能被其它点覆盖，所以问题就变为求入度为 $0$ 的点的个数。 再考虑第 $2$ 个问题。 因为原图中的 强连通分量 已经连通，所以没有必要在强连通分量内增加边，可以沿用上个问题缩点后的图。强连通分量 没有 出度为 $0$ 的点 和 入度为 $0$ 的点，所以我们现在需要连一些边，使该图中这些点的出度或入度增加。显然最优的方案是在 出度为 $0$ 的点 和 入度为 $0$ 的点 之间连一条边，一一匹配完后多出来的点与其它点连边，所以问题的答案就是 出度为 $0$ 的点数 和 入度为 $0$ 的点数 的较大值。如果原来的图本身就是一个强连通分量，新图将会是一个点，出度和入度为 $0$ 。若按照上述做法，答案将是 $1$，但实际答案是 $0$，所以需要特判这种情况。 两个问题的时间复杂度均为 $O(n)$ 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 100, MAXM = MAXN * MAXN;int n, tot, deep, top, cnt, in_0, out_0, head[MAXN + 5], dfn[MAXN + 5], low[MAXN + 5];int sta[MAXN + 5], col[MAXN + 5], in[MAXN + 5], out[MAXN + 5];struct Edge &#123; int next, to;&#125; e[MAXM + 5];inline void addEdge(int u, int v) &#123; e[++tot] = (Edge) &#123; head[u], v &#125;; head[u] = tot;&#125;void tarjan(int u) &#123; dfn[u] = low[u] = ++deep; sta[++top] = u; for (int v, i = head[u]; v = e[i].to, i; i = e[i].next) &#123; if (!dfn[v]) &#123; tarjan(v); low[u] = min(low[u], low[v]); &#125; else if (!col[v]) low[u] = min(low[u], dfn[v]); &#125; if (dfn[u] == low[u]) &#123; col[u] = ++cnt; for (; sta[top] != u; --top) col[sta[top]] = cnt; --top; &#125;&#125;int main() &#123; read(n); for (int x, i = 1; i &lt;= n; ++i) &#123; read(x); for (; x; read(x)) addEdge(i, x);//连有向边 &#125; for (int i = 1; i &lt;= n; ++i) if (!dfn[i]) tarjan(i);//缩点 for (int u = 1; u &lt;= n; ++u) for (int v, i = head[u]; v = e[i].to, i; i = e[i].next) if (col[u] != col[v])//如果不在同个强连通分量中，重新连边 ++out[col[u]], ++in[col[v]];//记录出度和入度 for (int i = 1; i &lt;= cnt; ++i) &#123; if (!in[i]) ++in_0; if (!out[i]) ++out_0; &#125;//统计入度为 0 的点和出度为 0 的点 write(in_0); putchar('\n'); write(cnt == 1 ? 0 : max(in_0, out_0));//特判是不是强连通分量 putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>图论</tag>
        <tag>缩点</tag>
        <tag>USACO</tag>
        <tag>IOI</tag>
        <tag>1996</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 1051」「HAOI2006」受欢迎的牛]]></title>
    <url>%2Fproblems%2Fbzoj-1051%2F</url>
    <content type="text"><![CDATA[Description给定 $n\ (1 \leq n \leq 10^4)$ 个点，$m\ (1 \leq m \leq 5 \times 10^4)$ 条边的有向图，求有多少点能够被所有点到达（不包括自己）。 Source[BZOJ]1051 Solution受欢迎的奶牛只有可能是出度为 $0$ 的强连通分量里的点。因为在同一个强连通分量里的所有点都是能互相到达的，所以 这个强连通分量外与它相连的点 不可能和 这个强连通分量内的点 互相到达，换句话说，如果某强连通分量内存在点 $u$，该强连通分量外某点 $v$ 与 $u$ 相连，那么边 $u \rightarrow v$ 和 $v \rightarrow u$ 只可能存在 $1$ 条，若存在边 $u \rightarrow v$（这个强连通分量的出度不为 $0$），则这个强连通分量里的点就不能被所有点到达（不存在边 $v \rightarrow u$，即 $v$ 不能到达 $u$）。如下图所示，共有 $4$ 个强连通分量，分别是 $\{a,b,c\},\{d\},\{f\},\{e,g,h\}$ 。出度为 $0$ 的强连通分量只有 $\{a,b,c\}$，这个强连通分量里的所有点都与除自己外的其它点连通。 如果存在 $2$ 个及以上出度为 $0$ 的强连通分量呢（如下图）？很显然 $\{a,b,c\},\{e,g,h\}$ 这 $2$ 个强连通分量内的点彼此都不能到达，所以没有符合题意的答案。 因此跑一边 $\rm tarjan$ 缩点，把图变成一个 DAG（有向无环图至少存在一个出度为 0 的点），再统计每个强连通分量的出度，如果只存在一个出度为 $0$ 的强连通分量，那么答案就是这个强连通分量点的个数，否则答案为 $0$ 。时间复杂度为 $O(n)$ 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1e4, MAXM = 5e4;int n, m, top, cnt, tot, deep, sol, ans, head[MAXN + 5], dfn[MAXN + 5], low[MAXN + 5], sta[MAXN + 5], col[MAXN + 5], size[MAXN + 5], out[MAXN + 5];struct Edge &#123; int next, to;&#125; e[(MAXM &lt;&lt; 1) + 5];inline void addEdge(int u, int v) &#123; e[++tot] = (Edge) &#123; head[u], v &#125;; head[u] = tot;&#125;void tarjan(int u) &#123; dfn[u] = low[u] = ++deep; sta[++top] = u; for (int v, i = head[u]; v = e[i].to, i; i = e[i].next) &#123; if (!dfn[v]) &#123; tarjan(v); low[u] = min(low[u], low[v]); &#125; else if (!col[v]) low[u] = min(low[u], dfn[v]); &#125; if (dfn[u] == low[u]) &#123; col[u] = ++cnt; for (; sta[top] != u; --top) col[sta[top]] = cnt; --top; &#125;&#125;int main() &#123; read(n), read(m); for (int u, v, i = 1; i &lt;= m; ++i) &#123; read(u), read(v); addEdge(u, v);//有向边 &#125; for (int i = 1; i &lt;= n; ++i) if (!dfn[i]) tarjan(i);//缩点 for (int u = 1; u &lt;= n; ++u) &#123; ++size[col[u]];//统计每个强连通分量的大小 for (int v, i = head[u]; v = e[i].to, i; i = e[i].next) if (col[u] != col[v])//不在同一个强连通分量内 ++out[col[u]];//统计每个强连通分量的出度 &#125; for (int i = 1; i &lt;= cnt &amp;&amp; sol &lt; 2; ++i) if (!out[i]) &#123; ans = size[i];//答案为该强连通分量的大小 ++sol;//出度为 0 的强连通分量个数 &#125; write(sol &gt; 1 ? 0 : ans);//如果不止 1 个，则无解 putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>HAOI</tag>
        <tag>2006</tag>
        <tag>缩点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2341」「HAOI2006」受欢迎的牛]]></title>
    <url>%2Fproblems%2Fluogu-p2341%2F</url>
    <content type="text"><![CDATA[Description给定 $n\ (1 \leq n \leq 10^4)$ 个点，$m\ (1 \leq m \leq 5 \times 10^4)$ 条边的有向图，求有多少点能够被所有点到达（不包括自己）。 Source[Luogu]P2341 Solution受欢迎的奶牛只有可能是出度为 $0$ 的强连通分量里的点。因为在同一个强连通分量里的所有点都是能互相到达的，所以 这个强连通分量外与它相连的点 不可能和 这个强连通分量内的点 互相到达，换句话说，如果某强连通分量内存在点 $u$，该强连通分量外某点 $v$ 与 $u$ 相连，那么边 $u \rightarrow v$ 和 $v \rightarrow u$ 只可能存在 $1$ 条，若存在边 $u \rightarrow v$（这个强连通分量的出度不为 $0$），则这个强连通分量里的点就不能被所有点到达（不存在边 $v \rightarrow u$，即 $v$ 不能到达 $u$）。如下图所示，共有 $4$ 个强连通分量，分别是 $\{a,b,c\},\{d\},\{f\},\{e,g,h\}$ 。出度为 $0$ 的强连通分量只有 $\{a,b,c\}$，这个强连通分量里的所有点都与除自己外的其它点连通。 如果存在 $2$ 个及以上出度为 $0$ 的强连通分量呢（如下图）？很显然 $\{a,b,c\},\{e,g,h\}$ 这 $2$ 个强连通分量内的点彼此都不能到达，所以没有符合题意的答案。 因此跑一边 $\rm tarjan$ 缩点，把图变成一个 DAG（有向无环图至少存在一个出度为 0 的点），再统计每个强连通分量的出度，如果只存在一个出度为 $0$ 的强连通分量，那么答案就是这个强连通分量点的个数，否则答案为 $0$ 。时间复杂度为 $O(n)$ 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1e4, MAXM = 5e4;int n, m, top, cnt, tot, deep, sol, ans, head[MAXN + 5], dfn[MAXN + 5], low[MAXN + 5], sta[MAXN + 5], col[MAXN + 5], size[MAXN + 5], out[MAXN + 5];struct Edge &#123; int next, to;&#125; e[(MAXM &lt;&lt; 1) + 5];inline void addEdge(int u, int v) &#123; e[++tot] = (Edge) &#123; head[u], v &#125;; head[u] = tot;&#125;void tarjan(int u) &#123; dfn[u] = low[u] = ++deep; sta[++top] = u; for (int v, i = head[u]; v = e[i].to, i; i = e[i].next) &#123; if (!dfn[v]) &#123; tarjan(v); low[u] = min(low[u], low[v]); &#125; else if (!col[v]) low[u] = min(low[u], dfn[v]); &#125; if (dfn[u] == low[u]) &#123; col[u] = ++cnt; for (; sta[top] != u; --top) col[sta[top]] = cnt; --top; &#125;&#125;int main() &#123; read(n), read(m); for (int u, v, i = 1; i &lt;= m; ++i) &#123; read(u), read(v); addEdge(u, v);//有向边 &#125; for (int i = 1; i &lt;= n; ++i) if (!dfn[i]) tarjan(i);//缩点 for (int u = 1; u &lt;= n; ++u) &#123; ++size[col[u]];//统计每个强连通分量的大小 for (int v, i = head[u]; v = e[i].to, i; i = e[i].next) if (col[u] != col[v])//不在同一个强连通分量内 ++out[col[u]];//统计每个强连通分量的出度 &#125; for (int i = 1; i &lt;= cnt &amp;&amp; sol &lt; 2; ++i) if (!out[i]) &#123; ans = size[i];//答案为该强连通分量的大小 ++sol;//出度为 0 的强连通分量个数 &#125; write(sol &gt; 1 ? 0 : ans);//如果不止 1 个，则无解 putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>图论</tag>
        <tag>HAOI</tag>
        <tag>2006</tag>
        <tag>缩点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 4521」「CQOI2016」手机号码]]></title>
    <url>%2Fproblems%2Fbzoj-4521%2F</url>
    <content type="text"><![CDATA[Description现在需要找一些 $11$ 位的手机号码（不含前导零），要出现至少 $3$ 个相邻的相同数字，且不能同时出现 $4$ 和 $8$ 。问区间 $[l,r]\ (10^{10} \leq l \leq r &lt; 10^{11})$ 中有多少符合上述条件的手机号码。 Source[BZOJ]4521 Solution考虑用 记忆化搜索 实现 数位DP 。 用 $f_{pos,pre1,pre2,four,eight,isThree}$ 表示 当前到了第 $12 - pos$ 位，前一位数是 $pre1$，前一位数的前一位数是 $pre2$，是否存在 $4$，是否存在 $8$，是否存在 $3$ 位数连续 的电话号码个数。因为固定 $11$ 位，只需要保证第 $1$ 位非零，所以不需要判断前导零。还有一个细节，当 $l = 10^{10}$ 时，$l - 1$ 会变成 $10$ 位数，显然不符合题意，这时计算就会出错，所以需要特判。具体实现详见代码，时间复杂度为 $O(\lg^3n)$ 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 11;LL l, r, f[MAXN + 5][MAXN + 5][MAXN + 5][2][2][2];inline LL dfs(int *num, int pos, int pre1, int pre2, bool four, bool eight, bool isThree, bool lim) &#123; //当前到了第 12 - pos 位，前一位数是 pre1，前一位数的前一位数是 pre2， //four 表示是否出现过 4，eight 表示是否出现过 8，isThree 表示是否有 3 位数连续，lim 表示当前位是否受限制 //固定 11 位，不需要判断前导零，只需要保证开头（第 1 位）不为 0 if (four &amp;&amp; eight) return 0;//不能同时有 4 和 8 if (!pos) return isThree;//搜完了，如果有三个以上连续的，返回 1 if (!lim &amp;&amp; ~f[pos][pre1][pre2][four][eight][isThree]) return f[pos][pre1][pre2][four][eight][isThree];//返回已记录的值 LL res = 0, maxNum = lim ? num[pos] : 9;//当前位最大值 for (int i = (pos == 11); i &lt;= maxNum; ++i)//第一位不能为 0 res += dfs(num, pos - 1, i, pre1, four || (i == 4), eight || (i == 8), isThree || (pre1 == pre2 &amp;&amp; i == pre2), lim &amp;&amp; (i == maxNum)); //搜索下一位，判断是否有 4，是否有 8 以及 是否存在 3 个数连续 if (!lim) f[pos][pre1][pre2][four][eight][isThree] = res;//存下当前状态的值 return res;&#125;inline LL solve(LL x) &#123; int len = 0, num[MAXN + 5]; for (; x; x /= 10) num[++len] = x % 10; memset(f, -1, sizeof (f));//初始化 return len == 11 ? dfs(num, len, 10, 10, 0, 0, 0, 1) : 0;//特判长度是否为 11 //第 1 位受到限制。前 2 位不能为 0 ~ 9，否则会影响检查是否存在 3 位数连续&#125;int main() &#123; read(l), read(r); write(solve(r) - solve(l - 1)); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>动态规划</tag>
        <tag>搜索</tag>
        <tag>数位DP</tag>
        <tag>CQOI</tag>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P4124」「CQOI2016」手机号码]]></title>
    <url>%2Fproblems%2Fluogu-p4124%2F</url>
    <content type="text"><![CDATA[Description现在需要找一些 $11$ 位的手机号码（不含前导零），要出现至少 $3$ 个相邻的相同数字，且不能同时出现 $4$ 和 $8$ 。问区间 $[l,r]\ (10^{10} \leq l \leq r &lt; 10^{11})$ 中有多少符合上述条件的手机号码。 Source[Luogu]P4124 Solution考虑用 记忆化搜索 实现 数位DP 。 用 $f_{pos,pre1,pre2,four,eight,isThree}$ 表示 当前到了第 $12 - pos$ 位，前一位数是 $pre1$，前一位数的前一位数是 $pre2$，是否存在 $4$，是否存在 $8$，是否存在 $3$ 位数连续 的电话号码个数。因为固定 $11$ 位，只需要保证第 $1$ 位非零，所以不需要判断前导零。还有一个细节，当 $l = 10^{10}$ 时，$l - 1$ 会变成 $10$ 位数，显然不符合题意，这时计算就会出错，所以需要特判。具体实现详见代码，时间复杂度为 $O(\lg^3n)$ 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 11;LL l, r, f[MAXN + 5][MAXN + 5][MAXN + 5][2][2][2];inline LL dfs(int *num, int pos, int pre1, int pre2, bool four, bool eight, bool isThree, bool lim) &#123; //当前到了第 12 - pos 位，前一位数是 pre1，前一位数的前一位数是 pre2， //four 表示是否出现过 4，eight 表示是否出现过 8，isThree 表示是否有 3 位数连续，lim 表示当前位是否受限制 //固定 11 位，不需要判断前导零，只需要保证开头（第 1 位）不为 0 if (four &amp;&amp; eight) return 0;//不能同时有 4 和 8 if (!pos) return isThree;//搜完了，如果有三个以上连续的，返回 1 if (!lim &amp;&amp; ~f[pos][pre1][pre2][four][eight][isThree]) return f[pos][pre1][pre2][four][eight][isThree];//返回已记录的值 LL res = 0, maxNum = lim ? num[pos] : 9;//当前位最大值 for (int i = (pos == 11); i &lt;= maxNum; ++i)//第一位不能为 0 res += dfs(num, pos - 1, i, pre1, four || (i == 4), eight || (i == 8), isThree || (pre1 == pre2 &amp;&amp; i == pre2), lim &amp;&amp; (i == maxNum)); //搜索下一位，判断是否有 4，是否有 8 以及 是否存在 3 个数连续 if (!lim) f[pos][pre1][pre2][four][eight][isThree] = res;//存下当前状态的值 return res;&#125;inline LL solve(LL x) &#123; int len = 0, num[MAXN + 5]; for (; x; x /= 10) num[++len] = x % 10; memset(f, -1, sizeof (f));//初始化 return len == 11 ? dfs(num, len, 10, 10, 0, 0, 0, 1) : 0;//特判长度是否为 11 //第 1 位受到限制。前 2 位不能为 0 ~ 9，否则会影响检查是否存在 3 位数连续&#125;int main() &#123; read(l), read(r); write(solve(r) - solve(l - 1)); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>动态规划</tag>
        <tag>搜索</tag>
        <tag>数位DP</tag>
        <tag>CQOI</tag>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 1833」「ZJOI2010」count 数字计数]]></title>
    <url>%2Fproblems%2Fbzoj-1833%2F</url>
    <content type="text"><![CDATA[Description给定两个正整数 $l,r\ (1 \leq l \leq r \leq 10^{12})$，求区间 $[l,r]$ 里的所有整数中，每个数码 $0 \sim 9$ 各出现了几次。 Source[BZOJ]1833 Solution考虑 数位DP 。 用 $f_{pos,cnt}$ 表示当前到了第 $len - pos + 1$ 位，有 $cnt$ 个数码 $digit$ 的数中，共有多少个数码 $digit$ 。 分别计算 $0 \sim 9$ 每一个数码，注意判前导零（前导零不算数码 $0$），具体实现详见代码。时间复杂度为 $O(10\lg^2n)$ 。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 12;LL l, r, f[MAXN + 5][MAXN + 5];LL dfs(int *num, int pos, LL cnt, int digit, bool lead, bool lim) &#123; //pos 表示当前是第 len - pos + 1 位，cnt 表示前 len - pos + 1 位中数码 digit 的数量， //digit 表示当前要求的数码，lead 表示是否有前导零，lim 表示当前数位是否受到限制 if (!pos) return cnt;//若搜完最后一位，则返回数码数量 if (!lead &amp;&amp; !lim &amp;&amp; ~f[pos][cnt]) return f[pos][cnt];//返回已记录的值 LL res = 0; int maxNum = lim ? num[pos] : 9;//当前数位最大值 for (int i = 0; i &lt;= maxNum; ++i) res += dfs(num, pos - 1, cnt + ((i == digit) &amp;&amp; !(lead &amp;&amp; !i)), digit, lead &amp;&amp; !i, lim &amp;&amp; i == maxNum); //查找下一位。如果第 i 位的数码是所要求的数码，且该数码不是前导零，那么统计数量 + 1 if (!lead &amp;&amp; !lim) f[pos][cnt] = res;//记录该状态的值 return res;&#125;inline LL solve(LL x, int digit) &#123; if (x &lt; 0) return 0;//l = 0 时 x = -1，特判 int len = 0, num[MAXN + 5]; for (; x; x /= 10) num[++len] = x % 10; memset(f, -1, sizeof (f));//初始化 return dfs(num, len, 0, digit, 1, 1);//注意第一位算 有前导零 且 数位受限制 &#125;int main() &#123; read(l), read(r); for (int i = 0; i &lt;= 9; ++i) &#123; write(solve(r, i) - solve(l - 1, i)); putchar(' '); &#125; putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>动态规划</tag>
        <tag>2010</tag>
        <tag>搜索</tag>
        <tag>数位DP</tag>
        <tag>ZJOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2602」「ZJOI2010」数字计数]]></title>
    <url>%2Fproblems%2Fluogu-p2602%2F</url>
    <content type="text"><![CDATA[Description给定两个正整数 $l,r\ (1 \leq l \leq r \leq 10^{12})$，求区间 $[l,r]$ 里的所有整数中，每个数码 $0 \sim 9$ 各出现了几次。 Source[Luogu]P2602 Solution考虑 数位DP 。 用 $f_{pos,cnt}$ 表示当前到了第 $len - pos + 1$ 位，有 $cnt$ 个数码 $digit$ 的数中，共有多少个数码 $digit$ 。 分别计算 $0 \sim 9$ 每一个数码，注意判前导零（前导零不算数码 $0$），具体实现详见代码。时间复杂度为 $O(10\lg^2n)$ 。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 12;LL l, r, f[MAXN + 5][MAXN + 5];LL dfs(int *num, int pos, LL cnt, int digit, bool lead, bool lim) &#123; //pos 表示当前是第 len - pos + 1 位，cnt 表示前 len - pos + 1 位中数码 digit 的数量， //digit 表示当前要求的数码，lead 表示是否有前导零，lim 表示当前数位是否受到限制 if (!pos) return cnt;//若搜完最后一位，则返回数码数量 if (!lead &amp;&amp; !lim &amp;&amp; ~f[pos][cnt]) return f[pos][cnt];//返回已记录的值 LL res = 0; int maxNum = lim ? num[pos] : 9;//当前数位最大值 for (int i = 0; i &lt;= maxNum; ++i) res += dfs(num, pos - 1, cnt + ((i == digit) &amp;&amp; !(lead &amp;&amp; !i)), digit, lead &amp;&amp; !i, lim &amp;&amp; i == maxNum); //查找下一位。如果第 i 位的数码是所要求的数码，且该数码不是前导零，那么统计数量 + 1 if (!lead &amp;&amp; !lim) f[pos][cnt] = res;//记录该状态的值 return res;&#125;inline LL solve(LL x, int digit) &#123; if (x &lt; 0) return 0;//l = 0 时 x = -1，特判 int len = 0, num[MAXN + 5]; for (; x; x /= 10) num[++len] = x % 10; memset(f, -1, sizeof (f));//初始化 return dfs(num, len, 0, digit, 1, 1);//注意第一位算 有前导零 且 数位受限制 &#125;int main() &#123; read(l), read(r); for (int i = 0; i &lt;= 9; ++i) &#123; write(solve(r, i) - solve(l - 1, i)); putchar(' '); &#125; putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>动态规划</tag>
        <tag>2010</tag>
        <tag>搜索</tag>
        <tag>数位DP</tag>
        <tag>ZJOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 1799」「AHOI2009」self 同类分布]]></title>
    <url>%2Fproblems%2Fbzoj-1799%2F</url>
    <content type="text"><![CDATA[Description给定 $l$ 和 $r\ \left( 1 \leq l \leq r \leq 10^{18} \right)$，求区间 $[l,r]$ 中各位数字之和能整除原数的数的个数。 Source[BZOJ]1799 Solution考虑 数位DP 。 用 $f_{pos,sum,now}$ 表示当前到了第 $len - pos + 1$ 位，这些数位的和是 $sum$，模 $mod$ 的值为 $now$ 的数的个数。 可以枚举 所有数位的和 的值，这个值显然不会超过 $9\lg n$（这个值在每一位都是 $9$ 时最大）。我们把这个值当做模数 $mod$，当前数每增加一位时，我们统计各个数位的和 $sum$，并将新的数对 $mod$ 取模。当搜到最后一位时，如果模数为 $0$，那么满足条件整除；如果 $sum = mod$，那么满足 此时所有数位的和 = 枚举的所有数位的和 。如果上述两个条件都满足，则说明这个数符合题意。同时因为只需要统计 各个数位和 以及 数对 $mod$ 取模的值，所以不需要判前导零。具体实现过程详见代码，时间复杂度为 $O(9^3n\lg^3 n)$ 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 18, MAXM = MAXN * 9;LL l, r, f[MAXN + 5][MAXM + 5][MAXM + 5];LL dfs(int *num, int pos, int sum, int now, int mod, bool lim) &#123; //pos 表示当前是第 len - pos + 1 位，sum 表示此时所有数位的和， //now 表示当前的数对 mod 取模后的值，mod 表示枚举的所有数位的和，lim 表示当前数位是否受到限制 if (!pos) return !now &amp;&amp; sum == mod;//如果 能够整除 且 此时所有数位的和 = 枚举的所有数位的和，返回 1 if (!lim &amp;&amp; ~f[pos][sum][now]) return f[pos][sum][now];//返回已记录的值 LL res = 0; int maxNum = lim ? num[pos] : 9;//当前数位最大值 for (int i = 0; i &lt;= maxNum; ++i) res += dfs(num, pos - 1, sum + i, (now * 10 + i) % mod, mod, lim &amp;&amp; i == maxNum);//查找下一位 if (!lim) f[pos][sum][now] = res;//记录该状态的值 return res;&#125;inline LL solve(LL x) &#123; int len = 0, num[MAXN + 5]; for (; x; x /= 10) num[++len] = x % 10; LL res = 0; for (int i = 1; i &lt;= 9 * len; ++i) &#123;//枚举所有数位的和，最大不会超过 9 * 数位长度（每一位都是 9） memset(f, -1, sizeof (f));//初始化 res += dfs(num, len, 0, 0, i, 1);//设所有数位的和为 i，累加答案，且注意第一位会受限 &#125; return res;&#125;int main() &#123; read(l), read(r); write(solve(r) - solve(l - 1)); putchar('\n'); return 0;&#125; ​]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>2009</tag>
        <tag>动态规划</tag>
        <tag>搜索</tag>
        <tag>数位DP</tag>
        <tag>AHOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P4127」「AHOI2009」同类分布]]></title>
    <url>%2Fproblems%2Fluogu-p4127%2F</url>
    <content type="text"><![CDATA[Description给定 $l$ 和 $r\ \left( 1 \leq l \leq r \leq 10^{18} \right)$，求区间 $[l,r]$ 中各位数字之和能整除原数的数的个数。 Source[Luogu]P4127 Solution考虑 数位DP 。 用 $f_{pos,sum,now}$ 表示当前到了第 $len - pos + 1$ 位，这些数位的和是 $sum$，模 $mod$ 的值为 $now$ 的数的个数。 可以枚举 所有数位的和 的值，这个值显然不会超过 $9\lg n$（这个值在每一位都是 $9$ 时最大）。我们把这个值当做模数 $mod$，当前数每增加一位时，我们统计各个数位的和 $sum$，并将新的数对 $mod$ 取模。当搜到最后一位时，如果模数为 $0$，那么满足条件整除；如果 $sum = mod$，那么满足 此时所有数位的和 = 枚举的所有数位的和 。如果上述两个条件都满足，则说明这个数符合题意。同时因为只需要统计 各个数位和 以及 数对 $mod$ 取模的值，所以不需要判前导零。具体实现过程详见代码，时间复杂度为 $O(9^3n\lg^3 n)$ 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 18, MAXM = MAXN * 9;LL l, r, f[MAXN + 5][MAXM + 5][MAXM + 5];LL dfs(int *num, int pos, int sum, int now, int mod, bool lim) &#123; //pos 表示当前是第 len - pos + 1 位，sum 表示此时所有数位的和， //now 表示当前的数对 mod 取模后的值，mod 表示枚举的所有数位的和，lim 表示当前数位是否受到限制 if (!pos) return !now &amp;&amp; sum == mod;//如果 能够整除 且 此时所有数位的和 = 枚举的所有数位的和，返回 1 if (!lim &amp;&amp; ~f[pos][sum][now]) return f[pos][sum][now];//返回已记录的值 LL res = 0; int maxNum = lim ? num[pos] : 9;//当前数位最大值 for (int i = 0; i &lt;= maxNum; ++i) res += dfs(num, pos - 1, sum + i, (now * 10 + i) % mod, mod, lim &amp;&amp; i == maxNum);//查找下一位 if (!lim) f[pos][sum][now] = res;//记录该状态的值 return res;&#125;inline LL solve(LL x) &#123; int len = 0, num[MAXN + 5]; for (; x; x /= 10) num[++len] = x % 10; LL res = 0; for (int i = 1; i &lt;= 9 * len; ++i) &#123;//枚举所有数位的和，最大不会超过 9 * 数位长度（每一位都是 9） memset(f, -1, sizeof (f));//初始化 res += dfs(num, len, 0, 0, i, 1);//设所有数位的和为 i，累加答案，且注意第一位会受限 &#125; return res;&#125;int main() &#123; read(l), read(r); write(solve(r) - solve(l - 1)); putchar('\n'); return 0;&#125; ​]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>2009</tag>
        <tag>动态规划</tag>
        <tag>搜索</tag>
        <tag>数位DP</tag>
        <tag>AHOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 1026」「SCOI2009」windy数]]></title>
    <url>%2Fproblems%2Fbzoj-1026%2F</url>
    <content type="text"><![CDATA[Description给定 $l$ 和 $r\ \left( 1 \leq l \leq r \leq 2 \times 10^9 \right)$，求区间 $[l,r]$ 有多少个 不含前导零且相邻两个数字之差至少为 $2$ 的正整数（即 $\rm{windy}$ 数）。 Source[BZOJ]1026 Solution数位DP 入门题。 用 $f_{pos,pre}$ 表示当前到了第 $len - pos + 1$ 位，上一位是 $pre$ 的 $\rm{windy}$ 数个数。 考虑用 记忆化搜索 实现 数位DP 。枚举每一位，保证当前位与上一位的差大于等于 $2$ 。注意判断是否有前导零，如果有或者刚开始搜，就把上一位设为 $11$（因为 $0 \sim 9$ 与 $11$ 的差都大于等于 $2$，保证下一位没有限制），具体实现详见代码。时间复杂度为 $O(\lg^2 n)$ 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 10;int l, r, f[MAXN + 5][MAXN + 5];int dfs(int *num, int pos, int pre, bool lead, bool lim) &#123; //pos 表示当前是第 len - pos + 1 位，pre 表示上一个数，lead 表示是否有前导零，lim 表示当前数位是否受到限制 if (!pos) return 1;//搜完了 if (!lim &amp;&amp; !lead &amp;&amp; ~f[pos][pre]) return f[pos][pre];//返回该状态已记录的值 int res = 0, maxNum = lim ? num[pos] : 9;//如果有限制，当前位则为 0 ~ 当前位的值，否则为 0 ~ 9 for (int i = 0; i &lt;= maxNum; ++i) &#123; if (abs(i - pre) &lt; 2) continue;//相邻数位之差不能小于 2（题目要求） if (lead &amp;&amp; !i) res += dfs(num, pos - 1, 11, 1, lim &amp;&amp; i == maxNum);//如果前面全是前导零，第一位仍设为 11 else res += dfs(num, pos - 1, i, 0, lim &amp;&amp; i == maxNum);//否则设当前位为 i，枚举下一位 &#125; if (!lim &amp;&amp; !lead) f[pos][pre] = res;//如果没有前导 0 且 最高位无限制，则存下这个状态的值 return res;&#125;//记忆化搜索 实现 数位DP inline int solve(int x) &#123; int len = 0, num[MAXN + 5]; for (; x; x /= 10) num[++len] = x % 10; memset(f, -1, sizeof (f));//初始化为 -1 return dfs(num, len, 11, 1, 1);//从 11 开始可以保证数字第一位没有限制 &#125;int main() &#123; read(l), read(r); write(solve(r) - solve(l - 1)); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>2009</tag>
        <tag>动态规划</tag>
        <tag>SCOI</tag>
        <tag>搜索</tag>
        <tag>数位DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2657」「SCOI2009」windy数]]></title>
    <url>%2Fproblems%2Fluogu-p2657%2F</url>
    <content type="text"><![CDATA[Description给定 $l$ 和 $r\ \left( 1 \leq l \leq r \leq 2 \times 10^9 \right)$，求区间 $[l,r]$ 有多少个 不含前导零且相邻两个数字之差至少为 $2$ 的正整数（即 $\rm{windy}$ 数）。 Source[Luogu]P2657 Solution数位DP 入门题。 用 $f_{pos,pre}$ 表示当前到了第 $len - pos + 1$ 位，上一位是 $pre$ 的 $\rm{windy}$ 数个数。 考虑用 记忆化搜索 实现 数位DP 。枚举每一位，保证当前位与上一位的差大于等于 $2$ 。注意判断是否有前导零，如果有或者刚开始搜，就把上一位设为 $11$（因为 $0 \sim 9$ 与 $11$ 的差都大于等于 $2$，保证下一位没有限制），具体实现详见代码。时间复杂度为 $O(\lg^2 n)$ 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 10;int l, r, f[MAXN + 5][MAXN + 5];int dfs(int *num, int pos, int pre, bool lead, bool lim) &#123; //pos 表示当前是第 len - pos + 1 位，pre 表示上一个数，lead 表示是否有前导零，lim 表示当前数位是否受到限制 if (!pos) return 1;//搜完了 if (!lim &amp;&amp; !lead &amp;&amp; ~f[pos][pre]) return f[pos][pre];//返回该状态已记录的值 int res = 0, maxNum = lim ? num[pos] : 9;//如果有限制，当前位则为 0 ~ 当前位的值，否则为 0 ~ 9 for (int i = 0; i &lt;= maxNum; ++i) &#123; if (abs(i - pre) &lt; 2) continue;//相邻数位之差不能小于 2（题目要求） if (lead &amp;&amp; !i) res += dfs(num, pos - 1, 11, 1, lim &amp;&amp; i == maxNum);//如果前面全是前导零，第一位仍设为 11 else res += dfs(num, pos - 1, i, 0, lim &amp;&amp; i == maxNum);//否则设当前位为 i，枚举下一位 &#125; if (!lim &amp;&amp; !lead) f[pos][pre] = res;//如果没有前导 0 且 最高位无限制，则存下这个状态的值 return res;&#125;//记忆化搜索 实现 数位DP inline int solve(int x) &#123; int len = 0, num[MAXN + 5]; for (; x; x /= 10) num[++len] = x % 10; memset(f, -1, sizeof (f));//初始化为 -1 return dfs(num, len, 11, 1, 1);//从 11 开始可以保证数字第一位没有限制 &#125;int main() &#123; read(l), read(r); write(solve(r) - solve(l - 1)); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>2009</tag>
        <tag>动态规划</tag>
        <tag>SCOI</tag>
        <tag>搜索</tag>
        <tag>数位DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 1087」「SCOI2005」互不侵犯King]]></title>
    <url>%2Fproblems%2Fbzoj-1087%2F</url>
    <content type="text"><![CDATA[Description在 $n \times n\ (1 \leq n \leq 9)$ 的棋盘上放置 $m\ (0 \leq m \leq n \times n)$ 个国王，每个国王都能攻击周围的 $8$ 个格子，求使它们无法互相攻击的方案数。 Source[BZOJ]1087 Solution状压DP 入门题，当然也可以打表（滑稽 如何 状态压缩？ 考虑把每一行的状态用一个 二进制数 来表示。若这个数的某一位为 $1$，则代表这个位置上放了国王，$0$ 反之。 状态： 用 $f_{i,j,k}$ 表示第 $i$ 行是第 $j$ 个状态，前 $i$ 行（包括第 $i$ 行）共放了 $k$ 个国王的方案数。 初始： \large {\begin{aligned} & f_{1,i,cnt_i} = 1 && \left( 当且仅当第\ i\ 个状态合法 \right) \end{aligned}}其中 $cnt_i$ 表示第 $i$ 个状态国王的个数。若在第 $1$ 行状态合法，则此状态的方案数为 $1$ 。 转移： \large {\begin{aligned} & f_{i,k,l} = f_{i, k, l} + f_{i - 1, j, l - cnt_k} & \left( cnt_k \leq l \leq m \right) \end{aligned}}其中 $cnt_k$ 表示第 $k$ 个状态国王的个数。若第 $i - 1$ 行是 第 $j$ 个状态，第 $i$ 行是 第 $k$ 个状态，枚举 第 $j$ 个状态 和 第 $k$ 个状态，如果这两个状态合法，且 第 $k$ 个状态 能够放在 第 $j$ 个状态 的下一行（两个状态的国王保持和平），就可以转移。假设在前 $i$ 行共放了 $l$ 个国王，那么前 $i - 1$ 行就放了 $l - cnt_k$ 个国王，显然这个方案是成立的，所以累加更新这个状态的方案数。 怎么判断 两个状态合法 且 上下两行国王和平 呢？这就要用到 状态压缩 时常用的位运算了。 若第 $i$ 个状态为 $state_i$，且 $state_i\&amp; \left( state_i &lt;&lt; 1 \right) &gt; 0$，则说明存在相邻的国王互相攻击，该行状态不合法。 若第 $i$ 个状态为 $state_i$，第 $j$ 个状态为 $state_j$，且 $state_i\&amp; state_j &gt; 0 $，则说明存在上下国王互相攻击。 若第 $i$ 个状态为 $state_i$，第 $j$ 个状态为 $state_j$，且 $state_i\&amp; \left(state_j &lt;&lt; 1\right) &gt; 0$，则说明存在左上与右下的国王互相攻击。 若第 $i$ 个状态为 $state_i$，第 $j$ 个状态为 $state_j$，且 $\left(state_i &lt;&lt; 1\right) \&amp; state_j &gt; 0$，则说明存在右上与左下的国王互相攻击。 答案： \large { \sum\limits_{i=1}^{tot} f_{n,i,m} }其中 $tot$ 表示合法的状态总数。答案即为：最后一行状态合法，前 $n$ 行共放了 $m$ 个国王的方案数总和。 一行里所有的状态共 $2^n$ 个（考虑每一位是 $0$ 还是 $1$），所以时间复杂度为 $O(nm2^{2n})$，可能会超时。但很容易发现，在一行里有很多状态本来就是不合法的，比如 $n = 4$ 时 $0110$ 这个状态，实际有用的状态远不及 $2^n$ 个。因此我们考虑先用搜索预处理出所有合法的状态，再进行转移，这样效率能高很多。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 9, MAXM = 1 &lt;&lt; 9;//2的9次方 int n, m, tot, state[MAXM + 5], cnt[MAXM + 5];LL ans, f[MAXN + 5][MAXM + 5][MAXN * MAXN + 5];void dfs(int x, int now, int king, bool pre) &#123; //x 表示已经搜到第 x 位，now 表示当前状态，king 表示当前国王数量（1 的数量），pre 表示上一位是什么 if (king &gt; m) return;//国王数不能超过 m if (x &gt; n) &#123; state[++tot] = now; cnt[tot] = king;//存下 这个状态 和 这个状态对应国王的数量 return; &#125; if (!pre) dfs(x + 1, now &lt;&lt; 1 | 1, king + 1, 1);//把 now 的第 x 位变成 1 //如果上一位是 1，显然这一位不能放 1 dfs(x + 1, now &lt;&lt; 1, king, 0);//把 now 的第 x 位变成 0&#125;int main() &#123; read(n), read(m); dfs(1, 0, 0, 0);//预处理一行里的合法状态 for (int i = 1; i &lt;= tot; ++i) f[1][i][cnt[i]] = 1;//初始 for (int i = 2; i &lt;= n; ++i) for (int j = 1; j &lt;= tot; ++j) for (int k = 1; k &lt;= tot; ++k) &#123; if ((state[j] &amp; state[k]) || ((state[j] &lt;&lt; 1) &amp; state[k]) || (state[j] &amp; (state[k] &lt;&lt; 1))) continue; //判断第 k 个状态放在第 j 个状态下面一行是否合法，且不需要考虑同一行国王相邻的情况 for (int l = cnt[k]; l &lt;= m; ++l) f[i][k][l] += f[i - 1][j][l - cnt[k]];//转移 &#125; for (int i = 1; i &lt;= tot; ++i) ans += f[n][i][m];//累加放完第 n 行，共 m 个国王的所有状态 write(ans); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>动态规划</tag>
        <tag>SCOI</tag>
        <tag>2005</tag>
        <tag>搜索</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P1896」「SCOI2005」互不侵犯]]></title>
    <url>%2Fproblems%2Fluogu-p1896%2F</url>
    <content type="text"><![CDATA[Description在 $n \times n\ (1 \leq n \leq 9)$ 的棋盘上放置 $m\ (0 \leq m \leq n \times n)$ 个国王，每个国王都能攻击周围的 $8$ 个格子，求使它们无法互相攻击的方案数。 Source[Luogu]P1896 Solution状压DP 入门题，当然也可以打表（滑稽 如何 状态压缩？ 考虑把每一行的状态用一个 二进制数 来表示。若这个数的某一位为 $1$，则代表这个位置上放了国王，$0$ 反之。 状态： 用 $f_{i,j,k}$ 表示第 $i$ 行是第 $j$ 个状态，前 $i$ 行（包括第 $i$ 行）共放了 $k$ 个国王的方案数。 初始： \large {\begin{aligned} & f_{1,i,cnt_i} = 1 && \left( 当且仅当第\ i\ 个状态合法 \right) \end{aligned}}其中 $cnt_i$ 表示第 $i$ 个状态国王的个数。若在第 $1$ 行状态合法，则此状态的方案数为 $1$ 。 转移： \large {\begin{aligned} & f_{i,k,l} = f_{i, k, l} + f_{i - 1, j, l - cnt_k} & \left( cnt_k \leq l \leq m \right) \end{aligned}}其中 $cnt_k$ 表示第 $k$ 个状态国王的个数。若第 $i - 1$ 行是 第 $j$ 个状态，第 $i$ 行是 第 $k$ 个状态，枚举 第 $j$ 个状态 和 第 $k$ 个状态，如果这两个状态合法，且 第 $k$ 个状态 能够放在 第 $j$ 个状态 的下一行（两个状态的国王保持和平），就可以转移。假设在前 $i$ 行共放了 $l$ 个国王，那么前 $i - 1$ 行就放了 $l - cnt_k$ 个国王，显然这个方案是成立的，所以累加更新这个状态的方案数。 怎么判断 两个状态合法 且 上下两行国王和平 呢？这就要用到 状态压缩 时常用的位运算了。 若第 $i$ 个状态为 $state_i$，且 $state_i\&amp; \left( state_i &lt;&lt; 1 \right) &gt; 0$，则说明存在相邻的国王互相攻击，该行状态不合法。 若第 $i$ 个状态为 $state_i$，第 $j$ 个状态为 $state_j$，且 $state_i\&amp; state_j &gt; 0 $，则说明存在上下国王互相攻击。 若第 $i$ 个状态为 $state_i$，第 $j$ 个状态为 $state_j$，且 $state_i\&amp; \left(state_j &lt;&lt; 1\right) &gt; 0$，则说明存在左上与右下的国王互相攻击。 若第 $i$ 个状态为 $state_i$，第 $j$ 个状态为 $state_j$，且 $\left(state_i &lt;&lt; 1\right) \&amp; state_j &gt; 0$，则说明存在右上与左下的国王互相攻击。 答案： \large { \sum\limits_{i=1}^{tot} f_{n,i,m} }其中 $tot$ 表示合法的状态总数。答案即为：最后一行状态合法，前 $n$ 行共放了 $m$ 个国王的方案数总和。 一行里所有的状态共 $2^n$ 个（考虑每一位是 $0$ 还是 $1$），所以时间复杂度为 $O(nm2^{2n})$，可能会超时。但很容易发现，在一行里有很多状态本来就是不合法的，比如 $n = 4$ 时 $0110$ 这个状态，实际有用的状态远不及 $2^n$ 个。因此我们考虑先用搜索预处理出所有合法的状态，再进行转移，这样效率能高很多。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 9, MAXM = 1 &lt;&lt; 9;//2的9次方 int n, m, tot, state[MAXM + 5], cnt[MAXM + 5];LL ans, f[MAXN + 5][MAXM + 5][MAXN * MAXN + 5];void dfs(int x, int now, int king, bool pre) &#123; //x 表示已经搜到第 x 位，now 表示当前状态，king 表示当前国王数量（1 的数量），pre 表示上一位是什么 if (king &gt; m) return;//国王数不能超过 m if (x &gt; n) &#123; state[++tot] = now; cnt[tot] = king;//存下 这个状态 和 这个状态对应国王的数量 return; &#125; if (!pre) dfs(x + 1, now &lt;&lt; 1 | 1, king + 1, 1);//把 now 的第 x 位变成 1 //如果上一位是 1，显然这一位不能放 1 dfs(x + 1, now &lt;&lt; 1, king, 0);//把 now 的第 x 位变成 0&#125;int main() &#123; read(n), read(m); dfs(1, 0, 0, 0);//预处理一行里的合法状态 for (int i = 1; i &lt;= tot; ++i) f[1][i][cnt[i]] = 1;//初始 for (int i = 2; i &lt;= n; ++i) for (int j = 1; j &lt;= tot; ++j) for (int k = 1; k &lt;= tot; ++k) &#123; if ((state[j] &amp; state[k]) || ((state[j] &lt;&lt; 1) &amp; state[k]) || (state[j] &amp; (state[k] &lt;&lt; 1))) continue; //判断第 k 个状态放在第 j 个状态下面一行是否合法，且不需要考虑同一行国王相邻的情况 for (int l = cnt[k]; l &lt;= m; ++l) f[i][k][l] += f[i - 1][j][l - cnt[k]];//转移 &#125; for (int i = 1; i &lt;= tot; ++i) ans += f[n][i][m];//累加放完第 n 行，共 m 个国王的所有状态 write(ans); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>动态规划</tag>
        <tag>SCOI</tag>
        <tag>2005</tag>
        <tag>搜索</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 3566」「SHOI2014」概率充电器]]></title>
    <url>%2Fproblems%2Fbzoj-3566%2F</url>
    <content type="text"><![CDATA[Description给定一棵 $n$ 个点的树，每个节点都有一个充电元件，第 $i$ 条边有 $p_i \%$ 的概率导电，第 $i$ 个点有 $q_i \%$ 的概率充电。求期望通电的元件个数，保留 $6$ 位小数。 Source[BZOJ]3566 Solution首先根据 期望 的性质： \large { E(A + B) = E(A) + E(B) }得到 \large {\begin{aligned} E\left( \sum\limits_{i=1}^n i \right) = \sum\limits_{i=1}^nE(i) = \sum\limits_{i=1}^n p_ix_i \end{aligned}}因为每个充电元件的贡献都是 $1$（即 $x_i = 1$），所以问题就是求所有元件充电的概率总和： \large { \sum\limits_{i=1}^n p_i }其中 $p_i$ 是元件 $i$ 通电的概率。这个东西怎么求呢？尝试 树形DP 。 状态： 用 $p_u$ 表示元件 $u$ 通电的概率。 转移： 考虑节点 $u$ 通电的 $3$ 种可能： 节点 $u$ 自己充电； 子树里有一个节点充电并传导到节点 $u$； 子树外有一个节点充电并传导到节点 $u​$ 。 节点 $u$ 自己充电很好实现，因为节点 $u$ 通电的初始概率就是读入进来的 $p_u$ 。 但是后两种似乎很难同时实现，干脆分两次 $\rm{dfs}​$ 解决。 对于第一次 $\rm{dfs}​$，我们先考虑第二种可能，有以下方程 \large {\begin{aligned} & p_u = p_u \cup \left( p_v \times q_{u \rightarrow v} \right) & \left( v \in son_u\right) \end{aligned}}其中 $q_{u \rightarrow v}​$ 表示边 $u \rightarrow v​$ 导电的概率。节点 $u​$ 通电的概率就是 节点 $u​$ 自己发电 与 子节点 $v​$ 通电后经过边 $u \rightarrow v​$ 传导到 $u​$ 的并集，换句话说，就是上述两种情况至少发生一种的概率。两个概率的并怎么求呢？有如下公式 \large { \begin{aligned} P\left( A \cup B \right) &= P\left( A \right) + P\left( B \right) - P\left( A \cap B \right)\\ &= P\left( A \right) + P\left( B \right) - P\left( A \right) \times P\left( B \right) \end{aligned} }很好证明，因为 $A$ 和 $B$ 至少发生一种，分 $3$ 种情况讨论（都运用了 乘法原理）： $A​$ 发生 $B​$ 不发生，概率为 $P\left(A \right) \times \left( 1 - P \left( B\right) \right)​$； $B$ 发生 $A$ 不发生，概率为 $P\left(B \right) \times \left( 1 - P \left( A\right) \right)$ ； $A​$ 与 $B​$ 同时发生，概率为 $P \left( A\right) \times P \left( B\right)​$ 。 根据 加法原理，把上述值加起来即能得证。这样我们就处理好了子树里节点导电的情况。 对于第二次 $\rm{dfs}​$，我们再考虑第三种可能，有以下方程 \large {\begin{aligned} & p_v = p_v \cup \left( \frac{p_u - p_v \times q_{u \rightarrow v}}{1 - p_v \times q_{u \rightarrow v}} \times q_{u \rightarrow v} \right) & \left( v \in son_u\right) \end{aligned}}其中 $q_{u \rightarrow v}$ 表示边 $u \rightarrow v$ 导电的概率。显然根节点（$root$）通电的概率已知（不可能有第三种可能），考虑通过父节点 $u$ 状态确定子节点 $v$ 。 $p_v$ 的值一定为 当前 $p_v$ 的值（自己和子树内的通电概率） 和 子树外节点通电传导给 $v$ 的并。其中 $v$ 子树里的节点通电传导给 $u$ 的概率为 $p_v \times q_{u \rightarrow v}$，这个值与子节点 $v$ 的 子树外节点通电传导给 $u$ 的概率 的并是 $p_u$ 。而现在要求 子树外节点通电传导给 $u$ 的概率 。 这个问题可以转化为——若已知 $P \left( B\right),P \left( C\right)$ 的值，且 $P\left( A \cup B \right) = P \left ( C\right)$，怎么求 $P \left( A \right)$？ 用刚才的公式倒推即可： \large { P \left( A \cup B\right) = P \left( C \right) } \large { P\left( A \right) + P\left( B \right) - P\left( A \right) \times P\left( B \right) = P\left( C \right) } \large { P\left( A \right) - P\left( A \right) \times P\left( B \right) = P\left( C \right) -P\left( B \right) } \large { P\left( A \right) \times \left( 1 - P\left( B \right) \right) = P\left( C \right) -P\left( B \right) } \large {\begin{aligned} & P\left( A \right) = \frac{P\left( C \right) -P\left( B \right)}{1 - P\left( B \right)} & \left( P \left( B \right) \neq 1 \right) \end{aligned} }根据这个式子求出 子树外节点通电传导给 $u$ 的概率，乘上 $q_{u \rightarrow v}$ 就是 子树外节点通电传导给 $v$ 的概率 了，再求 $p_v$ 与它的并，就是这个状态的值。值得注意的是，如果上述式子中的 $P\left( B \right) = 1$（即 $p_v \times q_{u \rightarrow v} = 1$），显然是不能直接除的，但因为 $0 \leq p_v,q_{u \rightarrow v} \leq 1$，所以 $p_v = q_{u \rightarrow v} = 1$，在这种情况下可以直接跳过，不进行转移（$p_v$ 一定通电）。最后把所有节点通电的概率加起来即为答案。 与第一次 $\rm{dfs}$ 不同的是：第一次是由子树合并答案，需要递归到底，返回时再转移；第二次是由父节点更新答案，遍历完整棵树即可。时间复杂度为 $O(n)​$ 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;const int MAXN = 5e5, MAXM = 5e5;const double eps = 1e-7;int n, tot, head[MAXN + 5];double ans, p[MAXN + 5], x[MAXN + 5];struct Edge &#123; int next, to; double dis;&#125; e[(MAXM &lt;&lt; 1) + 5];inline void addEdge(int u, int v, double w) &#123; e[++tot] = (Edge) &#123; head[u], v, w &#125;; head[u] = tot;&#125;inline double cup(double a, double b) &#123;//求两个概率的并 a∪b return a + b - a * b;&#125;inline double calc(double a, double b) &#123;//已知 P(b) 以及 P(a)∪P(b)，求 P(a) return (a - b) / (1.0 - b);&#125;void dfsUp(int u, int fa) &#123;//第一次 dfs，子树内节点传导电 for (int v, i = head[u]; v = e[i].to, i; i = e[i].next) &#123; if (v == fa) continue; dfsUp(v, u);//递归到底层 double q = e[i].dis; p[u] = cup(p[u], p[v] * q);//转移 &#125;&#125;void dfsDown(int u, int fa) &#123;//第二次 dfs，子树外节点传导电 ans += p[u];//累加答案 for (int v, i = head[u]; v = e[i].to, i; i = e[i].next) &#123; if (v == fa) continue; double q = e[i].dis; if (fabs(p[v] * q - 1.0) &lt; eps) &#123; dfsDown(v, u); continue;//跳过并向下搜 &#125; p[v] = cup(p[v], calc(p[u], p[v] * q) * q);//转移 dfsDown(v, u);//遍历整棵树 &#125;&#125;int main() &#123; read(n); for (int i = 1; i &lt; n; ++i) &#123; int u, v; double w; read(u), read(v), read(w); w *= 0.01;//q% addEdge(u, v, w), addEdge(v, u, w);//连无向边 &#125; for (int i = 1; i &lt;= n; ++i) &#123; read(p[i]); p[i] *= 0.01;//初始概率 为 节点自己充电的概率 &#125; dfsUp(1, 0); dfsDown(1, 0);//根节点为 1 printf("%.6lf\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>动态规划</tag>
        <tag>SHOI</tag>
        <tag>2014</tag>
        <tag>概率期望</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P4284」「SHOI2014」概率充电器]]></title>
    <url>%2Fproblems%2Fluogu-p4284%2F</url>
    <content type="text"><![CDATA[Description给定一棵 $n$ 个点的树，每个节点都有一个充电元件，第 $i$ 条边有 $p_i \%$ 的概率导电，第 $i$ 个点有 $q_i \%$ 的概率充电。求期望通电的元件个数，保留 $6$ 位小数。 Source[Luogu]P4284 Solution首先根据 期望 的性质： \large { E(A + B) = E(A) + E(B) }得到 \large {\begin{aligned} E\left( \sum\limits_{i=1}^n i \right) = \sum\limits_{i=1}^nE(i) = \sum\limits_{i=1}^n p_ix_i \end{aligned}}因为每个充电元件的贡献都是 $1$（即 $x_i = 1$），所以问题就是求所有元件充电的概率总和： \large { \sum\limits_{i=1}^n p_i }其中 $p_i$ 是元件 $i$ 通电的概率。这个东西怎么求呢？尝试 树形DP 。 状态： 用 $p_u$ 表示元件 $u$ 通电的概率。 转移： 考虑节点 $u$ 通电的 $3$ 种可能： 节点 $u$ 自己充电； 子树里有一个节点充电并传导到节点 $u$； 子树外有一个节点充电并传导到节点 $u​$ 。 节点 $u$ 自己充电很好实现，因为节点 $u$ 通电的初始概率就是读入进来的 $p_u$ 。 但是后两种似乎很难同时实现，干脆分两次 $\rm{dfs}​$ 解决。 对于第一次 $\rm{dfs}​$，我们先考虑第二种可能，有以下方程 \large {\begin{aligned} & p_u = p_u \cup \left( p_v \times q_{u \rightarrow v} \right) & \left( v \in son_u\right) \end{aligned}}其中 $q_{u \rightarrow v}​$ 表示边 $u \rightarrow v​$ 导电的概率。节点 $u​$ 通电的概率就是 节点 $u​$ 自己发电 与 子节点 $v​$ 通电后经过边 $u \rightarrow v​$ 传导到 $u​$ 的并集，换句话说，就是上述两种情况至少发生一种的概率。两个概率的并怎么求呢？有如下公式 \large { \begin{aligned} P\left( A \cup B \right) &= P\left( A \right) + P\left( B \right) - P\left( A \cap B \right)\\ &= P\left( A \right) + P\left( B \right) - P\left( A \right) \times P\left( B \right) \end{aligned} }很好证明，因为 $A$ 和 $B$ 至少发生一种，分 $3$ 种情况讨论（都运用了 乘法原理）： $A​$ 发生 $B​$ 不发生，概率为 $P\left(A \right) \times \left( 1 - P \left( B\right) \right)​$； $B$ 发生 $A$ 不发生，概率为 $P\left(B \right) \times \left( 1 - P \left( A\right) \right)$ ； $A​$ 与 $B​$ 同时发生，概率为 $P \left( A\right) \times P \left( B\right)​$ 。 根据 加法原理，把上述值加起来即能得证。这样我们就处理好了子树里节点导电的情况。 对于第二次 $\rm{dfs}​$，我们再考虑第三种可能，有以下方程 \large {\begin{aligned} & p_v = p_v \cup \left( \frac{p_u - p_v \times q_{u \rightarrow v}}{1 - p_v \times q_{u \rightarrow v}} \times q_{u \rightarrow v} \right) & \left( v \in son_u\right) \end{aligned}}其中 $q_{u \rightarrow v}$ 表示边 $u \rightarrow v$ 导电的概率。显然根节点（$root$）通电的概率已知（不可能有第三种可能），考虑通过父节点 $u$ 状态确定子节点 $v$ 。 $p_v$ 的值一定为 当前 $p_v$ 的值（自己和子树内的通电概率） 和 子树外节点通电传导给 $v$ 的并。其中 $v$ 子树里的节点通电传导给 $u$ 的概率为 $p_v \times q_{u \rightarrow v}$，这个值与子节点 $v$ 的 子树外节点通电传导给 $u$ 的概率 的并是 $p_u$ 。而现在要求 子树外节点通电传导给 $u$ 的概率 。 这个问题可以转化为——若已知 $P \left( B\right),P \left( C\right)$ 的值，且 $P\left( A \cup B \right) = P \left ( C\right)$，怎么求 $P \left( A \right)$？ 用刚才的公式倒推即可： \large { P \left( A \cup B\right) = P \left( C \right) } \large { P\left( A \right) + P\left( B \right) - P\left( A \right) \times P\left( B \right) = P\left( C \right) } \large { P\left( A \right) - P\left( A \right) \times P\left( B \right) = P\left( C \right) -P\left( B \right) } \large { P\left( A \right) \times \left( 1 - P\left( B \right) \right) = P\left( C \right) -P\left( B \right) } \large {\begin{aligned} & P\left( A \right) = \frac{P\left( C \right) -P\left( B \right)}{1 - P\left( B \right)} & \left( P \left( B \right) \neq 1 \right) \end{aligned} }根据这个式子求出 子树外节点通电传导给 $u$ 的概率，乘上 $q_{u \rightarrow v}$ 就是 子树外节点通电传导给 $v$ 的概率 了，再求 $p_v$ 与它的并，就是这个状态的值。值得注意的是，如果上述式子中的 $P\left( B \right) = 1$（即 $p_v \times q_{u \rightarrow v} = 1$），显然是不能直接除的，但因为 $0 \leq p_v,q_{u \rightarrow v} \leq 1$，所以 $p_v = q_{u \rightarrow v} = 1$，在这种情况下可以直接跳过，不进行转移（$p_v$ 一定通电）。最后把所有节点通电的概率加起来即为答案。 与第一次 $\rm{dfs}$ 不同的是：第一次是由子树合并答案，需要递归到底，返回时再转移；第二次是由父节点更新答案，遍历完整棵树即可。时间复杂度为 $O(n)​$ 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;const int MAXN = 5e5, MAXM = 5e5;const double eps = 1e-7;int n, tot, head[MAXN + 5];double ans, p[MAXN + 5], x[MAXN + 5];struct Edge &#123; int next, to; double dis;&#125; e[(MAXM &lt;&lt; 1) + 5];inline void addEdge(int u, int v, double w) &#123; e[++tot] = (Edge) &#123; head[u], v, w &#125;; head[u] = tot;&#125;inline double cup(double a, double b) &#123;//求两个概率的并 a∪b return a + b - a * b;&#125;inline double calc(double a, double b) &#123;//已知 P(b) 以及 P(a)∪P(b)，求 P(a) return (a - b) / (1.0 - b);&#125;void dfsUp(int u, int fa) &#123;//第一次 dfs，子树内节点传导电 for (int v, i = head[u]; v = e[i].to, i; i = e[i].next) &#123; if (v == fa) continue; dfsUp(v, u);//递归到底层 double q = e[i].dis; p[u] = cup(p[u], p[v] * q);//转移 &#125;&#125;void dfsDown(int u, int fa) &#123;//第二次 dfs，子树外节点传导电 ans += p[u];//累加答案 for (int v, i = head[u]; v = e[i].to, i; i = e[i].next) &#123; if (v == fa) continue; double q = e[i].dis; if (fabs(p[v] * q - 1.0) &lt; eps) &#123; dfsDown(v, u); continue;//跳过并向下搜 &#125; p[v] = cup(p[v], calc(p[u], p[v] * q) * q);//转移 dfsDown(v, u);//遍历整棵树 &#125;&#125;int main() &#123; read(n); for (int i = 1; i &lt; n; ++i) &#123; int u, v; double w; read(u), read(v), read(w); w *= 0.01;//q% addEdge(u, v, w), addEdge(v, u, w);//连无向边 &#125; for (int i = 1; i &lt;= n; ++i) &#123; read(p[i]); p[i] *= 0.01;//初始概率 为 节点自己充电的概率 &#125; dfsUp(1, 0); dfsDown(1, 0);//根节点为 1 printf("%.6lf\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>动态规划</tag>
        <tag>SHOI</tag>
        <tag>2014</tag>
        <tag>概率期望</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P1122」最大子树和]]></title>
    <url>%2Fproblems%2Fluogu-p1122%2F</url>
    <content type="text"><![CDATA[Description给定一棵 $n\ (1 \leq n \leq 16000)$ 个点的树，节点 $i$ 的点权为 $val_i\ \left( \left | \sum\limits_{i=1}^n val_i \right | \leq 2^{31}-1 \right)$，现在要从中找到一个联通分量，使它们的点权和最大， 求这个最大值。 Source[Luogu]P1122 Solution看到这种求最大值的题目，很容易想到 树形DP 。 状态： 用 $f_u$ 表示在节点 $u$ 的子树中，包括 $u$ 的联通分量的最大点权和。 初始： \large { f_u = val_u }由状态可知，$f_u$ 一定取了节点 $u$，所以最小值为 $val_u$ 。 转移： \large { f_u = \max \left( f_u, f_u + f_v \right) }如果加上包括子节点 $v$ 的联通分量后，比原来的值大，显然加上更优。 答案： \large {\begin{aligned} & \max \begin{Bmatrix} f_u \end{Bmatrix} & \left( 1 \leq u \leq n \right) \end{aligned}}不能判断 $f_{root}$（$root$ 表示根节点）就是答案，因为最优答案不一定取根节点，可能取其它节点（不选根节点）的方案更优，所以要取最大值。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 16000, MAXM = 16000;int n, tot, ans, val[MAXN + 5], head[MAXN + 5], f[MAXN + 5];struct Edge &#123; int next, to;&#125; e[(MAXM &lt;&lt; 1) + 5];inline void addEdge(int u, int v) &#123; e[++tot] = (Edge) &#123; head[u], v &#125;; head[u] = tot;&#125;void dfs(int u, int fa) &#123; f[u] = val[u];//初始 for (int v, i = head[u]; v = e[i].to, i; i = e[i].next) &#123; if (v == fa) continue; dfs(v, u); f[u] = max(f[u], f[u] + f[v]);//转移 &#125; ans = max(ans, f[u]);//取最大值 &#125;int main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) read(val[i]); for (int i = 1; i &lt; n; ++i) &#123; int u, v; read(u), read(v); addEdge(u, v), addEdge(v, u);//无向边 &#125; dfs(1, 0);//假设根节点为 1 write(ans); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>动态规划</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2016」战略游戏]]></title>
    <url>%2Fproblems%2Fluogu-p2016%2F</url>
    <content type="text"><![CDATA[Description给定一棵 $n\ (1 \leq n \leq 1500)$ 个点的树，编号为 $0 \sim n - 1$，现在需要从中选择若干个点，每个点可以覆盖所有连向它的边，求覆盖所有边至少需要几个点。 Source[Luogu]P2016 Solution考虑用 树形DP 求解。 状态： 用 $f_{0,u}$ 表示在节点 $u$ 的子树中，覆盖所有边但不选节点 $u$ 最少需要几个点； 用 $f_{1,u}$ 表示在节点 $u$ 的子树中，覆盖所有边且选了节点 $u$ 最少需要几个点。 初始： 无 转移： \large { f_{0,u} = \sum\limits_{v \in son_u} f_{1,v} }若不选节点 $u$，则节点 $u$ 的儿子 $v$ 必须选，这样才能覆盖到边 $u \rightarrow v$ 。 \large { f_{1,u} = \sum\limits_{v \in son_u} \min \left(f_{0, v} , f_{1, v} \right) + 1 }若选节点 $u$，则边 $u \rightarrow v$ 一定能被覆盖，节点 $v$ 可选可不选，显然取节点 $v$ 选 和 不选 的较小值更优，并加上 $1$（算上节点 $u$）。 答案： \large{\begin{aligned} &\min \left(f_{0,root},f_{1,root} \right) && (root\ 表示根节点) \end{aligned}}考虑在根节点的子树中（整棵树），根节点 选 或 不选，取较小值即是答案。因为本题没有给出根节点，所以直接设 $1$ 号节点为根，连无向边即可。 时间复杂度为 $O(n)$ 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1500, MAXM = 1500;int n, tot, head[MAXN + 5], f[2][MAXN + 5];struct Edge &#123; int next, to;&#125; e[(MAXM &lt;&lt; 1) + 5];inline void addEdge(int u, int v) &#123; e[++tot] = (Edge) &#123; head[u], v &#125;; head[u] = tot;&#125;void dfs(int u, int fa) &#123; f[1][u] = 1; for (int v, i = head[u]; v = e[i].to, i; i = e[i].next) &#123; if (v == fa) continue; dfs(v, u); f[0][u] += f[1][v]; f[1][u] += min(f[0][v], f[1][v]);//转移 &#125;&#125;int main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) &#123; int u, v, k; read(u); ++u;//习惯点的编号从 1 开始 for (read(k); k; --k) &#123; read(v); ++v; addEdge(u, v), addEdge(v, u);//连无向边 &#125; &#125; dfs(1, 0);//设根节点为 1 号节点 write(min(f[0][1], f[1][1])); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>动态规划</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2014」选课]]></title>
    <url>%2Fproblems%2Fluogu-p2014%2F</url>
    <content type="text"><![CDATA[Description现在有 $n\ (1\leq n \leq 300)$ 个点，其中节点 $i\ (1 \leq i \leq n)$ 的父节点为 $k_i\ (0\leq k_i \leq n)$，权值为 $s_i\ (1 \leq s_i \leq 20)$，$k_i = 0$ 表示这个点没有父节点。现在需要从中选择 $m\ (1 \leq m \leq 300)$ 个点，你能选择一个点当且仅当 这个点的所有祖先节点已选 或 这个点没有父节点，求这些点的最大点权和。 Source[Luogu]P2014 Solution不止一个点没有父节点，说明这道题的图是一个 森林（由很多树组成）。一种经典的解决方法是，我们把每棵树的根连向一个虚拟节点—— $0$ 号节点（即 $k_i = 0$ 时依然连边）。我们把 $0$ 号节点看作必选的点，也就是说，一共要选 $m + 1$ 个点。这样就把一个森林转化成了一棵树。 这是一个有树形依赖的背包问题，所以考虑在转化后的树上做 树形DP（树形背包）。 状态： 用 $f_{u,j,k}$ 表示从 $u$ 的前 $j$ 个子节点的子树中选出 $k$ 个点的最大点权和。 初始： \large { f_{u, 0, 1} = s_u }从节点 $u$ 的前 $0$ 个子节点中选出 $1$ 个点的答案为 $s_u$（根据题目中的条件：只有选了节点 $u$ 才能继续选其子树中的点）。 转移： \large { f_{u,j,k} = \max \begin{Bmatrix} f_{u, j - 1, k - l} + f_{v, sum_v, l} \end{Bmatrix}\\[2ex] \left( 0 \leq l \leq \min\left(k - 1,size_v \right), v \in son_u \right) }其中 $v$ 是 $u$ 的第 $j$ 个子节点，$sum_v$ 表示 $v$ 的子节点个数，$size_v$ 表示 $v$ 的子树大小。在 $u$ 的子树中，从 $u$ 的前 $j$ 个子节点的子树中选出 $k$ 个点时，可以先从前 $j - 1$ 个子节点的子树中选择 $k - l$ 个点，然后在第 $j$ 个子节点 $v$ 的子树中选择 $l$ 个点，枚举 $l$，取最大值即是该状态的答案。 答案： \large{\begin{aligned} &f_{root,sum_{root},m + 1} && (root\ 表示根节点) \end{aligned}}答案为在根节点的子树中，从根节点的所有儿子（$sum_{root}$，即根节点的儿子个数）中选出 $m + 1$ 个点的最大点权和。此题中根节点为 $0$ 号节点（虚点）。 然而 $3$ 维的空间可能会开不下，考虑如何优化空间复杂度。 很容易发现，$u$ 是从子节点 $v$ 的状态合并而来的，所以在处理 $u$ 之前 $v$ 的状态都是已知的（即 $f_{v,sum_v,l}$ 已知）。同时状态转移与 $k$ 枚举的顺序无关，因为枚举 $k$ 时 $j - 1$ 的所有状态都已经求出来了。除此之外，状态 $k - l$ 一直在 $l$ 的前面，因此我们考虑压掉 $j$ 这一维。 状态： 用 $f_{u,j}$ 表示在 $u$ 的子树中，选出 $j$ 个点的最大点权和。 初始： \large { f_{u,1} = s_u }转移： \large { f_{u,j} = \max \begin{Bmatrix} f_{u, j - k} + f_{v, k} \end{Bmatrix}\\[2ex] \left( 0 \leq k \leq \min\left(j - 1,size_v \right), v \in son_u \right) }$size_v$ 表示 $v$ 的子树大小。注意 $j$ 应该倒序枚举，这样做的实质是：$f_{u,j-k}$ 仍然是上一次转移的状态（还没被更新），即 $f_{u-1,j-k}$ 。 答案： \large{\begin{aligned} &f_{root,m + 1} && (root\ 表示根节点) \end{aligned}}时间复杂度不是很好证明，应该为 $O(nm)$ 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 300, MAXM = 300;int n, m, tot, k, s[MAXN + 5], head[MAXN + 5], size[MAXN + 5], f[MAXN + 5][MAXN + 5];struct Edge &#123; int next, to;&#125; e[(MAXM &lt;&lt; 1) + 5];inline void addEdge(int u, int v) &#123; e[++tot] = (Edge) &#123; head[u], v &#125;; head[u] = tot;&#125;void dfs(int u, int depth) &#123; if (depth &gt; m) return;//小优化：所选的点一定在前 m 层（节点 0 算第 0 层） size[u] = 1; f[u][1] = s[u];//初始 for (int v, i = head[u]; v = e[i].to, i; i = e[i].next) &#123; dfs(v, depth + 1); size[u] += size[v];//节点 u 的子树大小 for (int j = min(m + 1, size[u]); j; --j)//注意压维后要倒序枚举 for (int k = 0; k &lt;= min(j - 1, size[v]); ++k) f[u][j] = max(f[u][j], f[u][j - k] + f[v][k]);//转移 &#125;&#125;int main() &#123; read(n), read(m); for (int i = 1; i &lt;= n; ++i) &#123; read(k), read(s[i]); addEdge(k, i);//k 是 i 的父节点，连一条有向边 k -&gt; i &#125; dfs(0, 0);//根节点是 0 write(f[0][m + 1]);//答案 putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>动态规划</tag>
        <tag>树形DP</tag>
        <tag>背包问题</tag>
        <tag>CTSC</tag>
        <tag>1997</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2458」「SDOI2006」保安站岗]]></title>
    <url>%2Fproblems%2Fluogu-p2458%2F</url>
    <content type="text"><![CDATA[Description给定一棵 $n\ (1 \leq n \leq 1500)$ 个节点的树，点 $i\ (1 \leq i \leq n)$ 的花费是 $val_i\ (1 \leq val_i \leq 10^4)$，现在需要从中选择若干个点，这些点能够覆盖与它们相连的点，求覆盖树上所有点的最小代价是多少。 Source[Luogu]P2458 Solution考虑 树形DP 。 状态： 用 $f_{0,u}$ 表示在节点 $u$ 的子树中，所有点都已经被覆盖，其中节点 $u$ 被自己覆盖的最小代价； 用 $f_{1,u}$ 表示在节点 $u$ 的子树中，所有点都已经被覆盖，其中节点 $u$ 被它儿子覆盖的最小代价； 用 $f_{2,u}$ 表示在节点 $u$ 的子树中，除节点 $u$ 外的点都已经被覆盖，其中节点 $u$ 将被它父亲覆盖的最小代价。 初始： 无 转移： \large { f_{0,u} = val_u + \sum\limits_{v \in son_u} \min \begin{Bmatrix} f_{0,v},f_{1,v},f_{2,v} \end{Bmatrix} }若节点 $u$ 被自己覆盖，则至少要花费 $val_u$ 的代价，同时子节点 $v$ 的状态不需要考虑，因为无论怎样 $v$ 都会被 $u$ 覆盖，所以还需要加上 子节点所有状态的最小值 。 \large {f_{1,u}=\left\{\begin{matrix}\begin{aligned} &\sum\limits_{v \in son_u} \min \left(f_{0,v}, f_{1,v}\right) \\[2ex] &\sum\limits_{v \in son_u} \min \left(f_{0,v}, f_{1,v}\right) + \min \begin{Bmatrix} f_{0,v} - f_{1,v} \end{Bmatrix} & (\operatorname{if} \ \forall f_{0,v} > f_{1,v}) \end{aligned}\end{matrix}\right.}若节点 $u$ 被它儿子覆盖，则子节点 $v$ 不可能被它的父节点 $u$ 覆盖，因此需要取子节点 被自己覆盖 和 被其儿子 覆盖的较小值。但是所取的子节点肯定不能全部被自己的儿子覆盖，否则节点 $u$ 将不会被覆盖。因此如果所有的 $f_{1,v}$ 都比 $f_{0,v}$ 更优，那么需要从中挑出一个 $f_{1,v}$，把它变成 $f_{0,v}$，这样才能满足 $u$ 被 $v$ 覆盖。为了让变化所花费的代价更小，我们需要找到 $f_{0,v}$ 与 $f_{1,v}$ 的最小差值，加上原来的代价即可。 \large { f_{2,u} = \sum\limits_{v \in son_u} \min \left( f_{0,v}, f_{1,v} \right) }若节点 $u$ 被它父亲覆盖，则子节点 $v$ 不可能被它的父节点 $u$ 覆盖，所以只需要加上子节点 被自己覆盖 和 被其儿子 覆盖的较小值即可。 答案： \large{\begin{aligned} &\min \left(f_{0,root},f_{1,root} \right) && (root\ 表示根节点) \end{aligned}}因为根节点没有父亲，所以不需要考虑根节点被父亲覆盖的情况，答案应该取根节点 被自己覆盖 和 被儿子覆盖 的较小值。因为本题是棵无根树，所以直接设 $1$ 号节点为根，连无向边即可。 时间复杂度为 $O(n)$ 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1500, MAXM = 1500;int n, m, tot, val[MAXN + 5], head[MAXN + 5], f[3][MAXN + 5];struct Edge &#123; int next, to;&#125; e[(MAXM &lt;&lt; 1) + 5];inline void addEdge(int u, int v) &#123; e[++tot] = (Edge) &#123; head[u], v &#125;; head[u] = tot;&#125;void dfs(int u, int fa) &#123; f[0][u] = val[u]; bool flag = 1; int minn = 0x7fffffff; for (int v, i = head[u]; v = e[i].to, i; i = e[i].next) &#123; if (v == fa) continue; dfs(v, u); f[0][u] += min(f[0][v], min(f[1][v], f[2][v])); f[1][u] += min(f[0][v], f[1][v]); f[2][u] += min(f[0][v], f[1][v]);//转移 if (f[0][v] &lt;= f[1][v]) flag = 0;//检查是否所有的 f[0][v] 都大于 f[1][v] if (flag) minn = min(minn, f[0][v] - f[1][v]);//如果是，记录最小其差值 &#125; if (flag) f[1][u] += minn;//如果全部选择了 f[1][v]，还要加上最小差值 &#125;int main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) &#123; int u, v; read(u), read(val[u]), read(m);//注意读入的是节点 u 的点权而不是 i 的点权 for (int j = 1; j &lt;= m; ++j) &#123; read(v); addEdge(u, v), addEdge(v, u); &#125;//连无向边 &#125; dfs(1, 0);//以 1 号节点作为根节点 write(min(f[0][1], f[1][1])); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>SDOI</tag>
        <tag>动态规划</tag>
        <tag>2006</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P1352」没有上司的舞会]]></title>
    <url>%2Fproblems%2Fluogu-p1352%2F</url>
    <content type="text"><![CDATA[Description给定一棵 $n\ (1 \leq n \leq 6 \times 10^3)$ 个点的树，点 $i\ (1 \leq i \leq n)$ 的点权为 $r_i\ (-128 \leq r_i \leq 127)$ 。现在需要从中选取若干个点，使这些点的点权和最大，但规定子节点和父节点不能同时选，求最大点权和。 Source[Luogu]P1352 Solution考虑 树形DP 。 状态： 用 $f_{0,u}$ 表示在节点 $u$ 的子树中，不取 $u$ 的最大点权和； 用 $f_{1,u}$ 表示在节点 $u$ 的子树中，取了 $u$ 的最大点权和。 初始： 无 转移： \large{ f_{0,u} = \sum\limits_{v \in son_u} \max \left( f_{0,v}, f_{1,v}\right) }当不取节点 $u$ 时，$u$ 的子节点取和不取都可以，显然取其中较大的更优，所以 $f_{0,u}$ 应当等于 所有子节点 取 与 不取 的 较大值 之和。 \large{ f_{1,u} = r_u + \sum\limits_{v \in son_u} f_{0,v} }当取节点 $u$ 时，$f_{1,u}$ 的最小值为 节点 $u$ 的点权，同时 $u$ 的子节点只能不取，所以 $f_{1,u}$ 还应当加上 所有子节点不取 的和。 答案： \large{\begin{aligned} &\max \left(f_{0,root},f_{1,root} \right) && (root\ 表示根节点) \end{aligned}}答案是在根节点的子树中，取 和 不取 根节点的较大值。 时间复杂度为 $O(n)$ 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 6000;int n, l, k, tot, root, r[MAXN + 5], cnt[MAXN + 5], head[MAXN + 5], f[2][MAXN + 5];struct Edge &#123; int next, to;&#125; e[(MAXN &lt;&lt; 1) + 5];inline void addEdge(int u, int v) &#123; e[++tot] = (Edge) &#123; head[u], v &#125;; head[u] = tot;&#125;void dfs(int u) &#123; f[1][u] = r[u]; for (int v, i = head[u]; v = e[i].to, i; i = e[i].next) &#123; dfs(v); f[0][u] += max(f[0][v], f[1][v]); f[1][u] += f[0][v]; &#125;//转移 &#125;int main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) read(r[i]); for (int i = 1; i &lt; n; ++i) &#123; read(l), read(k);//k 是 l 的上司 addEdge(k, l);//连一条有向边 k -&gt; l ++cnt[l];//l 的上司数量 &#125; for (int i = 1; i &lt;= n; ++i) if (!cnt[i]) &#123; root = i; break; &#125;//找根节点（没有父亲的节点） dfs(root); write(max(f[0][root], f[1][root]));//答案 putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>动态规划</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LaTeX/MathJax 字体美化]]></title>
    <url>%2Fothers%2Flatex-mathjax-gong-shi-zi-ti-mei-hua%2F</url>
    <content type="text"><![CDATA[前言本文主要介绍 $\LaTeX$，$\text{MathJax}$ 语法的字体美化，包括 字体种类，字体大小，字体特效，字体颜色 等。 字体种类设置统一表示方法：\字体种类{文本} 字体种类 表示方法 预览 默认字体 ABCDEFGHIJKLMNOPQRSTUVWXYZ $ABCDEFGHIJKLMNOPQRSTUVWXYZ$ abcdefghijklmnopqrstuvwxyz $abcdefghijklmnopqrstuvwxyz$ 数学斜体 \mit{ABCDEFGHIJKLMNOPQRSTUVWXYZ} $\mit{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ \mit{abcdefghijklmnopqrstuvwxyz} $\mit{abcdefghijklmnopqrstuvwxyz}$ 意大利体 \it{ABCDEFGHIJKLMNOPQRSTUVWXYZ} $\it{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ \it{abcdefghijklmnopqrstuvwxyz} $\it{abcdefghijklmnopqrstuvwxyz}$ 罗马体 \rm{ABCDEFGHIJKLMNOPQRSTUVWXYZ} $\rm{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ \rm{abcdefghijklmnopqrstuvwxyz} $\rm{abcdefghijklmnopqrstuvwxyz}$ 花体 \cal{ABCDEFGHIJKLMNOPQRSTUVWXYZ} $\cal{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ \cal{abcdefghijklmnopqrstuvwxyz} $\cal{abcdefghijklmnopqrstuvwxyz}$ 打字机体 \tt{ABCDEFGHIJKLMNOPQRSTUVWXYZ} $\tt{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ \tt{abcdefghijklmnopqrstuvwxyz} $\tt{abcdefghijklmnopqrstuvwxyz}$ 粗体 \bf{ABCDEFGHIJKLMNOPQRSTUVWXYZ} $\bf{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ \bf{abcdefghijklmnopqrstuvwxyz} $\bf{abcdefghijklmnopqrstuvwxyz}$ 黑板粗体 \Bbb{ABCDEFGHIJKLMNOPQRSTUVWXYZ} $\Bbb{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ \Bbb{abcdefghijklmnopqrstuvwxyz} $\Bbb{abcdefghijklmnopqrstuvwxyz}$ 等线体 \sf{ABCDEFGHIJKLMNOPQRSTUVWXYZ} $\sf{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ \sf{abcdefghijklmnopqrstuvwxyz} $\sf{abcdefghijklmnopqrstuvwxyz}$ 旧德式体 \frak{ABCDEFGHIJKLMNOPQRSTUVWXYZ} $\frak{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ \frak{abcdefghijklmnopqrstuvwxyz} $\frak{abcdefghijklmnopqrstuvwxyz}$ 手写体 \scr{ABCDEFGHIJKLMNOPQRSTUVWXYZ} $\scr{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ \scr{abcdefghijklmnopqrstuvwxyz} $\scr{abcdefghijklmnopqrstuvwxyz}$ 字体大小设置统一表示方法：\字体大小{文本} 字体大小 字宽(pt) 表示方法 预览 小初 $36$ pts \Huge{小初字体(36pts)} $\Huge{小初字体(36pts)}$ 一号 $27.5$ pts \huge{一号字体(27.5pts)} $\huge{一号字体(27.5pts)}$ 二号 $21$ pts \LARGE{二号字体(21pts)} $\LARGE{二号字体(21pts)}$ 三号 $15.75$ pts \Large{三号字体(15.75pts)} $\Large{三号字体(15.75pts)}$ 四号 $13.75$ pts \large{四号字体(13.75pts)} $\large{四号字体(13.75pts)}$ 小四 $12$ pts \normalsize{小四字体(12pts)} $\normalsize{小四字体(12pts)}$ 默认 $12$ pts 默认字体(12pts) $默认字体(12pts)$ 五号 $10.5$ pts \small{五号字体(10.5pts)} $\small{五号字体(10.5pts)}$ 六号 $7.875$ pts \scriptsize{六号字体(7.875pts)} $\scriptsize{六号字体(7.875pts)}$ 七号 $5.25$ pts \tiny{七号字体(5.25pts)} $\tiny{七号字体(5.25pts)}$ 字体特效设置 字体特效 表示方法 预览 加粗 \bf{加粗} $\bf{加粗}$ 下划线 \underline{下划线}​ $\underline{下划线}$ 使用前声名删除线 \require{enclose} $\require{enclose}$ 删除线 \enclose{horizontalstrike}{删除线} $\enclose{horizontalstrike}{删除线}$ \enclose{verticalstrike}{删\\除\\线} $\enclose{verticalstrike}{删\\除\\线}$ \enclose{updiagonalstrike}{删除线} $\enclose{updiagonalstrike}{删除线}$ \enclose{downdiagonalstrike}{删除线} $\enclose{downdiagonalstrike}{删除线}$ \enclose{updiagonalstrike,downdiagonalstrike}{删除线} $\enclose{updiagonalstrike,downdiagonalstrike}{删除线}$ \enclose{horizontalstrike,verticalstrike}{\;\ 删\\删除线\\\;\ 线} $\enclose{horizontalstrike,verticalstrike}{\; 删\\删除线\\\; 线}$ \enclose{updiagonalstrike,downdiagonalstrike,horizontalstrike,verticalstrike}{删除线} $\enclose{updiagonalstrike,downdiagonalstrike,horizontalstrike,verticalstrike}{删除线}$ 补充：删除线可以多种形式搭配使用 字体颜色设置统一表示方法：\color{颜色}{文本} 颜色 表示方法 预览 黑色(black) \color{black}{黑色(\text{black})} $\color{black}{黑色(\text{black})}$ 红色(red) \color{red}{红色(\text{red})} $\color{red}{红色(\text{red})}$ 黄色(yellow) \color{yellow}{黄色(\text{yellow})} $\color{yellow}{黄色(\text{yellow})}$ 蓝色(blue) \color{blue}{蓝色(\text{blue})} $\color{blue}{蓝色(\text{blue})}$ 灰色(grey) \color{grey}{灰色(\text{grey})} $\color{grey}{灰色(\text{grey})}$ 白色(white) \color{white}{白色(\text{white})} $\color{white}{白色(\text{white})}$ 绿色(green) \color{green}{绿色(\text{green})} $\color{green}{绿色(\text{green})}$ 紫色(green) \color{purple}{紫色(\text{purple})} $\color{purple}{紫色(\text{purple})}$ 紫红色(maroon) \color{maroon}{紫红色(\text{maroon})} $\color{maroon}{紫红色(\text{maroon})}$ 橄榄绿(olive) \color{olive}{橄榄绿(\text{olive})} $\color{olive}{橄榄绿(\text{olive})}$ 蓝绿色(teal) \color{teal}{蓝绿色(\text{teal})} $\color{teal}{蓝绿色(\text{teal})}$ 银色(silver) \color{silver}{银色(\text{silver})} $\color{silver}{银色(\text{silver})}$ 浅绿色(lime) \color{lime}{浅绿色(\text{lime})} $\color{lime}{浅绿色(\text{lime})}$ 藏青色(navy) \color{navy}{藏青色(\text{navy})} $\color{navy}{藏青色(\text{navy})}$]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
        <tag>MathJax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 3884」上帝与集合的正确用法]]></title>
    <url>%2Fproblems%2Fbzoj-3884%2F</url>
    <content type="text"><![CDATA[Description给定 $T\ (T\leq 10^3)$ 组数据，每组数据包含一个正整数 $p\ (1 \leq p \leq 10^7)$，求 $2^{2^{2 \cdots}}(无限个 2) \bmod p$ 的值。 Source[BZOJ]3884 Solution 前置知识： 常见积性函数 - 欧拉函数 - 线性筛求欧拉函数 常用的质数相关定理 - 扩展欧拉定理 在此题中，指数 $b = 2^{2^{2\cdots}}$ 一定满足 $b \geq \varphi(p)$，所以我们通过 扩展欧拉定理： \begin{aligned} a^b &\equiv a^{b \bmod \varphi(p) + \varphi(p)} \pmod p & b \geq \varphi(p)\\ \end{aligned}得到 2^{2^{2\cdots} } \bmod p=2^{\left(2^{2 \cdots} \bmod \varphi(p)+\varphi(p)\right)} \bmod p设 $f(p) = 2^{2^{2\cdots}} \bmod p$，则有 f(p)=2^{f(\varphi(p)) + \varphi(p)}\bmod p我们就成功地化简了问题——把求 $f(p)$ 转化为求 $f(\varphi(p))$ 。 这个式子可以一直递归下去，直到 $p = 1$ 时返回 $f(1)=2^{2^{2 \cdots}} \bmod \varphi(1) = 0$ 。总时间复杂度为 $O(p + T\log^2 p)$ 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1e6, MAXP = 1e7;int t, p, cnt, prime[MAXN + 5], phi[MAXP + 5];bool isNotPrime[MAXP + 5];inline void getPhi(int n) &#123; phi[1] = 1; isNotPrime[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; if (!isNotPrime[i]) &#123; prime[++cnt] = i; phi[i] = i - 1; &#125; for (int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n; ++j) &#123; isNotPrime[i * prime[j]] = 1; if (i % prime[j] == 0) &#123; phi[i * prime[j]] = phi[i] * prime[j]; break; &#125; else phi[i * prime[j]] = phi[i] * (prime[j] - 1); &#125; &#125;&#125;//线性筛求 φ(1) ~ φ(n) inline int quickPow(int x, int p, int mod) &#123; int res = 1; for (; p; p &gt;&gt;= 1, x = (LL) x * x % mod) if (p &amp; 1) res = (LL) res * x % mod; return res;&#125;//快速幂 int f(int p) &#123; if (p == 1) return 0;//f(1) = 0 return quickPow(2, f(phi[p]) + phi[p], p);&#125;//递归求解 int main() &#123; getPhi(MAXP); for (read(t); t; --t) &#123; read(p); write(f(p));//答案为 f(p) putchar('\n'); &#125; return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>数论数学</tag>
        <tag>欧拉定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P4139」上帝与集合的正确用法]]></title>
    <url>%2Fproblems%2Fluogu-p4139%2F</url>
    <content type="text"><![CDATA[Description给定 $T\ (T\leq 10^3)$ 组数据，每组数据包含一个正整数 $p\ (1 \leq p \leq 10^7)$，求 $2^{2^{2 \cdots}}(无限个 2) \bmod p$ 的值。 Source[Luogu]P4139 Solution 前置知识： 常见积性函数 - 欧拉函数 - 线性筛求欧拉函数 常用的质数相关定理 - 扩展欧拉定理 在此题中，指数 $b = 2^{2^{2\cdots}}$ 一定满足 $b \geq \varphi(p)$，所以我们通过 扩展欧拉定理： \begin{aligned} a^b &\equiv a^{b \bmod \varphi(p) + \varphi(p)} \pmod p & b \geq \varphi(p)\\ \end{aligned}得到 2^{2^{2\cdots} } \bmod p=2^{\left(2^{2 \cdots} \bmod \varphi(p)+\varphi(p)\right)} \bmod p设 $f(p) = 2^{2^{2\cdots}} \bmod p$，则有 f(p)=2^{f(\varphi(p)) + \varphi(p)}\bmod p我们就成功地化简了问题——把求 $f(p)$ 转化为求 $f(\varphi(p))$ 。 这个式子可以一直递归下去，直到 $p = 1$ 时返回 $f(1)=2^{2^{2 \cdots}} \bmod \varphi(1) = 0$ 。总时间复杂度为 $O(p + T\log^2 p)$ 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1e6, MAXP = 1e7;int t, p, cnt, prime[MAXN + 5], phi[MAXP + 5];bool isNotPrime[MAXP + 5];inline void getPhi(int n) &#123; phi[1] = 1; isNotPrime[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; if (!isNotPrime[i]) &#123; prime[++cnt] = i; phi[i] = i - 1; &#125; for (int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n; ++j) &#123; isNotPrime[i * prime[j]] = 1; if (i % prime[j] == 0) &#123; phi[i * prime[j]] = phi[i] * prime[j]; break; &#125; else phi[i * prime[j]] = phi[i] * (prime[j] - 1); &#125; &#125;&#125;//线性筛求 φ(1) ~ φ(n) inline int quickPow(int x, int p, int mod) &#123; int res = 1; for (; p; p &gt;&gt;= 1, x = (LL) x * x % mod) if (p &amp; 1) res = (LL) res * x % mod; return res;&#125;//快速幂 int f(int p) &#123; if (p == 1) return 0;//f(1) = 0 return quickPow(2, f(phi[p]) + phi[p], p);&#125;//递归求解 int main() &#123; getPhi(MAXP); for (read(t); t; --t) &#123; read(p); write(f(p));//答案为 f(p) putchar('\n'); &#125; return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>数论数学</tag>
        <tag>欧拉定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 1407」「NOI2002」Savage]]></title>
    <url>%2Fproblems%2Fbzoj-1407%2F</url>
    <content type="text"><![CDATA[Descripion岛上有 $m$ 个洞穴，顺时针编号为 $1 \sim m$ 。岛上有 $n\ (1 \leq n \leq 15)$ 个野人分别住在 $c_1,c_2,\ldots,c_n\ (1 \leq c_i \leq 100)$ 中。以后每年，第 $i$ 个野人会沿顺时针向前走 $p_i\ (1 \leq p_i \leq 100)$ 个洞住下来，其中第 $i$ 个野人可以生存 $l_i$ 年。没有 $2$ 个野人能在有生之年生存在同一个洞穴中，求洞穴个数 $m\ (m \leq 10^6)$ 的最小值。 Source[BZOJ]1407 Solution 前置知识： 扩展欧几里得(exgcd)算法 对于 野人 $i$ 和 野人 $j$ $(i \neq j)$，假设经过 $x$ 天之后他们会在同一个洞穴相遇，那么可以得出方程： c_i + p_ix \equiv c_j + p_jx \pmod m化简方程，得到 (p_i - p_j)x \equiv c_j - c_i \pmod m这个方程等价于 (p_i - p_j)x + m \times y = c_j - c_i显然我们可以用 exgcd(扩展欧几里得) 算法求出方程 $(p_i - p_j)x + m \times y = \gcd(p_i-p_j,m)$ 的一个解 $x’$ 。 如果 $\gcd(p_i-p_j,m) \nmid c_j-c_i$，说明 $x$ 无解，野人 $i,j$ 永远不会相遇。 若有解，我们求出 $x$ 的最小正整数解，即 x = \left( x' \times \frac{c_j - c_i}{\gcd(p_i-p_j,m)} \bmod \frac{m}{\gcd(p_i-p_j,m)} + \frac{m}{\gcd(p_i-p_j,m)} \right) \bmod \frac{m}{\gcd(p_i-p_j,m)}如果 $x &gt; \min(l_i,l_j)$，说明在他们相遇之前，$i, j$ 中会有至少一个野人死亡，所以也是可行的。 如果 $x \leq \min(l_i,l_j)$，说明 野人 $i,j$ 会在死亡前相遇，这个 $m$ 不可行。 我们只需要枚举每一个可能的 $m$（题目保证 $m \leq 10^6$），枚举每一对野人 $(i,j)$，用 exgcd 求解 $x$ 并判断这个 $m$ 是否满足要求。还有一些小细节：用 exgcd 时必须保证 $p_i \geq p_j$，因为 $\gcd$ 只对 非负整数 有意义。总时间复杂度为 $O( n^2m\log p_i)$ 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 15, MAXM = 1e6;int n, maxn, c[MAXN + 5], p[MAXN + 5], l[MAXN + 5];int exGcd(int a, int b, int &amp;x, int &amp;y) &#123; if (b == 0) &#123; x = 1, y = 0; return a; &#125; int d = exGcd(b, a % b, y, x); y -= a / b * x; return d;&#125;inline bool judge(int m) &#123;//判断这个 m 是否可行 for (int i = 1; i &lt; n; ++i) for (int j = i + 1; j &lt;= n; ++j) &#123;//枚举每一对野人 int pi = p[i], pj = p[j], ci = c[i], cj = c[j], x, y, d; if (pi &lt; pj) &#123; swap(pi, pj); swap(ci, cj); &#125; //如果 pi &lt; pj，不满足 gcd 要求，交换 d = exGcd(pi - pj, m, x, y);//d = gcd(pi - pj, m) if ((cj - ci) % d != 0) continue;//x 无解，野人 i,j 不可能相遇 int p = m / d; x *= (cj - ci) / d; x = (x % p + p) % p;//x 的最小整数解 if (x &lt;= min(l[i], l[j])) return 0;//这个 m 不符合题意 &#125; return 1;&#125;int main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) &#123; read(c[i]), read(p[i]), read(l[i]); maxn = max(maxn, c[i]);//已有洞穴中的编号最大的洞穴 &#125; for (int i = maxn; i &lt;= MAXM; ++i)//枚举洞穴个数，注意最小值为编号最大的洞穴 if (judge(i)) &#123; write(i); putchar('\n'); return 0; &#125; return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>数论数学</tag>
        <tag>NOI</tag>
        <tag>2002</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2421」「NOI2002」荒岛野人]]></title>
    <url>%2Fproblems%2Fluogu-p2421%2F</url>
    <content type="text"><![CDATA[Descripion岛上有 $m$ 个洞穴，顺时针编号为 $1 \sim m$ 。岛上有 $n\ (1 \leq n \leq 15)$ 个野人分别住在 $c_1,c_2,\ldots,c_n\ (1 \leq c_i \leq 100)$ 中。以后每年，第 $i$ 个野人会沿顺时针向前走 $p_i\ (1 \leq p_i \leq 100)$ 个洞住下来，其中第 $i$ 个野人可以生存 $l_i$ 年。没有 $2$ 个野人能在有生之年生存在同一个洞穴中，求洞穴个数 $m\ (m \leq 10^6)$ 的最小值。 Source[Luogu]P2421 Solution 前置知识： 扩展欧几里得(exgcd)算法 对于 野人 $i$ 和 野人 $j$ $(i \neq j)$，假设经过 $x$ 天之后他们会在同一个洞穴相遇，那么可以得出方程： c_i + p_ix \equiv c_j + p_jx \pmod m化简方程，得到 (p_i - p_j)x \equiv c_j - c_i \pmod m这个方程等价于 (p_i - p_j)x + m \times y = c_j - c_i显然我们可以用 exgcd(扩展欧几里得) 算法求出方程 $(p_i - p_j)x + m \times y = \gcd(p_i-p_j,m)$ 的一个解 $x’$ 。 如果 $\gcd(p_i-p_j,m) \nmid c_j-c_i$，说明 $x$ 无解，野人 $i,j$ 永远不会相遇。 若有解，我们求出 $x$ 的最小正整数解，即 x = \left( x' \times \frac{c_j - c_i}{\gcd(p_i-p_j,m)} \bmod \frac{m}{\gcd(p_i-p_j,m)} + \frac{m}{\gcd(p_i-p_j,m)} \right) \bmod \frac{m}{\gcd(p_i-p_j,m)}如果 $x &gt; \min(l_i,l_j)$，说明在他们相遇之前，$i, j$ 中会有至少一个野人死亡，所以也是可行的。 如果 $x \leq \min(l_i,l_j)$，说明 野人 $i,j$ 会在死亡前相遇，这个 $m$ 不可行。 我们只需要枚举每一个可能的 $m$（题目保证 $m \leq 10^6$），枚举每一对野人 $(i,j)$，用 exgcd 求解 $x$ 并判断这个 $m$ 是否满足要求。还有一些小细节：用 exgcd 时必须保证 $p_i \geq p_j$，因为 $\gcd$ 只对 非负整数 有意义。总时间复杂度为 $O( n^2m\log p_i)$ 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 15, MAXM = 1e6;int n, maxn, c[MAXN + 5], p[MAXN + 5], l[MAXN + 5];int exGcd(int a, int b, int &amp;x, int &amp;y) &#123; if (b == 0) &#123; x = 1, y = 0; return a; &#125; int d = exGcd(b, a % b, y, x); y -= a / b * x; return d;&#125;inline bool judge(int m) &#123;//判断这个 m 是否可行 for (int i = 1; i &lt; n; ++i) for (int j = i + 1; j &lt;= n; ++j) &#123;//枚举每一对野人 int pi = p[i], pj = p[j], ci = c[i], cj = c[j], x, y, d; if (pi &lt; pj) &#123; swap(pi, pj); swap(ci, cj); &#125; //如果 pi &lt; pj，不满足 gcd 要求，交换 d = exGcd(pi - pj, m, x, y);//d = gcd(pi - pj, m) if ((cj - ci) % d != 0) continue;//x 无解，野人 i,j 不可能相遇 int p = m / d; x *= (cj - ci) / d; x = (x % p + p) % p;//x 的最小整数解 if (x &lt;= min(l[i], l[j])) return 0;//这个 m 不符合题意 &#125; return 1;&#125;int main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) &#123; read(c[i]), read(p[i]), read(l[i]); maxn = max(maxn, c[i]);//已有洞穴中的编号最大的洞穴 &#125; for (int i = maxn; i &lt;= MAXM; ++i)//枚举洞穴个数，注意最小值为编号最大的洞穴 if (judge(i)) &#123; write(i); putchar('\n'); return 0; &#125; return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>数论数学</tag>
        <tag>NOI</tag>
        <tag>2002</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 338D」GCD Table]]></title>
    <url>%2Fproblems%2Fcodeforces-338d%2F</url>
    <content type="text"><![CDATA[Description给定一个 $n \times m\ (1 \leq n,m \leq 10^{12})$ 的表 格，其中 第 $i$ 行，第 $j$ 列 的元素是 $\gcd(i,j)$ 。现在有一个长度为 $k\ (1\leq k \leq 10^4)$ 的序列 $a\ (1 \leq a_i \leq 10^{12})$，询问在表格内是否存在 $x,y\ (1 \leq x \leq n,1 \leq y \leq m - k +1)$，满足对于任意一个 $l$， 都有 $\gcd(x,y+l-1) = a_l\ (1 \leq l \leq k)$（即这个序列在表格的某一行中出现过）。 Source[Luogu]CF338D [Codeforces]338D Solution 前置知识： 扩展中国剩余定理(exCRT) 由题意得 \left\{\begin{matrix} \begin{aligned} \gcd(x,y)&=a_1\\[1ex] \gcd(x,y+1)&=a_2\\[1ex] \gcd(x,y+2)&=a_3\\[1ex] &\cdots\\[1ex] \gcd(x,y + k - 1) &= a_k \end{aligned} \end{matrix}\right.显然对于所有的 $a_i\ (1 \leq i \leq k)$ 都满足 $a_i \mid x$，所以 ${\rm lcm}\begin{Bmatrix}a_1,a_2,a_3,\ldots,a_k\end{Bmatrix} \mid x$ 。假设 $x = k \times lcm$（$k$ 是正整数），那么 $\gcd(k \times lcm,y+i-1) = a_i$，也就是说要限制 $\gcd\left( k \times \frac{lcm}{a_i},\frac{y+i-1}{a_i} \right) = 1$ 。取 $k = 1$ 时，对该式子的影响最小，由此能够得到 $x={\rm lcm}\begin{Bmatrix}a_1,a_2,a_3,\ldots,a_k\end{Bmatrix}$ 。 至于 $y$ 呢？由上述方程组能够得到 \left\{\begin{matrix} \begin{aligned} a_1 &\mid y\\[1ex] a_2 &\mid y + 1\\[1ex] a_3 &\mid y + 2\\[1ex] &\cdots\\[1ex] a_k &\mid y + k - 1 \end{aligned} \end{matrix}\right.\\[10ex] \Leftrightarrow \left\{\begin{matrix} \begin{aligned} y &\equiv 0 \pmod {a_1}\\[1ex] y + 1 &\equiv 0 \pmod {a_2}\\[1ex] y + 2 &\equiv 0 \pmod {a_3}\\[1ex] &\cdots\\[1ex] y + k-1&\equiv 0 \pmod {a_k} \end{aligned} \end{matrix}\right.根据同余式的性质，化简该方程组，得到 \left\{\begin{matrix} \begin{aligned} y &\equiv 0 \pmod {a_1}\\[1ex] y &\equiv -1 \pmod {a_2}\\[1ex] y &\equiv -2 \pmod {a_3}\\[1ex] &\cdots\\[1ex] y &\equiv 1-k \pmod {a_k} \end{aligned} \end{matrix}\right.这是一个线性同余方程组，且模数不一定两两互质，所以能用 扩展中国剩余定理(exCRT) 求出 $y$ 的最小正整数解。 难道只需要考虑 $y$ 的最小正整数解吗？实际上 $y + k \times {\rm lcm}\begin{Bmatrix}a_1,a_2,a_3,\ldots,a_k\end{Bmatrix}$ 都是这个方程组的解，但因为 $\gcd(lcm, y) = \gcd(lcm,y + lcm) =\gcd(lcm,y +k\times lcm)$（原理：更相减损法），所以没必要尝试。 求出了 $x$ 和 $y$ 还没有结束，因为只满足 $a_i \mid x$ 和 $a_i \mid y + i -1\ (1 \leq i \leq k)$，可能会出现 $\gcd(x,y+i-1)\neq a_i$（即 $\gcd \left( \frac{x}{a_i},\frac{y+i-1}{a_i} \right) \neq 1$）的情况，所以要验证该解是否成立。总时间复杂度为 $O(k \log a_i)$ 。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1e4;int k;LL ans, n, m, a[MAXN + 5], b[MAXN + 5];inline LL slowMul(LL x, LL p, LL mod) &#123; LL res = 0; for (; p; p &gt;&gt;= 1, x = (x + x) % mod) if (p &amp; 1) res = (res + x) % mod; return res;&#125;LL gcd(LL a, LL b) &#123; return !b ? a : gcd(b, a % b); &#125;LL exGcd(LL a, LL b, LL &amp;x, LL &amp;y) &#123; if (!b) &#123; x = 1, y = 0; return a; &#125; LL d = exGcd(b, a % b, y, x); y -= a / b * x; return d;&#125;inline LL exCrt(LL *a, LL *b, LL &amp;lcm) &#123;//求解 ans ≡ a[i] (mod b[i]) LL res = a[1]; lcm = b[1];//第一个方程的解 for (int i = 2; i &lt;= k; ++i) &#123; LL x, y, c = ((a[i] - res) % b[i] + b[i]) % b[i], d = exGcd(lcm, b[i], x, y), m = b[i] / d; if (c % d) return -1;//无解 x = slowMul(x, c / d, m); res += lcm * x; lcm *= m; if (lcm &gt; n) return -1;//如果 lcm&#123;a[i]&#125; 比 n 大，肯定找不到合适的 x 满足题意 res = (res + lcm) % lcm; &#125; return res == 0 ? lcm : res;//y 的值不能为 0，所以最小正整数解为 lcm&#125;int main() &#123; read(n), read(m), read(k); for (int i = 1; i &lt;= k; ++i) &#123; read(a[i]); b[i] = ((1 - i) % a[i] + a[i]) % a[i]; &#125;//y ≡ 1 - i (mod a[i]) LL x, y = exCrt(b, a, x);//同余的数是 b[i]，模数是 a[i] if (y == -1 || y &gt; m - k + 1) &#123;//y 无解 或 超出表格 puts("NO"); return 0; &#125; for (int i = 1; i &lt;= k; ++i) if (gcd(x, y + i - 1) != a[i]) &#123; puts("NO"); return 0; &#125;//验证该解是否成立 puts("YES"); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>数论数学</tag>
        <tag>中国剩余定理</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 1477」青蛙的约会]]></title>
    <url>%2Fproblems%2Fbzoj-1477%2F</url>
    <content type="text"><![CDATA[Descripion环形数轴长 $L\ (0 &lt; L &lt; 2.1 \times 10^9)$ 米（单位长度 $1$ 米），上面有两只青蛙，向正方向跳跃，出发点分别为 $x$ 和 $y\ (0 &lt; x \neq y &lt; 2 \times 10^9)$，一次分别能跳 $m$ 米 和 $n$ 米 $(0 &lt; m,n &lt; 2 \times 10^9)$，两只青蛙跳一次所花的时间相同，求最少跳几次才能相遇。若永远不能相遇，输出 Impossible 。 Source[BZOJ]1477 Solution 前置知识： 扩展欧几里得(exgcd)算法 假设两只青蛙跳 $a$ 步能够相遇，则有方程 x + am \equiv y + an \pmod L根据同余式的性质，化简得到 (m-n)a \equiv y - x \pmod L这个方程等价于 (m - n)a + L \times b = y - x我们只有 $a$ 和 $b$ 未知，其它量都已知，这不就是一个形如 $ax + by = c$ 的 不定方程 吗？ 我们可以用 exgcd（扩展欧几里得） 算法求出方程 $(m-n)a + L \times b = \gcd(m - n, L)$ 中 $a$ 的一个解 ${a}’$ 。 值得注意的是，$\gcd$ 只对 非负整数 有意义。所以一定要保证 $m \geq n$，若 $m &lt; n$，则在 exgcd 前交换两只青蛙的信息即可。 如果方程 $(m - n)a + L \times b = y - x$ 有解，则一定满足 $y - x \mid \gcd(m - n, L)$，否则无解（输出 Impossible）。 若方程有解，则 $a$ 实际的解为 ${a}’ \times \frac{y-x}{\gcd(m - n, L)}$，可这只是这个不定方程的特解，不一定是最小正整数解。 我们让 $L = \frac{L}{\gcd(m - n, L)}$，最小正整数解即为 $\left( a \bmod L + L\right) \bmod L$ 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;LL exGcd(LL a, LL b, LL &amp;x, LL &amp;y) &#123; if (!b) &#123; x = 1, y = 0; return a; &#125; LL d = exGcd(b, a % b, y, x); y -= a / b * x; return d;&#125;LL x, y, m, n, l, d, a, b;int main() &#123; read(x), read(y), read(m), read(n), read(l); if (m &lt; n) &#123; swap(m, n); swap(x, y); &#125;//m &lt; n，则交换两只青蛙的信息 d = exGcd(m - n, l, a, b);//扩展欧几里得求解不定方程，其中 d = gcd(m - n, L) if ((y - x) % d == 0) &#123; a *= (y - x) / d;//a 实际的解 l /= d; write((a % l + l) % l); putchar('\n'); &#125; else puts("Impossible");//无解 return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>数论数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P1516」青蛙的约会]]></title>
    <url>%2Fproblems%2Fluogu-p1516%2F</url>
    <content type="text"><![CDATA[Descripion环形数轴长 $L\ (0 &lt; L &lt; 2.1 \times 10^9)$ 米（单位长度 $1$ 米），上面有两只青蛙，向正方向跳跃，出发点分别为 $x$ 和 $y\ (0 &lt; x \neq y &lt; 2 \times 10^9)$，一次分别能跳 $m$ 米 和 $n$ 米 $(0 &lt; m,n &lt; 2 \times 10^9)$，两只青蛙跳一次所花的时间相同，求最少跳几次才能相遇。若永远不能相遇，输出 Impossible 。 Source[Luogu]P1516 Solution 前置知识： 扩展欧几里得(exgcd)算法 假设两只青蛙跳 $a$ 步能够相遇，则有方程 x + am \equiv y + an \pmod L根据同余式的性质，化简得到 (m-n)a \equiv y - x \pmod L这个方程等价于 (m - n)a + L \times b = y - x我们只有 $a$ 和 $b$ 未知，其它量都已知，这不就是一个形如 $ax + by = c$ 的 不定方程 吗？ 我们可以用 exgcd（扩展欧几里得） 算法求出方程 $(m-n)a + L \times b = \gcd(m - n, L)$ 中 $a$ 的一个解 ${a}’$ 。 值得注意的是，$\gcd$ 只对 非负整数 有意义。所以一定要保证 $m \geq n$，若 $m &lt; n$，则在 exgcd 前交换两只青蛙的信息即可。 如果方程 $(m - n)a + L \times b = y - x$ 有解，则一定满足 $y - x \mid \gcd(m - n, L)$，否则无解（输出 Impossible）。 若方程有解，则 $a$ 实际的解为 ${a}’ \times \frac{y-x}{\gcd(m - n, L)}$，可这只是这个不定方程的特解，不一定是最小正整数解。 我们让 $L = \frac{L}{\gcd(m - n, L)}$，最小正整数解即为 $\left( a \bmod L + L\right) \bmod L$ 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;LL exGcd(LL a, LL b, LL &amp;x, LL &amp;y) &#123; if (!b) &#123; x = 1, y = 0; return a; &#125; LL d = exGcd(b, a % b, y, x); y -= a / b * x; return d;&#125;LL x, y, m, n, l, d, a, b;int main() &#123; read(x), read(y), read(m), read(n), read(l); if (m &lt; n) &#123; swap(m, n); swap(x, y); &#125;//m &lt; n，则交换两只青蛙的信息 d = exGcd(m - n, l, a, b);//扩展欧几里得求解不定方程，其中 d = gcd(m - n, L) if ((y - x) % d == 0) &#123; a *= (y - x) / d;//a 实际的解 l /= d; write((a % l + l) % l); putchar('\n'); &#125; else puts("Impossible");//无解 return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>数论数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 2705」「SDOI2012」Longge的问题]]></title>
    <url>%2Fproblems%2Fbzoj-2705%2F</url>
    <content type="text"><![CDATA[Descrption给定一个正整数 $n\ (0 &lt; n \leq 2^{32})$，求 $\sum\limits_{i=1}^{n}\gcd(i,n)$ 。 Source[BZOJ]2705 Solution 前置知识： 常见积性函数 - 欧拉函数 - 求一个数的欧拉函数值 假设 $\gcd(i,n) = d\ (1 \leq i \leq n) $，则 $\gcd(\frac{i}{d},\frac{n}{d}) = 1$ 。 因为 $d \mid n$，所以 $d$ 一定是 $n$ 的因数。对于某一个 $d$，我们设 $i = d \times x\ (\frac{1}{d} \leq x \leq \frac{n}{d})$，则 \gcd(\frac{i}{d},\frac{n}{d}) = \gcd(x,\frac{n}{d}) = 1有多少个符合条件的 $x$ 与 $\frac{n}{d}$ 互质呢？显然有 $\varphi(\frac{n}{d})$ 个。而 $d$ 是一个定值，所以也同样有 $\varphi(\frac{n}{d})$ 个 $i$ 满足 $\gcd(i,n) = d$，这个 $d$ 所产生的贡献即为 $\varphi(\frac{n}{d}) \times d$ 。枚举每一个因数 $d$，把它们的贡献加起来就能得到答案，即 \sum\limits_{d \mid n} \left[ \varphi \left(\frac{n}{d} \right) \times d \right]枚举因数 $d$，只需要 $O(\sqrt n)$ 的时间复杂度。$n$ 最大为 $2^{32}$，肯定不能 $O(n)$ 预处理出 $\varphi(1) \sim \varphi(n)$，所以可以用 $O(\sqrt n)$ 的时间复杂度求出一个数的欧拉函数值。总时间复杂度为 $O(n\ 的因数个数 \times \sqrt n)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;inline LL getPhi(LL n) &#123; LL res = n; for (LL i = 2; i * i &lt;= n; ++i) if (n % i == 0) &#123; res -= res / i; for (; n % i == 0; n /= i); &#125; if (n &gt; 1) res -= res / n; return res;&#125;//求一个数的欧拉函数值 LL ans, n;int main() &#123; read(n); for (LL i = 1; i * i &lt;= n; ++i)//枚举 n 的约数 d if (n % i == 0) &#123; LL d1 = i, d2 = n / i;//得到因数 i 和 n / i ans += d1 * getPhi(n / d1); if (d1 != d2) ans += d2 * getPhi(n / d2);//d1 = d2 时只能加一次答案 &#125; write(ans); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>SDOI</tag>
        <tag>数论数学</tag>
        <tag>2012</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2303」「SDOI2012」Longge的问题]]></title>
    <url>%2Fproblems%2Fluogu-p2303%2F</url>
    <content type="text"><![CDATA[Descrption给定一个正整数 $n\ (0 &lt; n \leq 2^{32})$，求 $\sum\limits_{i=1}^{n}\gcd(i,n)$ 。 Source[Luogu]P2303 Solution 前置知识： 常见积性函数 - 欧拉函数 - 求一个数的欧拉函数值 假设 $\gcd(i,n) = d\ (1 \leq i \leq n) $，则 $\gcd(\frac{i}{d},\frac{n}{d}) = 1$ 。 因为 $d \mid n$，所以 $d$ 一定是 $n$ 的因数。对于某一个 $d$，我们设 $i = d \times x\ (\frac{1}{d} \leq x \leq \frac{n}{d})$，则 \gcd(\frac{i}{d},\frac{n}{d}) = \gcd(x,\frac{n}{d}) = 1有多少个符合条件的 $x$ 与 $\frac{n}{d}$ 互质呢？显然有 $\varphi(\frac{n}{d})$ 个。而 $d$ 是一个定值，所以也同样有 $\varphi(\frac{n}{d})$ 个 $i$ 满足 $\gcd(i,n) = d$，这个 $d$ 所产生的贡献即为 $\varphi(\frac{n}{d}) \times d$ 。枚举每一个因数 $d$，把它们的贡献加起来就能得到答案，即 \sum\limits_{d \mid n} \left[ \varphi \left(\frac{n}{d} \right) \times d \right]枚举因数 $d$，只需要 $O(\sqrt n)$ 的时间复杂度。$n$ 最大为 $2^{32}$，肯定不能 $O(n)$ 预处理出 $\varphi(1) \sim \varphi(n)$，所以可以用 $O(\sqrt n)$ 的时间复杂度求出一个数的欧拉函数值。总时间复杂度为 $O(n\ 的因数个数 \times \sqrt n)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;inline LL getPhi(LL n) &#123; LL res = n; for (LL i = 2; i * i &lt;= n; ++i) if (n % i == 0) &#123; res -= res / i; for (; n % i == 0; n /= i); &#125; if (n &gt; 1) res -= res / n; return res;&#125;//求一个数的欧拉函数值 LL ans, n;int main() &#123; read(n); for (LL i = 1; i * i &lt;= n; ++i)//枚举 n 的约数 d if (n % i == 0) &#123; LL d1 = i, d2 = n / i;//得到因数 i 和 n / i ans += d1 * getPhi(n / d1); if (d1 != d2) ans += d2 * getPhi(n / d2);//d1 = d2 时只能加一次答案 &#125; write(ans); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>SDOI</tag>
        <tag>数论数学</tag>
        <tag>2012</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 2818」Gcd]]></title>
    <url>%2Fproblems%2Fbzoj-2818%2F</url>
    <content type="text"><![CDATA[Description给定一个整数 $n\ (1 \leq n \leq 10^7)$，求满足 $\gcd(x,y)\ (1 \leq x, y \leq n)$ 为质数的数对 $(x,y)$ 的个数。 Source[BZOJ]2818 Solution 前置知识： 常见积性函数 - 欧拉函数 - 线性筛求欧拉函数 如果 $\gcd(x,y) = 1$，那么 $\gcd(x \times p, y \times p) = p$，只需要满足 $p$ 是质数，就能符合题意。显然我们只需要找满足 $\gcd(x,y) = 1$ 的 $(x,y)$ 的对数，$\gcd(x,y) = 1$ 等价于 $x$ 与 $y$ 互质，很容易联想到 欧拉函数 。 假设 $x \leq y \leq n$，若 $\gcd(x,y) = 1$，则 $x$ 的取值有 $\varphi(y)$ 种，而 $y$ 的值可以取 $1 \sim n$，所以 $(x,y)$ 共 $\sum\limits_{i=1}^{n}\varphi(i)$ 对。在这道题中，还是假设 $x \leq y\leq n $，若 $\gcd(x \times p, y \times p) = p$，$p$ 是质数，则 $y \times p$ 一定不大于 $n$，也就是说，$y \leq \left \lfloor \frac{n}{p} \right \rfloor$ 。因为同时需要满足 $\gcd(x,y) = 1$，所以此时 $(x,y)$ 的对数为 $\sum\limits_{i=1}^{\left \lfloor \frac{n}{p} \right \rfloor}\varphi(i)$，而 $p$ 可以是 $n$ 以内的任何一个质数，因此我们需要枚举每一个 $p$，最后答案为 $\sum\limits_{p \in prime}^{n}\sum\limits_{i=1}^{\left \lfloor \frac{n}{p} \right \rfloor}\varphi(i)$ 。注意这是在 $x \leq y$ 条件下的答案，$\gcd(x,y)$ 与 $\gcd(y,x)$ 算不同的答案，计入答案时要乘 $2$，其中 $\gcd(1 \times p,1\times p)$ 被算了 $2$ 遍，所以还要减 $1$，即 \sum\limits_{p \in prime}^{n}\left [\left( 2\sum\limits_{i=1}^{\left \lfloor \frac{n}{p} \right \rfloor}\varphi(i)\right ) -1\right ]因为要多次求 $\sum\limits_{i=1}^{\left \lfloor \frac{n}{p} \right \rfloor}\varphi(i)$，我们可以预处理出 $\varphi(1) \sim \varphi(n)$ 的 前缀和，整道题的时间复杂度为 $O(n)$ 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1e7, MAXP = 1e6;int n, cnt, prime[MAXP], phi[MAXN];LL ans, pre[MAXN + 5];bool isNotPrime[MAXN + 5];inline void getPhi(int n) &#123; isNotPrime[1] = 1; phi[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; if (!isNotPrime[i]) &#123; prime[++cnt] = i; phi[i] = i - 1; &#125; for (int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n; ++j) &#123; isNotPrime[i * prime[j]] = 1; if (i % prime[j] == 0) &#123; phi[i * prime[j]] = phi[i] * prime[j]; break; &#125; else phi[i * prime[j]] = phi[i] * (prime[j] - 1); &#125; &#125;&#125;int main() &#123; read(n); getPhi(n);//线性筛求 n 以内的质数 和 欧拉函数 for (int i = 1; i &lt;= n; ++i) pre[i] = pre[i - 1] + phi[i];//预处理欧拉函数前缀和 for (int i = 1; i &lt;= cnt; ++i)//枚举 gcd(x * prime[i], y * prime[i]) = prime[i] ans += (LL) pre[n / prime[i]] * 2 - 1;//gcd(1 * prime[i], 1 * prime[i]) 算了 2 遍，要减 1 write(ans); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>数论数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2568」GCD]]></title>
    <url>%2Fproblems%2Fluogu-p2568%2F</url>
    <content type="text"><![CDATA[Description给定一个整数 $n\ (1 \leq n \leq 10^7)$，求满足 $\gcd(x,y)\ (1 \leq x, y \leq n)$ 为质数的数对 $(x,y)$ 的个数。 Source[Luogu]P2568 Solution 前置知识： 常见积性函数 - 欧拉函数 - 线性筛求欧拉函数 如果 $\gcd(x,y) = 1$，那么 $\gcd(x \times p, y \times p) = p$，只需要满足 $p$ 是质数，就能符合题意。显然我们只需要找满足 $\gcd(x,y) = 1$ 的 $(x,y)$ 的对数，$\gcd(x,y) = 1$ 等价于 $x$ 与 $y$ 互质，很容易联想到 欧拉函数 。 假设 $x \leq y \leq n$，若 $\gcd(x,y) = 1$，则 $x$ 的取值有 $\varphi(y)$ 种，而 $y$ 的值可以取 $1 \sim n$，所以 $(x,y)$ 共 $\sum\limits_{i=1}^{n}\varphi(i)$ 对。在这道题中，还是假设 $x \leq y\leq n $，若 $\gcd(x \times p, y \times p) = p$，$p$ 是质数，则 $y \times p$ 一定不大于 $n$，也就是说，$y \leq \left \lfloor \frac{n}{p} \right \rfloor$ 。因为同时需要满足 $\gcd(x,y) = 1$，所以此时 $(x,y)$ 的对数为 $\sum\limits_{i=1}^{\left \lfloor \frac{n}{p} \right \rfloor}\varphi(i)$，而 $p$ 可以是 $n$ 以内的任何一个质数，因此我们需要枚举每一个 $p$，最后答案为 $\sum\limits_{p \in prime}^{n}\sum\limits_{i=1}^{\left \lfloor \frac{n}{p} \right \rfloor}\varphi(i)$ 。注意这是在 $x \leq y$ 条件下的答案，$\gcd(x,y)$ 与 $\gcd(y,x)$ 算不同的答案，计入答案时要乘 $2$，其中 $\gcd(1 \times p,1\times p)$ 被算了 $2$ 遍，所以还要减 $1$，即 \sum\limits_{p \in prime}^{n}\left [\left( 2\sum\limits_{i=1}^{\left \lfloor \frac{n}{p} \right \rfloor}\varphi(i)\right ) -1\right ]因为要多次求 $\sum\limits_{i=1}^{\left \lfloor \frac{n}{p} \right \rfloor}\varphi(i)$，我们可以预处理出 $\varphi(1) \sim \varphi(n)$ 的 前缀和，整道题的时间复杂度为 $O(n)$ 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1e7, MAXP = 1e6;int n, cnt, prime[MAXP], phi[MAXN];LL ans, pre[MAXN + 5];bool isNotPrime[MAXN + 5];inline void getPhi(int n) &#123; isNotPrime[1] = 1; phi[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; if (!isNotPrime[i]) &#123; prime[++cnt] = i; phi[i] = i - 1; &#125; for (int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n; ++j) &#123; isNotPrime[i * prime[j]] = 1; if (i % prime[j] == 0) &#123; phi[i * prime[j]] = phi[i] * prime[j]; break; &#125; else phi[i * prime[j]] = phi[i] * (prime[j] - 1); &#125; &#125;&#125;int main() &#123; read(n); getPhi(n);//线性筛求 n 以内的质数 和 欧拉函数 for (int i = 1; i &lt;= n; ++i) pre[i] = pre[i - 1] + phi[i];//预处理欧拉函数前缀和 for (int i = 1; i &lt;= cnt; ++i)//枚举 gcd(x * prime[i], y * prime[i]) = prime[i] ans += (LL) pre[n / prime[i]] * 2 - 1;//gcd(1 * prime[i], 1 * prime[i]) 算了 2 遍，要减 1 write(ans); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>数论数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 24D」Broken robot]]></title>
    <url>%2Fproblems%2Fcodeforces-24d%2F</url>
    <content type="text"><![CDATA[Description现在有一个机器人，最初站在 $n \times m\ (1 \leq n,m\leq 1000)$ 矩阵中的 $(x,y)\ (1 \leq x \leq n, 1\leq y \leq m)$ 位置。每次它会等概率的选择 原地不动，向左移动，向右移动，向下移动 四种操作。当然，机器人在第 $1$ 列时不会选择向左移动，第 $m$ 列时不会选择向右移动。求机器人到达第 $n$ 行的期望步数，至少精确到 $10^{-4}$ 。 Source[Luogu]CF24D [Codeforces]24D Solution 前置知识： 高斯(Gauss)消元 求期望步数，很容易想到 期望DP 。我们用 $f_{i,j}$ 表示从 $(i,j)$ 走到最后一行的期望步数，那么初始状态就是 $f_{n,i} = 0\ (1 \leq i \leq m)$（从最后一行走到最后一行的期望步数为 $0$），要求的答案就是 $f_{x,y}$（根据状态即能得到），状态转移方程如下（分 $3$ 种情况讨论）： \large{f_{i,j}=\left\{\begin{matrix} \frac{1}{3}\left ( f_{i,j} + f_{i,j+1} + f_{i+1,j} \right )+1& (j=1)\\[2ex] \frac{1}{4}\left ( f_{i,j} + f_{i,j+1} + f_{i,j-1} + f_{i+1,j} \right )+1& (1< j< m) \\[2ex] \frac{1}{3}\left ( f_{i,j} + f_{i,j-1} + f_{i+1,j} \right )+1& (j=m) \\ \end{matrix}\right.}值得注意的是：$m = 1​$ 时比较特殊，因为不能向左和向右移动，此时 \large{f_{i,j}=\frac{1}{2} \left( f_{i,j} + f_{i+1,j} \right) + 1}这个转移方程是倒推的，并且有后效性，所以不能直接转移。在求 $f_{i,j}​$ 时，$f_{i+1,j}​$ 是 已知 的，而 $f_{i,j-1},f_{i,j},f_{i,j+1}​$ 都是 未知 的，我们把未知量移到左边，把已知量移到右边，可以得到： \large{\left\{\begin{matrix} -\frac{2}{3}f_{i,j}+\frac{1}{3}f_{i,j+1}=-\frac{1}{3}f_{i+1,j}-1 & (j=1)\\[2ex] \frac{1}{4}f_{i,j-1}-\frac{3}{4}f_{i,j}+\frac{1}{4}f_{i,j+1}=-\frac{1}{4}f_{i+1,j}-1& (1 < j < m)\\[2ex] \frac{1}{3}f_{i,j-1}-\frac{2}{3}f_{i,j}=-\frac{1}{3}f_{i+1,j}-1 & (j=m)\\ \end{matrix}\right.}同理，$m = 1​$ 时， \large{-\frac{1}{2}f_{i,j} = -\frac{1}{2}f_{i+1,j} - 1}我们会发现一共有 $m​$ 个未知数和 $m​$ 个方程，很容易想到 高斯消元 求解未知量 $f_{i,1} \sim f_{i,m}\ (1 \leq i &lt; n)​$ 。 比如说，当 $m = 5​$ 时，所构成的矩阵就是： \large{\begin{bmatrix} -\frac{2}{3} & \color{blue}{\frac{1}{3}} & 0 & 0 & 0\\[1ex] \color{red}{\frac{1}{4}} & -\frac{3}{4} & \color{blue}{\frac{1}{4}} & 0 & 0\\[1ex] 0 & \color{red}{\frac{1}{4}} & -\frac{3}{4} & \color{blue}{\frac{1}{4}} & 0\\[1ex] 0 & 0 & \color{red}{\frac{1}{4}} & -\frac{3}{4} & \color{blue}{\frac{1}{4}}\\[1ex] 0 & 0 & 0 & \color{red}{\frac{1}{3}} & -\frac{2}{3}\\[1ex] \end{bmatrix} =\begin{bmatrix} -\frac{1}{3}f_{i+1,j}-1\\[1ex] -\frac{1}{4}f_{i+1,j}-1\\[1ex] -\frac{1}{4}f_{i+1,j}-1\\[1ex] -\frac{1}{4}f_{i+1,j}-1\\[1ex] -\frac{1}{3}f_{i+1,j}-1\\ \end{bmatrix}}本来 高斯消元 的时间复杂度应该是 $O(n^3)​$ 的。但是观察矩阵能够发现，其实这是一个稀疏矩阵，未知数全部集中在对角线上，$0​$ 的地方不需要消元，我们需要消元的只有 $m - 1​$ 个数（上图 $\color{red}{红色}​$ 的数字），回带时原方程中也只需要消去 $m - 1​$ 个数（上图 $\color{blue}{蓝色}​$ 的数字），所以本题中 高斯消元 时间复杂度为 $O(m)​$ 。总时间复杂度为 $O(nm)​$ 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;const int MAXN = 1000;int n, m, x, y;double a[MAXN + 5][MAXN + 5], f[MAXN + 5][MAXN + 5];inline void Gauss() &#123; for (int i = 1; i &lt; m; ++i) &#123; double t = a[i][i]; a[i][i] = 1; a[i][i + 1] /= t; a[i][m + 1] /= t; t = a[i + 1][i]; a[i + 1][i] = 0; a[i + 1][i + 1] -= t * a[i][i + 1]; a[i + 1][m + 1] -= t * a[i][m + 1]; &#125;//消元，消去下一行方程开头的未知数 a[m][m + 1] /= a[m][m]; a[m][m] = 1;//求出最后一个未知数的解 for (int i = m - 1; i; --i) a[i][m + 1] -= a[i + 1][m + 1] * a[i][i + 1];//回带，消去下一行方程末尾的未知数&#125;int main() &#123; read(n), read(m), read(x), read(y); for (int i = n - 1; i &gt;= x; --i) &#123; if (m == 1) &#123; a[1][1] = -1.0 / 2; a[1][m + 1] = -f[i + 1][1] / 2.0 - 1;//特判 m = 1 &#125; else &#123; a[1][1] = -2.0 / 3; a[1][2] = 1.0 / 3; a[1][m + 1] = -f[i + 1][1] / 3.0 - 1.0; for (int j = 2; j &lt; m; ++j) &#123; a[j][j] = -3.0 / 4; a[j][j - 1] = a[j][j + 1] = 1.0 / 4; a[j][m + 1] = -f[i + 1][j] / 4.0 - 1; &#125; a[m][m] = -2.0 / 3; a[m][m - 1] = 1.0 / 3; a[m][m + 1] = -f[i + 1][m] / 3.0 - 1; &#125;//构造矩阵 Gauss();//高斯消元 for (int j = 1; j &lt;= m; ++j) f[i][j] = a[j][m + 1];//赋值求出的解 &#125; printf("%.10lf\n", f[x][y]); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>数论数学</tag>
        <tag>概率期望</tag>
        <tag>Codeforces</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见积性函数]]></title>
    <url>%2Fnotes%2Fchang-jian-ji-xing-han-shu%2F</url>
    <content type="text"><![CDATA[定义积性函数 指对于 任意互质的整数 $a$ 和 $b$ 有性质 $f(ab)=f(a)\times f(b)$ 的数论函数。 完全积性函数 指对于 任意整数 $a$ 和 $b$ 有性质 $f(ab)=f(a)\times f(b)$ 的数论函数。 很显然 完全积性函数 是 积性函数 的一个子集。 积性函数欧拉函数定义：欧拉函数，属于 积性函数，但不是完全积性函数。常用 $\varphi$ 表示，读作 fai 。 $\varphi(n)$ 定义为小于等于 $n$ 的正整数中与 $n$ 互质的数的个数。 公式：若 $p_1 , p_2 ,\ldots, p_m$ 为 $x$ 的所有 互不相同 的质因数，$n$ 是一个不为 $0$ 的整数，则 \begin{aligned} \varphi(n)&=n\times\left ( 1-\frac{1}{p_1}\right )\times \left ( 1-\frac{1}{p_2}\right )\times \cdots \times \left ( 1-\frac{1}{p_m}\right )\\[2ex] &=n\prod\limits_{i=1}^{m}\left ( 1-\frac{1}{p_i}\right )\\ \end{aligned}性质 &amp; 证明：性质 1： 若 $n , m​$ 互质，则 $\varphi(nm)=\varphi(n) \times \varphi(m)​$ 。 证明： 积性函数特有性质。 性质 2： 若 $n​$ 为 质数，则 $\varphi(n)=n-1​$ 。 证明： 所有小于 $n$ 的正整数都与 $n$ 互质，一共 $n - 1​$ 个。 性质 3： 若 $n​$ 为 奇数，则 $\varphi(2n)=\varphi(n)​$ 。 证明： 显然 $n$ 与 $2$ 互质，且 $\varphi(2) = 1$，所以根据 性质 1，可得 \begin{aligned} \varphi(2n)&=\varphi(2) \times \varphi(n)\\[1ex] &=1\times \varphi(n)\\[1ex] &=\varphi(n) \end{aligned}性质 4： 若 $p$ 为质数，$n = p^k$，则 \varphi(n)=p^k-p^{k-1}证明： 由 $n=p^k$，得 $n$ 的质因数只有 $p$，再通过公式，可知 \begin{aligned} \varphi(n)&=n\times\left(1-\frac{1}{p}\right)\\[2ex] &=p^k \times \left(1-\frac{1}{p}\right)\\[2ex] &= p^k - p^{k-1} \end{aligned}性质 5： 若 $n &gt; 2​$，则 $\varphi(n)​$ 为偶数。 若 $n &gt; 1$，则小于等于 $n$ 且与 $n$ 互质的数的和为 \frac{n \times \varphi(n)}{2}证明： 首先需要知道：若 $n$ 与 $m$ 互质 $(n &gt; m)$，则 $n$ 与 $n - m$ 互质。 \begin{aligned} &\gcd(n,m)=1\\[1ex] &\gcd(n,m)=\gcd(n,n-m)\\ \end{aligned}显然与 $n$ 互质的数都是成对出现的，且相加的和为 $n$，只有在 $\gcd(n,\frac{n}{2})=1$ 时例外，但这种情况只会在 $n \leq 2$ 时出现，所以 $\varphi(n)\ (n &gt; 2)$ 为偶数得证。小于等于 $n$ 的数中，与 $n$ 互质的数的个数为 $\varphi(n)$，所以一共有 $\frac{\varphi(n)}{2}$ 对，总和为 $\frac{n \times \varphi(n)}{2}​$。 性质 6： 若正整数 $x$ 与质数 $p$ 不互质 程序：如何求出 $\varphi(n)​$ ？ 根据欧拉函数的公式我们能够得到以下代码： 123456789inline int getPhi(int n) &#123; int res = n; for (int i = 2; i &lt;= n; ++i)//枚举因数 if (n % i == 0) &#123; res -= res / i; for (; n % i == 0; n /= i);//将质因数 i 除完 &#125; return res;&#125; 在最坏情况下（$n​$ 是质数），该代码的时间复杂度为 $O(n)​$，这显然不够优秀，考虑如何优化。 任何一个整数 $n$ 都不可能存在 $2$ 个大于 $\sqrt n$ 的质因子，所以我们枚举因数时只需要遍历到 $O(\sqrt n)$ 即可，如果将小于 $\sqrt n$ 的质因子除完后，剩下的数不为 $1$，说明还有 $1$ 个大于 $\sqrt n$ 的质因子，最后要算进去。这种做法的时间复杂度为 $O(\sqrt n)$ 。 求一个数的欧拉函数值： 12345678910inline int getPhi(int n) &#123; int res = n; for (int i = 2; i * i &lt;= n; ++i) if (n % i == 0) &#123; res -= res / i; for (; n % i == 0; n /= i); &#125; if (n &gt; 1) res -= res / n; return res;&#125; 如果需要求 $\varphi(1)\sim \varphi(n)​$ 的值，用上述方法逐个求的时间复杂度为 $O(n\sqrt n)​$，有没有更快的做法呢？ 线性筛求欧拉函数： 1234567891011121314151617inline void getPhi(int n) &#123; isNotPrime[1] = 1; phi[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; if (!isNotPrime[i]) &#123; prime[++cnt] = i; phi[i] = i - 1; &#125; for (int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n; ++j) &#123; isNotPrime[i * prime[j]] = 1; if (i % prime[j] == 0) &#123; phi[i * prime[j]] = phi[i] * prime[j]; break; &#125; else phi[i * prime[j]] = phi[i] * (prime[j] - 1); &#125; &#125;&#125; 莫比乌斯函数定义：莫比乌斯函数，属于 积性函数，但不是完全积性函数。常用 $\mu$ 表示，读作 miu 。 莫比乌斯函数的定义域是全体自然数 $n$ 。 若 $n = 1$，则 $\mu(1)=1$； 若 $n$ 存在大于 $1$ 的平方因子，则 $\mu(n)=0$（平方因子即 $4 , 9 , 25$ 等）； 若 $n$ 是偶数个互不相同的质数之积，则 $\mu(n)=1$； 若 $n$ 是奇数个互不相同的质数之积，则 $\mu(n)=-1$ 。 公式： \mu(n)=\left\{\begin{matrix} 1& n=1\\[2ex] (-1)^m& n=p_1\times p_2 \times \cdots \times p_m = \prod\limits_{i=1}^{m}p_i(\forall p_i \neq p_j)\\[2ex] 0& others\\ \end{matrix}\right.性质 &amp; 证明：性质 1： 若 $n , m$ 互质，则 $\mu(nm)=\mu(n) \times \mu(m)$ 。 证明： 积性函数特有性质。 性质 2： 若 $n \neq 1$，则 $n$ 所有因子的莫比乌斯函数值的和为 $0$，即 \sum\limits_{d\mid n}\mu(d)=\left\{\begin{matrix} 1& n=1\\[2ex] 0& n>1 \end{matrix}\right.证明： 除数函数定义：除数函数，属于 积性函数，但不是完全积性函数。常用 $\sigma$ 表示，读作 sigma 。 $\sigma_x(n)$ 定义为 $n$ 的正约数的 $x$ 次幂之和，即 \sigma_x(n)=\sum\limits_{d\mid n}d^x公式：若 $p_1 , p_2 ,\ldots, p_m$ 为 $x$ 的所有质因数，$n$ 和 $x$ 都是 自然数 。 \begin{aligned} \sigma_x(n) &= (1 + p_1^x+p_1^{2x}+\cdots+p_1^{a_1x})\\[1ex] &\times (1 + p_2^x+p_2^{2x}+\cdots+p_2^{a_2x})\\[1ex] &\times (1 + p_3^x+p_3^{2x}+\cdots+p_3^{a_3x})\\[1ex] &\times \cdots \cdots\\[1ex] &\times (1 + p_m^x+p_m^{2x}+\cdots+p_m^{a_mx})\\[2ex] &=\prod\limits_{i=1}^{m}\sum\limits_{j=0}^{a_i}p_i^{jx}\\[2ex] &=\prod\limits_{i=1}^{m}\frac{p_i^{(a_i+1)x}-1}{p_i^x-1}\\ \end{aligned}性质 &amp; 证明：性质 1： 特殊地，$\sigma_0(n)$ 可以表示 $n$ 的正约数个数，$\sigma_1(n)$ 可以表示 $n​$ 的正约数之和。 证明： 根据定义即能得到该结论。 性质 2： 若 $n , m​$ 互质，且 $x​$ 是自然数，则 $\sigma_x(nm)=\sigma_x(n) \times \sigma_x(m)​$ 。 证明： 积性函数特有性质。 完全积性函数]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>数论数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的质数相关定理]]></title>
    <url>%2Fnotes%2Fchang-yong-de-zhi-shu-xiang-guan-ding-li%2F</url>
    <content type="text"><![CDATA[前言许多与质数相关的定理都是数论的基础，想要学好数论，必须掌握这些定理并且能够熟练运用。 唯一分解定理（算数基本定理）任何一个大于 $1$ 的自然数都可以表示为有限个（包括 $1$ 个）质数的乘积。 \begin{aligned} n &= p_1^{a_1} \times p_2^{a_2} \times p_3^{a_3} \times \cdots \times p_m^{a_m}\\[2ex] &= \prod\limits_{i=1}^{m}p_i^{a_i}\\ \end{aligned}其中 $p_i (1 \leq i \leq m)$ 为质数，且都是 $n$ 的质因子。 当 $p_1 &lt; p_2 &lt; \cdot \cdot \cdot &lt; p_m$ 时，该式又称为 $n$ 的 标准分解式 。 约数个数定理若 $n = \prod\limits_{i=1}^{m}p_i^{a_i}$，则 $n​$ 的约数个数可以表示为： \begin{aligned} \sigma_0(n) &= (a_1 + 1) \times (a_2+1) \times \cdots \times (a_m+1)\\[2ex] &=\prod\limits_{i=1}^{m}(a_i+1)\\ \end{aligned} $\sigma$ 是 除数函数 。具体内容请见 常见积性函数 - 除数函数 。 证明： 对于这个 $n​$，显然 $p_i^{a_i}(1 \leq i \leq m)​$ 的约数有： p_i^0,p_i^1,p_i^2,\ldots,p_i^{a_i}一共 $a_i+1$ 个。而 $n$ 的约数肯定是 $p_1^{a_1},p_2^{a_2},p_3^{a_3},\cdots,p_m^{a_m}$ 每一个数各选出一个约数的乘积。 根据 乘法原理，一共有 (a_1 + 1) \times (a_2+1) \times \cdots \times (a_m+1) =\prod\limits_{i=1}^{m}(a_i+1)种选法，即 $n$ 的约数个数。 约数和定理若 $n = \prod\limits_{i=1}^{m}p_i^{a_i}$，则 $n$ 的所有正约数之和可以表示为： \begin{aligned} \sigma_1(n) &= (p_1^0 + p_1^1+p_1^2+\cdots+p_1^{a_1})\\[1ex] &\times (p_2^0 + p_2^1+p_2^2+\cdots+p_2^{a_2})\\[1ex] &\times (p_3^0 + p_3^1+p_3^2+\cdots+p_3^{a_3})\\[1ex] &\times \cdots \cdots\\[1ex] &\times (p_m^0 + p_m^1+p_m^2+\cdots+p_m^{a_m})\\[2ex] &= \prod\limits_{i=1}^{m}\sum\limits_{j=0}^{a_i}p_i^j\\ \end{aligned}其实 $\sum\limits_{j=0}^{a_i}p_i^j$ 是一个公比为 $p_i$ 的 等比数列 的和，因此该式子也能表示为： \sigma_1(n) = \prod\limits_{i=1}^{m}\frac{p_i^{a_i+1}-1}{p_i-1} $\sigma$ 是 除数函数 。具体内容请见 常见积性函数 - 除数函数 。 证明： 咕 威尔逊定理若 $p$ 为质数，则 (p-1)! \equiv -1\pmod p威尔逊定理的 逆定理 也成立，即： 对于某一个正整数 $p$，若 $(p-1)! \equiv -1\pmod p$，则 $p$ 一定是一个质数。 证明： 咕 二次探测定理若 $p​$ 是质数，$x​$ 是小于 $p​$ 的正整数，且 $x^2 \equiv 1\pmod p​$，则 x_1=1\ ,\ x_2=p-1证明： 根据同余式的性质，两边同时减去 $1$，得到 x^2 - 1 \equiv 0\pmod p左边显然可以用 平方差公式 因式分解，得到 (x+1)(x-1)\equiv 0\pmod p这个式子等价于 p\mid (x+1)(x-1)显然 $p$ 的因子来自 $x + 1$ 和 $x - 1$，但是因为 $p$ 是一个质数，所以 $p$ 的因子只有 $1$ 和 $p$，因此一定满足 $p\mid x+1$ 或 $p\mid x-1$ 。又因为 $0 &lt; x &lt; p$，所以 $x$ 的值为 $1$ 或 $p - 1$ 。 二次探测定理的 逆定理 也成立，即： $x​$ 是小于 $p​$ 的正整数，若 $x^2 \equiv 1\pmod p​$，且 $x\neq 1 , x\neq p-1​$，则这个 $p​$ 一定不是质数。 费马小定理若 $a​$ 为正整数，$p​$ 为质数，且 $a​$ 与 $p​$ 互质，则 a^{p-1}\equiv 1\pmod p证明： 咕 欧拉定理若 $a$ 和 $p$ 都是正整数，且 $a$ 与 $p$ 互质，则 a^{\varphi(p)} \equiv 1\pmod p $\varphi​$ 是 欧拉函数 。具体内容请见 常见积性函数 - 欧拉函数 。 证明： 咕 扩展欧拉定理若 $a$ 和 $p$ 都是正整数，则 \left\{\begin{array} {ll}a^{b} \equiv {a^{b \bmod \varphi(p)}} \pmod p & {\gcd(a, p)=1} \\[2ex] a^{b} \equiv {a^{b}} \pmod p & {\gcd(a, p) \neq 1, b]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>数论数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 1607」「USACO2008 Dec」Patting Heads 轻拍牛头]]></title>
    <url>%2Fproblems%2Fbzoj-1607%2F</url>
    <content type="text"><![CDATA[Descripion给定 $n\ (1 \leq n \leq 10^5)$ 个正整数 $a_i\ (1 \leq a_i \leq 10^6)$ 。对于每一个数 $a_i$，求有多少个数 $j\ (1 \leq j \leq n)$ 满足 $a_i \mid a_j$ 且 $i \neq j$ 。 Source[BZOJ]1607 Solution看完题目很容易想到 $O(n^2)$ 的暴力算法，枚举所有 $i$ 和 $j$，显然会超时。但我们发现 $a_i$ 并不大，所以考虑另一种方法。 我们用一个桶 $cnt$ 记录 $a_i$ 出现的次数，$ans_i$ 表示 $a_i=i$ 时的答案，枚举 $i=1 \sim \max \begin{Bmatrix}a_i\end{Bmatrix}$ ，接着枚举 $i$ 以及 $i$ 的倍数，凡是等于 $i$ 或是 $i$ 的倍数的数，答案都应该加上 $i$ 出现的次数。同时因为会把自己算进去，所以答案要减 $1$ 。时间复杂度为 $O(n\log\log n)$，类似 埃拉托斯特尼筛法 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1e5, MAXM = 1e6;int n, maxn, a[MAXN + 5], cnt[MAXM + 5], ans[MAXM + 5];int main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); ++cnt[a[i]]; maxn = max(maxn, a[i]); &#125; for (int i = 1; i &lt;= maxn; ++i) &#123; if (!cnt[i]) continue;//小优化：判断 i 是否出现过 for (int j = i; j &lt;= maxn; j += i)//枚举 i 以及 i 的倍数 ans[j] += cnt[i];//如果 i | j，则让 ans[j] 增加 i 出现的次数 &#125; for (int i = 1; i &lt;= n; ++i) &#123; write(ans[a[i]] - 1);//因为 a[i] | a[i]，多算了一次自己，要减 1 putchar('\n'); &#125; return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>数论数学</tag>
        <tag>USACO</tag>
        <tag>2008</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2926」「USACO08DEC」拍头 Patting Heads]]></title>
    <url>%2Fproblems%2Fluogu-p2926%2F</url>
    <content type="text"><![CDATA[Descripion给定 $n\ (1 \leq n \leq 10^5)$ 个正整数 $a_i\ (1 \leq a_i \leq 10^6)$ 。对于每一个数 $a_i$，求有多少个数 $j\ (1 \leq j \leq n)$ 满足 $a_i \mid a_j$ 且 $i \neq j$ 。 Source[Luogu]P2926 Solution看完题目很容易想到 $O(n^2)$ 的暴力算法，枚举所有 $i$ 和 $j$，显然会超时。但我们发现 $a_i$ 并不大，所以考虑另一种方法。 我们用一个桶 $cnt$ 记录 $a_i$ 出现的次数，$ans_i$ 表示 $a_i=i$ 时的答案，枚举 $i=1 \sim \max \begin{Bmatrix}a_i\end{Bmatrix}$ ，接着枚举 $i$ 以及 $i$ 的倍数，凡是等于 $i$ 或是 $i$ 的倍数的数，答案都应该加上 $i$ 出现的次数。同时因为会把自己算进去，所以答案要减 $1$ 。时间复杂度为 $O(n\log\log n)$，类似 埃拉托斯特尼筛法 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1e5, MAXM = 1e6;int n, maxn, a[MAXN + 5], cnt[MAXM + 5], ans[MAXM + 5];int main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); ++cnt[a[i]]; maxn = max(maxn, a[i]); &#125; for (int i = 1; i &lt;= maxn; ++i) &#123; if (!cnt[i]) continue;//小优化：判断 i 是否出现过 for (int j = i; j &lt;= maxn; j += i)//枚举 i 以及 i 的倍数 ans[j] += cnt[i];//如果 i | j，则让 ans[j] 增加 i 出现的次数 &#125; for (int i = 1; i &lt;= n; ++i) &#123; write(ans[a[i]] - 1);//因为 a[i] | a[i]，多算了一次自己，要减 1 putchar('\n'); &#125; return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>数论数学</tag>
        <tag>USACO</tag>
        <tag>2008</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 2721」「Violet 5」樱花]]></title>
    <url>%2Fproblems%2Fbzoj-2721%2F</url>
    <content type="text"><![CDATA[Descripion求不定方程 \frac{1}{x} + \frac{1}{y} = \frac{1}{n!}\ (1 \leq n \leq 10^6)正整数解 $(x, y) $ 的数目，答案对 $10^9+7$ 取模。 Source[BZOJ]2721 Solution题目所给的方程一看就知道不能直接做，必须化简。 我们先把等式左边通分，得到 \frac{x+y}{xy}=\frac{1}{n!}对角相乘，得到 xy=(x+y)n!移项 xy-(x+y)n!=0根据等式的性质，两边同时加上 $(n!)^2$，得到 xy-(x+y)n!+(n!)^2=(n!)^2这时我们发现等式左边可以因式分解了，式子变为 (x-n!)(y-n!)=(n!)^2即使到了这一步，还是看不出什么，我们考虑换元。假设 $a=x-n!$，$b=y-n!$，则能得到 ab=(n!)^2很显然 $n!$ 是确定的，$a,b$ 有多少不同的正整数解， $x,y$ 就有多少不同的值能使等式成立，而 $a,b$ 都是 $(n!)^2$ 的因数，所以问题就变为求 $(n!)^2$ 的因数个数。根据 唯一分解定理： n!=p_1^{a_1} \times p_2^{a_2} \times \cdot \cdot \cdot \times p_m^{a_m}其中 $m$ 表示 $n!$ 分解出的不同质数的个数，$p_i$ 表示 $n!$ 分解出的质数，$a_i$ 表示质因子 $p_i$ 的个数，那么 (n!)^2=p_1^{2a_1} \times p_2^{2a_2} \times \cdot \cdot \cdot \times p_m^{2a_m}$(n!)^2$ 的因数个数就等于 $\prod\limits_{i=1}^{m}(2a_i+1)$ 。 这个东西怎么求呢？ 我们先用 线性筛法（欧拉筛）求出 $1\sim n$ 内的质数，并记录下每个数的最小质因子（线性筛中的合数只会被它的最小质因子筛去）。因为我们要求 $n!$ 的质因数，所以枚举 $1 \sim n$ 每一个数，依次分解它们，得到它们有哪些质因数。具体方法：每次除以它本身的最小质因子，直到这个数变成 $1$ 为止。例如求 $18$ 的因数：$18$ 的最小质因子是 $2$，就将 $a_2 +1$，$18$ 除以 $2$ 变为 $9$；再考虑 $9$，$9$ 的最小质因子是 $3$，将 $a_3 +1$，$9$ 除以 $3$ 变为 $3$；$3$ 的最小质因子是 $3$，所以将 $a_3 + 1$，$3$ 除以 $3$ 变为 $1$，停止计算 。此时我们已经可以知道：$18=2^{a_2=1}\times 3^{a_3=2} $。按上述操作处理，就能算出 $n!$ 的质因数分布，根据公式就能得到答案。同时因为最小的质数是 $2$，每次除以它的最小质因子时，最大也会变为原来的 $\frac{1}{2}$，所以时间复杂度为 $O(n\log n)$ 。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1e6;const LL MOD = 1e9 + 7;int n, cnt, a[MAXN + 5], prime[MAXN + 5], minPrime[MAXN + 5];//minPrime[i]表示 i 的最小质因子 LL ans = 1;inline void getPrime(int n) &#123; for (int i = 2; i &lt;= n; ++i) &#123; if (!minPrime[i]) &#123; minPrime[i] = i;//质数的最小质因子是它本身 prime[++cnt] = i; &#125; for (int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n; ++j) &#123; minPrime[i * prime[j]] = prime[j];//线性筛中的合数只会被最小质因子筛去 if (i % prime[j] == 0) break; &#125; &#125; &#125;int main() &#123; read(n); getPrime(n);//线性筛质数 for (int i = 1; i &lt;= n; ++i) for (int j = i; j &gt; 1; j /= minPrime[j]) ++a[minPrime[j]];//质因子计数 for (int i = 1; i &lt;= cnt; ++i) ans = ans * (LL) (a[prime[i]] &lt;&lt; 1 | 1) % MOD;//用公式求得答案 write(ans); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>数论数学</tag>
        <tag>筛法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P1445」「Violet」樱花]]></title>
    <url>%2Fproblems%2Fluogu-p1445%2F</url>
    <content type="text"><![CDATA[Descripion求不定方程 \frac{1}{x} + \frac{1}{y} = \frac{1}{n!}\ (1 \leq n \leq 10^6)正整数解 $(x, y) $ 的数目，答案对 $10^9+7$ 取模。 Source[Luogu]P1445 Solution题目所给的方程一看就知道不能直接做，必须化简。 我们先把等式左边通分，得到 \frac{x+y}{xy}=\frac{1}{n!}对角相乘，得到 xy=(x+y)n!移项 xy-(x+y)n!=0根据等式的性质，两边同时加上 $(n!)^2$，得到 xy-(x+y)n!+(n!)^2=(n!)^2这时我们发现等式左边可以因式分解了，式子变为 (x-n!)(y-n!)=(n!)^2即使到了这一步，还是看不出什么，我们考虑换元。假设 $a=x-n!$，$b=y-n!$，则能得到 ab=(n!)^2很显然 $n!$ 是确定的，$a,b$ 有多少不同的正整数解， $x,y$ 就有多少不同的值能使等式成立，而 $a,b$ 都是 $(n!)^2$ 的因数，所以问题就变为求 $(n!)^2$ 的因数个数。根据 唯一分解定理： n!=p_1^{a_1} \times p_2^{a_2} \times \cdot \cdot \cdot \times p_m^{a_m}其中 $m$ 表示 $n!$ 分解出的不同质数的个数，$p_i$ 表示 $n!$ 分解出的质数，$a_i$ 表示质因子 $p_i$ 的个数，那么 (n!)^2=p_1^{2a_1} \times p_2^{2a_2} \times \cdot \cdot \cdot \times p_m^{2a_m}$(n!)^2$ 的因数个数就等于 $\prod\limits_{i=1}^{m}(2a_i+1)$ 。 这个东西怎么求呢？ 我们先用 线性筛法（欧拉筛）求出 $1\sim n$ 内的质数，并记录下每个数的最小质因子（线性筛中的合数只会被它的最小质因子筛去）。因为我们要求 $n!$ 的质因数，所以枚举 $1 \sim n$ 每一个数，依次分解它们，得到它们有哪些质因数。具体方法：每次除以它本身的最小质因子，直到这个数变成 $1$ 为止。例如求 $18$ 的因数：$18$ 的最小质因子是 $2$，就将 $a_2 +1$，$18$ 除以 $2$ 变为 $9$；再考虑 $9$，$9$ 的最小质因子是 $3$，将 $a_3 +1$，$9$ 除以 $3$ 变为 $3$；$3$ 的最小质因子是 $3$，所以将 $a_3 + 1$，$3$ 除以 $3$ 变为 $1$，停止计算 。此时我们已经可以知道：$18=2^{a_2=1}\times 3^{a_3=2} $。按上述操作处理，就能算出 $n!$ 的质因数分布，根据公式就能得到答案。同时因为最小的质数是 $2$，每次除以它的最小质因子时，最大也会变为原来的 $\frac{1}{2}$，所以时间复杂度为 $O(n\log n)$ 。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1e6;const LL MOD = 1e9 + 7;int n, cnt, a[MAXN + 5], prime[MAXN + 5], minPrime[MAXN + 5];//minPrime[i]表示 i 的最小质因子 LL ans = 1;inline void getPrime(int n) &#123; for (int i = 2; i &lt;= n; ++i) &#123; if (!minPrime[i]) &#123; minPrime[i] = i;//质数的最小质因子是它本身 prime[++cnt] = i; &#125; for (int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n; ++j) &#123; minPrime[i * prime[j]] = prime[j];//线性筛中的合数只会被最小质因子筛去 if (i % prime[j] == 0) break; &#125; &#125; &#125;int main() &#123; read(n); getPrime(n);//线性筛质数 for (int i = 1; i &lt;= n; ++i) for (int j = i; j &gt; 1; j /= minPrime[j]) ++a[minPrime[j]];//质因子计数 for (int i = 1; i &lt;= cnt; ++i) ans = ans * (LL) (a[prime[i]] &lt;&lt; 1 | 1) % MOD;//用公式求得答案 write(ans); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>数论数学</tag>
        <tag>筛法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 242E」XOR on Segment]]></title>
    <url>%2Fproblems%2Fcodeforces-242e%2F</url>
    <content type="text"><![CDATA[Description给定 $n\ (1 \leq n \leq 10^5)$ 个数 $a_i\ (0 \leq a_i \leq 10^6)$，现在有 $m\ (1 \leq m \leq 5 \times 10^4)$ 个操作（操作有 $2$ 种）: 1 l r：求 $\sum\limits_{i=l}^{r}a_i\ (1 \leq l \leq r \leq n)$； 2 l r x：区间 $[l,r]\ (1 \leq l \leq r \leq n)$ 内的数对 $x\ (1 \leq x \leq 10^6)$ 异或。 Source[Luogu]CF242E [Codeforces]242E Solution 前置知识： 线段树 因为是区间修改和区间查询，且异或具有结合律：$(a \oplus b) \oplus c = a \oplus (b \oplus c)$，我们很容易想到用线段树来维护。可是似乎打不了懒标记，怎么办？先考虑 $a_i$ 只有 $0$ 和 $1$ 两个值的情况，当对一条线段区间反转的时候，我们只需要让这条线段的懒标记异或 $1$，这个区间 $1$ 的个数变为 区间长度 - 原来区间 $1$ 的个数。标记下放时，如果这条线段的懒标记为 $1$，则将这条线段的左右区间反转（做上述反转操作），并清空这条线段的懒标记。 显然只有 $0$ 和 $1$ 时用线段树维护很简单，现在我们需要让这些数转化为 $0$ 和 $1$ 进行操作，这不就是把它们转化成 二进制 吗？相当于建了 $\log \max\begin{Bmatrix}a_i\end{Bmatrix}$ 棵线段树，分别维护 $a_i$ 在二进制下的每一位，以及每一位的区间和。对于即将异或的数 $x$，先找到要修改的区间 $[l,r]$，再把 $x$ 二进制拆分，如果 $x$ 在二进制下某一位是 $1$，我们就对这一位所在的线段树区间 $[l,r]$ 反转。查询时，同样先找到要查询的区间 $[l,r]$，把二进制下每一位所在的 线段树区间 $[l,r]$ 的和 × 二进制下这一位对应的值 加起来就是答案。因为每一次修改或查询都要在线段树内二进制拆分，所以时间复杂度为 $O(n\log^2n)$ 。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1e5, MAX_LOG = 21;int n, m, a[MAXN + 5];struct SegmentTree &#123; LL lazy[MAXN &lt;&lt; 2 | 3], sum[MAX_LOG + 1][MAXN &lt;&lt; 2 | 3]; //sum[i][x]表示二进制下第 i 位第 x 条线段的和 inline int lson(int x) &#123; return x &lt;&lt; 1; &#125; inline int rson(int x) &#123; return x &lt;&lt; 1 | 1; &#125; inline void pushUp(LL x) &#123; for (int i = 0; i &lt;= MAX_LOG; ++i) sum[i][x] = sum[i][lson(x)] + sum[i][rson(x)];//维护二进制下每一位 &#125; void build(int *a, int x = 1, int l = 1, int r = n) &#123; if (l == r) &#123; for (register int i = 0; i &lt;= MAX_LOG; ++i) sum[i][x] = (a[l] &gt;&gt; i) &amp; 1;//二进制拆分 return; &#125; int mid = (l + r) &gt;&gt; 1; build(a, lson(x), l, mid), build(a, rson(x), mid + 1, r); pushUp(x); &#125; inline void modify(int x, int l, int r, LL p) &#123; lazy[x] ^= p;//异或满足结合律 (a ^ b) ^ c = a ^ (b ^ c) for (int i = 0; i &lt;= MAX_LOG; ++i) if ((p &gt;&gt; i) &amp; 1)//如果第 i 位为 1 sum[i][x] = r - l + 1 - sum[i][x];//区间内 1 的个数取反 &#125; inline void pushDown(int x, int l, int r) &#123; LL mid = (l + r) &gt;&gt; 1; modify(lson(x), l, mid, lazy[x]), modify(rson(x), mid + 1, r, lazy[x]); lazy[x] = 0; &#125; void update(int ql, int qr, LL p, int l = 1, int r = n, int x = 1) &#123; if (ql &lt;= l &amp;&amp; qr &gt;= r) &#123; modify(x, l, r, p); return; &#125; if (lazy[x]) pushDown(x, l, r); LL mid = (l + r) &gt;&gt; 1; if (ql &lt;= mid) update(ql, qr, p, l, mid, lson(x)); if (qr &gt; mid) update(ql, qr, p, mid + 1, r, rson(x)); pushUp(x); &#125; LL query(int ql, int qr, int l = 1, int r = n, int x = 1) &#123; if (ql &lt;= l &amp;&amp; qr &gt;= r) &#123; LL res = 0; for (int i = 0; i &lt;= MAX_LOG; ++i) res += sum[i][x] &lt;&lt; i;//二进制下第 i 位对应 2 的 i 次方，累加 return res; &#125; if (lazy[x]) pushDown(x, l, r); LL res = 0, mid = (l + r) &gt;&gt; 1; if (ql &lt;= mid) res += query(ql, qr, l, mid, lson(x)); if (qr &gt; mid) res += query(ql, qr, mid + 1, r, rson(x)); return res; &#125;&#125; tr;int main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) read(a[i]); tr.build(a); read(m); for (int i = 1; i &lt;= m; ++i) &#123; int opt, l, r; LL x; read(opt); if (opt == 1) &#123; read(l), read(r); write(tr.query(l, r)); putchar('\n'); &#125; else &#123; read(l), read(r), read(x); tr.update(l, r, x); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉查找树(BST)简介]]></title>
    <url>%2Fnotes%2Fer-cha-cha-zhao-shu-bst-jian-jie%2F</url>
    <content type="text"><![CDATA[介绍二叉查找树(Binary Search Tree) 又称 二叉排序树(Binary Sort Tree) ，亦称 二叉搜索树，简写为 BST 。 二叉查找树具有以下性质： 如果左子树非空，那么左子树上的所有节点的值均小于等于根节点的值。 如果右子树非空，那么右子树上的所有节点的值均大于等于根节点的值。 二叉查找树的 左子树 与 右子树 也分别为二叉查找树。 通俗地讲：二叉查找树上点的权值，左儿子 &lt; 根节点 &lt; 右儿子 。 根据这个性质，我们很容易发现二叉查找树的中序遍历是一个单调不减的序列。 那么，二叉查找树有什么作用呢？ 对于一个长度为 $8​$ 的序列： $1, 15, 5, 3, 8, 10, 9, 12, 10​$，该如何找到这个序列第 $k​$ 大的数，并且支持插入与删除元素呢？如果我们将其排序再进行查询，时间复杂度为 $O(n \log n)​$，这显然不够优秀。因此我们考虑构造出一棵二叉查找树，如图。 插入假设我们要向上述序列插入一个数 $11​$，我们从根节点开始。 我们发现 $11 &gt; 9$，因此我们把 $11$ 放到 $9$ 的右儿子。 此时 $12$ 比 $11$ 大了，为了保持二叉搜索树的性质，我们把 $11$ 放到 $12​$ 的左儿子。 $11 &gt; 10$，本来应该让 $11$ 和 $10$ 的右儿子继续比较，可是 $10$ 没有右儿子，因此我们把 $11$ 插入到该位置。 小结：插入一个数时，从根节点开始，依次比较要插入的数和当前节点的值，如果大于当前节点，就放到该结点的右儿子，如果小于当前节点，就放到该结点的左儿子，重复上述操作，直到下放的位置没有结点。如果中途碰到与某个节点相等，我们再定义一个 $cnt$ 数组，表示当前节点值的个数，并且加上 $1$ 。这样我们就完成了一个数的插入过程。 删除类似插入的过程，还是依次比较要删除的数和当前节点的值，不断下放，当找到目标节点时，并不需要把该节点整个删掉，只需要给该节点值的个数减 $1$ 。对于节点 $x$，如果 $cnt[x] = 0$， 则表示当前位置没有节点。当一个位置没有节点时，这棵树依旧满足二叉查找树的性质。 查询前驱$x$ 的前驱定义为小于 $x$ 的最大的数。那么如何找 $x​$ 的前驱呢？ 这里以 $6$ 为例，从根节点开始。 从前驱的定义可知，$6$ 的前驱一定比 $6$ 小。而 $9 &gt; 6$，所以把 $6$ 放在 $9$ 的左儿子。 $8$ 还是比 $6$ 大，因此我们把 $6$ 放到 $8$ 的左儿子。 我们发现 $3 &lt; 6$，但是并不知道 $3$ 是不是小于 $6$ 的数中最大的，我们还要去找比 $3$ 大的数，因为这些数也有可能成为答案。所以记录当前答案为 $3$，把 $6$ 放在 $3$ 的右儿子。 $5$ 还是比 $6$ 小，更新当前答案为 $5$，而 $5$ 没有右儿子，所以最后答案 （$6$ 的前驱）就是 $5$ 。 小结：寻找 $x$ 的前驱时，从根节点开始，依次比较 $x$ 和当前节点的值。如果当前节点的值大于 $x$，则往该节点的左儿子找，直到出现小于 $x$ 的节点。此时我们记录当前答案为这个节点的值，往这个节点的右儿子找，如果途中遇到的节点的值小于 $x$，就更新当前答案，否则结束查询，当前答案就是 $x$ 的前驱。 后继$x​$ 的后继定义为大于 $x​$ 的最小的数。 与前驱的操作恰恰相反，依次比较 $x​$ 和当前节点的值。如果当前节点的值小于 $x​$，则往该节点的右儿子找，直到出现大于 $x​$ 的节点。此时我们记录当前答案为这个节点的值，往这个节点的左儿子找，如果途中遇到的节点的值大于 $x​$，就更新当前答案，否则结束查询，当前答案就是 $x​$ 的后继。 已知排名求值排名定义为比当前数小的数的个数 $+1​$，现在需要寻找排名为 $x​$ 的数。 我们新定义一个数组 $size$，对于一个节点 $x$，$size[x]$ 表示 $x$ 以及它的子树大小之和，需要递归预处理出每个节点的 $size$，当然，插入与删除操作时也要更新 $size$ 数组。假设我们要寻找排名为 $7$ 的数是多少，从根节点开始，如图（红色的数字即为节点的 $size$）。 $9​$ 的左儿子的 $size​$ 为 $4​$，所以 $9​$ 的排名为 $5​$，而要寻找的数的排名为 $7​$，所以该数一定比 $9​$ 大，因此我们到 $9​$ 的右子树找。 此时到了一棵新的子树上，因为排名为 $5$ 以及 $5$ 之前的节点都不要了，所以我们需要在该子树上找排名为 $2$ 的数。$12$ 的左儿子的 $size$ 为 $2$，因此 $12$ 在该子树上的排名为 $3$，排名为 $2$ 的数一定比 $12$ 小，应该到 $12$ 的左子树找。 现在所在的子树又少了 $2$ 个节点，但这 $2$ 个节点的排名都比 $2$ 大，所以仍然在新子树中找排名为 $2$ 的数。因为 $10$ 没有左儿子（即 $size$ 为 $0$），所以 $10$ 的排名为 $1$，而要查询的数排名为 $2$，大于 $10$，应该到 $10$ 的右子树找。 排名为 $1​$ 的节点已经不要了，因此要在新子树中找排名为 $1​$ 的节点。而 $11​$ 没有左儿子（即 $size​$ 为 $0​$），所以 $11​$ 的排名为 $1​$ 。最后的答案就是 $11​$ 。 小结：已知排名求值时，先预处理出每个节点的子树大小 $size$，从根节点开始，依次检查每个节点的排名，每个节点 $x$ 的排名为它 左儿子的 $size$ 加上 $cnt[x]$ (该节点值的数量) 。如果该节点的排名比要查询的排名小，则在该节点的右子树中查询 当前要查询的排名 - 该节点排名 的数。如果该节点排名更大，就在左子树中继续查询这个排名的数。如果排名相等，则该节点的值就是答案。 已知值求排名与已知排名求值的过程相似，以查询 $11$ 的排名为例，从根节点开始，初始没有数比 $11$ 小，所以 $11$ 的排名为 $1​$ 。 $9​$ 的排名为它左儿子的 $size​$ 加上它的 $cnt​$，也就是 $5​$，显然 $9 &lt; 11​$，所以 $11​$ 的排名变为 $1 + 5 = 6​$，并且往 $9​$ 的右子树找。 因为 $12 &gt; 11$，没有数比 $11$ 小，所以往 $12$ 的左子树找。 $10$ 比 $11$ 小，因为 $10$ 没有左儿子（左儿子 $size$ 为 $0$），所以 $10$ 在该子树中的排名为 $1$ 。$11$ 的排名更新为 $6 + 1 = 7$，并往 $10$ 的右子树找。 与目标节点重合，停止查询，$7$ 即为 $11$ 的排名。 小结：已知值求排名时，初始化已知值的排名为 $1$ 。从根节点开始，依次检查每个节点的值，如果该节点的值比已知值小，则排名更新为 它当前的排名 加上 该节点的排名，每个节点 $x$ 的排名为它 左儿子的 $size$ 加上 $cnt[x]$ (该节点值的数量) ，往该节点的右子树走。如果该节点的值比已知值大，则往该节点的左子树走。如果与已知值相等，则停止查询，当前排名就是这个值最终的排名。 总结普通的二叉查找树在数据随机的情况下所有操作的时间复杂度都是 $O(\log n)$ 的，但是在最劣情况下会变成一条链，时间复杂度为 $O(n)$，因此我们需要旋转，分裂等操作来维护二叉查找树，使其时间复杂度稳定为 $O(\log n)$，这种二叉查找树称作平衡二叉树，简称平衡树。平衡树的常见实现方法有 Treap , Splay , AVL , 替罪羊树 , 红黑树 等，这里不作介绍。]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伸展树(Splay)小结]]></title>
    <url>%2Fnotes%2Fshen-zhan-shu-splay-xiao-jie%2F</url>
    <content type="text"><![CDATA[前置知识二叉查找树(BST) 线段树 简介伸展树(Splay Tree) 是平衡二叉树的一种，也属于二叉查找树，使用旋转保持平衡。它能在 $O(\log n)​$ 内完成插入、删除和查询操作，还具有很强的区间操作能力，所以也能作为 LCT 的辅助树，可以说是一种万能的平衡树。 原理咕咕咕]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
        <tag>Splay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 3038」上帝造题的七分钟2]]></title>
    <url>%2Fproblems%2Fbzoj-3038%2F</url>
    <content type="text"><![CDATA[Description给定 $n\ (n \leq 10^5)$ 个数，已知 $\sum\limits_{i=1}^{n}a_i \leq 10^{18}$。 $m\ (m \leq 10^5)$ 个操作（操作有 $2$ 种）： 1 x y：询问区间 $[x,y]\ (1 \leq x,y \leq n)$ 所有数的和（不保证 $x \leq y$，若 $x &gt; y$，则交换 $x,y$）。 2 x y：将区间 $[x,y]\ (1 \leq x,y \leq n)$ 内的每一个数开 平方根（下取整） 。 Source[BZOJ]3038 Solution 前置知识： 线段树 因为要维护区间和，所以我们想到用线段树来维护。 但是会发现懒惰标记不能打，那该怎么办呢？ 考虑暴力修改： $a[i]$ 最大为 $10^{18}$。 \left \lfloor \sqrt{\sqrt{\sqrt{\sqrt{\sqrt{\sqrt{10^{18}}}}}}}\right \rfloor = 1换言之， \left \lfloor \sqrt[2^6]{10^{18}}\right \rfloor = 1一个数最多开 $6$ 次平方根就会变成 $1$ 。 因为 $\sqrt{1} = 1,\sqrt{0} = 0$， 我们只需要维护 区间和 与 区间最大值 即可， 当一个区间的最大值 $\leq 1$ 时，我们对这个区间的修改就是无用的，因为无论怎么修改这个数仍是它本身。 而我们对一个数的开平方操作不会超过 $6$ 次，所以时间复杂度仍是 $O(n \log n)$ 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1e5 + 10;struct SegmentTree &#123; LL sum[MAXN &lt;&lt; 2], maxx[MAXN &lt;&lt; 2]; inline int lson(int x) &#123; return x &lt;&lt; 1; &#125; inline int rson(int x) &#123; return x &lt;&lt; 1 | 1; &#125; inline void pushUp(int x) &#123; sum[x] = sum[lson(x)] + sum[rson(x)]; maxx[x] = max(maxx[lson(x)], maxx[rson(x)]); &#125; void build(int x, int l, int r, LL *a) &#123; if (l == r) &#123; sum[x] = a[l]; maxx[x] = a[l]; return; &#125; int mid = (l + r) &gt;&gt; 1; build(lson(x), l, mid, a), build(rson(x), mid + 1, r, a); pushUp(x); &#125; void update(int ql, int qr, int l, int r, int x) &#123; if (maxx[x] &lt;= 1) return;//如果区间最大值小于等于1，就可以直接忽略这个区间的修改操作 if (l == r) &#123; sum[x] = sqrt(sum[x]); maxx[x] = sqrt(maxx[x]); return; &#125; int mid = (l + r) &gt;&gt; 1; if (ql &lt;= mid) update(ql, qr, l, mid, lson(x)); if (qr &gt; mid) update(ql, qr, mid + 1, r, rson(x)); pushUp(x); &#125; LL query(int ql, int qr, int l, int r, int x) &#123; if (ql &lt;= l &amp;&amp; qr &gt;= r) return sum[x]; int mid = (l + r) &gt;&gt; 1; LL res = 0; if (ql &lt;= mid) res += query(ql, qr, l, mid, lson(x)); if (qr &gt; mid) res += query(ql, qr, mid + 1, r, rson(x)); return res; &#125;&#125; tr;int n, m;LL a[MAXN];int main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) read(a[i]); tr.build(1, 1, n, a); read(m); for (int opt, l, r, i = 1; i &lt;= m; ++i) &#123; read(opt), read(l), read(r); if (l &gt; r) swap(l, r); if (opt == 1) &#123; write(tr.query(l, r, 1, n, 1)); putchar('\n'); &#125; else tr.update(l, r, 1, n, 1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 3211」花神游历各国]]></title>
    <url>%2Fproblems%2Fbzoj-3211%2F</url>
    <content type="text"><![CDATA[Description给定 $n\ (n \leq 10^5)$ 个数，已知 $\sum\limits_{i=1}^{n}a_i \leq 10^{18}$。 $m\ (m \leq 10^5)$ 个操作（操作有 $2$ 种）： 1 x y：询问区间 $[x,y]\ (1 \leq x,y \leq n)$ 所有数的和（不保证 $x \leq y$，若 $x &gt; y$，则交换 $x,y$）。 2 x y：将区间 $[x,y]\ (1 \leq x,y \leq n)$ 内的每一个数开 平方根（下取整） 。 Source[BZOJ]3211 Solution 前置知识： 线段树 因为要维护区间和，所以我们想到用线段树来维护。 但是会发现懒惰标记不能打，那该怎么办呢？ 考虑暴力修改： $a[i]$ 最大为 $10^{18}$。 \left \lfloor \sqrt{\sqrt{\sqrt{\sqrt{\sqrt{\sqrt{10^{18}}}}}}}\right \rfloor = 1换言之， \left \lfloor \sqrt[2^6]{10^{18}}\right \rfloor = 1一个数最多开 $6$ 次平方根就会变成 $1$ 。 因为 $\sqrt{1} = 1,\sqrt{0} = 0$， 我们只需要维护 区间和 与 区间最大值 即可， 当一个区间的最大值 $\leq 1$ 时，我们对这个区间的修改就是无用的，因为无论怎么修改这个数仍是它本身。 而我们对一个数的开平方操作不会超过 $6$ 次，所以时间复杂度仍是 $O(n \log n)$ 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1e5 + 10;struct SegmentTree &#123; LL sum[MAXN &lt;&lt; 2], maxx[MAXN &lt;&lt; 2]; inline int lson(int x) &#123; return x &lt;&lt; 1; &#125; inline int rson(int x) &#123; return x &lt;&lt; 1 | 1; &#125; inline void pushUp(int x) &#123; sum[x] = sum[lson(x)] + sum[rson(x)]; maxx[x] = max(maxx[lson(x)], maxx[rson(x)]); &#125; void build(int x, int l, int r, LL *a) &#123; if (l == r) &#123; sum[x] = a[l]; maxx[x] = a[l]; return; &#125; int mid = (l + r) &gt;&gt; 1; build(lson(x), l, mid, a), build(rson(x), mid + 1, r, a); pushUp(x); &#125; void update(int ql, int qr, int l, int r, int x) &#123; if (maxx[x] &lt;= 1) return;//如果区间最大值小于等于1，就可以直接忽略这个区间的修改操作 if (l == r) &#123; sum[x] = sqrt(sum[x]); maxx[x] = sqrt(maxx[x]); return; &#125; int mid = (l + r) &gt;&gt; 1; if (ql &lt;= mid) update(ql, qr, l, mid, lson(x)); if (qr &gt; mid) update(ql, qr, mid + 1, r, rson(x)); pushUp(x); &#125; LL query(int ql, int qr, int l, int r, int x) &#123; if (ql &lt;= l &amp;&amp; qr &gt;= r) return sum[x]; int mid = (l + r) &gt;&gt; 1; LL res = 0; if (ql &lt;= mid) res += query(ql, qr, l, mid, lson(x)); if (qr &gt; mid) res += query(ql, qr, mid + 1, r, rson(x)); return res; &#125;&#125; tr;int n, m;LL a[MAXN];int main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) read(a[i]); tr.build(1, 1, n, a); read(m); for (int opt, l, r, i = 1; i &lt;= m; ++i) &#123; read(opt), read(l), read(r); if (l &gt; r) swap(l, r); if (opt == 1) &#123; write(tr.query(l, r, 1, n, 1)); putchar('\n'); &#125; else tr.update(l, r, 1, n, 1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P4145」上帝造题的七分钟2/花神游历各国]]></title>
    <url>%2Fproblems%2Fluogu-p4145%2F</url>
    <content type="text"><![CDATA[Description给定 $n\ (n \leq 10^5)$ 个数，已知 $\sum\limits_{i=1}^{n}a_i \leq 10^{18}$。 $m\ (m \leq 10^5)$ 个操作（操作有 $2$ 种）： 0 x y：将区间 $[x,y]\ (1 \leq x,y \leq n)$ 内的每一个数开 平方根（下取整） 。 1 x y：询问区间 $[x,y]\ (1 \leq x,y \leq n)$ 所有数的和（不保证 $x \leq y$，若 $x &gt; y$，则交换 $x,y$）。 Source[Luogu]P4145 Solution 前置知识： 线段树 因为要维护区间和，所以我们想到用线段树来维护。 但是会发现懒惰标记不能打，那该怎么办呢？ 考虑暴力修改： $a[i]$ 最大为 $10^{18}$。 \left \lfloor \sqrt{\sqrt{\sqrt{\sqrt{\sqrt{\sqrt{10^{18}}}}}}}\right \rfloor = 1换言之， \left \lfloor \sqrt[2^6]{10^{18}}\right \rfloor = 1一个数最多开 $6$ 次平方根就会变成 $1$ 。 因为 $\sqrt{1} = 1,\sqrt{0} = 0$， 我们只需要维护 区间和 与 区间最大值 即可， 当一个区间的最大值 $\leq 1$ 时，我们对这个区间的修改就是无用的，因为无论怎么修改这个数仍是它本身。 而我们对一个数的开平方操作不会超过 $6$ 次，所以时间复杂度仍是 $O(n \log n)$ 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1e5 + 10;struct SegmentTree &#123; LL sum[MAXN &lt;&lt; 2], maxx[MAXN &lt;&lt; 2]; inline int lson(int x) &#123; return x &lt;&lt; 1; &#125; inline int rson(int x) &#123; return x &lt;&lt; 1 | 1; &#125; inline void pushUp(int x) &#123; sum[x] = sum[lson(x)] + sum[rson(x)]; maxx[x] = max(maxx[lson(x)], maxx[rson(x)]); &#125; void build(int x, int l, int r, LL *a) &#123; if (l == r) &#123; sum[x] = a[l]; maxx[x] = a[l]; return; &#125; int mid = (l + r) &gt;&gt; 1; build(lson(x), l, mid, a), build(rson(x), mid + 1, r, a); pushUp(x); &#125; void update(int ql, int qr, int l, int r, int x) &#123; if (maxx[x] &lt;= 1) return;//如果区间最大值小于等于1，就可以直接忽略这个区间的修改操作 if (l == r) &#123; sum[x] = sqrt(sum[x]); maxx[x] = sqrt(maxx[x]); return; &#125; int mid = (l + r) &gt;&gt; 1; if (ql &lt;= mid) update(ql, qr, l, mid, lson(x)); if (qr &gt; mid) update(ql, qr, mid + 1, r, rson(x)); pushUp(x); &#125; LL query(int ql, int qr, int l, int r, int x) &#123; if (ql &lt;= l &amp;&amp; qr &gt;= r) return sum[x]; int mid = (l + r) &gt;&gt; 1; LL res = 0; if (ql &lt;= mid) res += query(ql, qr, l, mid, lson(x)); if (qr &gt; mid) res += query(ql, qr, mid + 1, r, rson(x)); return res; &#125;&#125; tr;int n, m;LL a[MAXN];int main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) read(a[i]); tr.build(1, 1, n, a); read(m); for (int opt, l, r, i = 1; i &lt;= m; ++i) &#123; read(opt), read(l), read(r); if (l &gt; r) swap(l, r); if (opt == 1) &#123; write(tr.query(l, r, 1, n, 1)); putchar('\n'); &#125; else tr.update(l, r, 1, n, 1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SPOJ 2713」GSS4 - Can you answer these queries IV]]></title>
    <url>%2Fproblems%2Fspoj-2713%2F</url>
    <content type="text"><![CDATA[Description给定 $n\ (n \leq 10^5)$ 个数，已知 $\sum\limits_{i=1}^{n}a_i \leq 10^{18}$。 $m\ (m \leq 10^5)$ 个操作（操作有 $2$ 种）： 0 x y：将区间 $[x,y]\ (1 \leq x,y \leq n)$ 内的每一个数开 平方根（下取整） 。 1 x y：询问区间 $[x,y]\ (1 \leq x,y \leq n)$ 所有数的和（不保证 $x \leq y$，若 $x &gt; y$，则交换 $x,y$）。 Source[Luogu]SP2713 [SPOJ]GSS4 Solution 前置知识： 线段树 因为要维护区间和，所以我们想到用线段树来维护。 但是会发现懒惰标记不能打，那该怎么办呢？ 考虑暴力修改： $a[i]$ 最大为 $10^{18}$。 \left \lfloor \sqrt{\sqrt{\sqrt{\sqrt{\sqrt{\sqrt{10^{18}}}}}}}\right \rfloor = 1换言之， \left \lfloor \sqrt[2^6]{10^{18}}\right \rfloor = 1一个数最多开 $6$ 次平方根就会变成 $1$ 。 因为 $\sqrt{1} = 1,\sqrt{0} = 0$， 我们只需要维护 区间和 与 区间最大值 即可， 当一个区间的最大值 $\leq 1$ 时，我们对这个区间的修改就是无用的，因为无论怎么修改这个数仍是它本身。 而我们对一个数的开平方操作不会超过 $6$ 次，所以时间复杂度仍是 $O(n \log n)$ 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1e5 + 10;struct SegmentTree &#123; LL sum[MAXN &lt;&lt; 2], maxx[MAXN &lt;&lt; 2]; inline int lson(int x) &#123; return x &lt;&lt; 1; &#125; inline int rson(int x) &#123; return x &lt;&lt; 1 | 1; &#125; inline void pushUp(int x) &#123; sum[x] = sum[lson(x)] + sum[rson(x)]; maxx[x] = max(maxx[lson(x)], maxx[rson(x)]); &#125; void build(int x, int l, int r, LL *a) &#123; if (l == r) &#123; sum[x] = a[l]; maxx[x] = a[l]; return; &#125; int mid = (l + r) &gt;&gt; 1; build(lson(x), l, mid, a), build(rson(x), mid + 1, r, a); pushUp(x); &#125; void update(int ql, int qr, int l, int r, int x) &#123; if (maxx[x] &lt;= 1) return;//如果区间最大值小于等于1，就可以直接忽略这个区间的修改操作 if (l == r) &#123; sum[x] = sqrt(sum[x]); maxx[x] = sqrt(maxx[x]); return; &#125; int mid = (l + r) &gt;&gt; 1; if (ql &lt;= mid) update(ql, qr, l, mid, lson(x)); if (qr &gt; mid) update(ql, qr, mid + 1, r, rson(x)); pushUp(x); &#125; LL query(int ql, int qr, int l, int r, int x) &#123; if (ql &lt;= l &amp;&amp; qr &gt;= r) return sum[x]; int mid = (l + r) &gt;&gt; 1; LL res = 0; if (ql &lt;= mid) res += query(ql, qr, l, mid, lson(x)); if (qr &gt; mid) res += query(ql, qr, mid + 1, r, rson(x)); return res; &#125;&#125; tr;int n, m;LL a[MAXN];int main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) read(a[i]); tr.build(1, 1, n, a); read(m); for (int opt, l, r, i = 1; i &lt;= m; ++i) &#123; read(opt), read(l), read(r); if (l &gt; r) swap(l, r); if (opt == 1) &#123; write(tr.query(l, r, 1, n, 1)); putchar('\n'); &#125; else tr.update(l, r, 1, n, 1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>SPOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SPOJ 1716」GSS3 - Can you answer these queries III]]></title>
    <url>%2Fproblems%2Fspoj-1716%2F</url>
    <content type="text"><![CDATA[Description给定一个长度为 $n\ (n \leq 50000, \mid a_i \mid \leq 10000)$ 的整数序列 和 $m\ (m \leq 50000)$ 个操作（操作有 $2$ 种）： 0 x y：把 $a_x\ (1 \leq x \leq n)$ 的值修改为 $y\ (\mid y \mid \leq 10000)$。 1 x y： 询问区间 $[x,y]\ (1 \leq x \leq y \leq n)$ 的最大子段和。 Source[Luogu]SP1716 [SPOJ]GSS3 Solution 前置知识： 线段树 仅仅是比 「SPOJ1043」GSS1 多了一个单点修改操作，暴力修改并且加上 $\mathrm{pushUp}$ 操作即可。 $\mathrm{pushUp}$ 操作 和 $\mathrm{query}$ 操作 的详细实现过程请看上一行链接。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 5e4 + 10;struct SegmentTree &#123; struct Node &#123; LL sum, lsum, rsum, res; &#125; seg[MAXN &lt;&lt; 2]; inline int lson(int x) &#123; return x &lt;&lt; 1; &#125; inline int rson(int x) &#123; return x &lt;&lt; 1 | 1; &#125; inline void pushUp(int x) &#123; seg[x].sum = seg[lson(x)].sum + seg[rson(x)].sum; seg[x].res = max(max(seg[lson(x)].res, seg[rson(x)].res), seg[lson(x)].rsum + seg[rson(x)].lsum); seg[x].lsum = max(seg[lson(x)].lsum, seg[lson(x)].sum + seg[rson(x)].lsum); seg[x].rsum = max(seg[rson(x)].rsum, seg[lson(x)].rsum + seg[rson(x)].sum); &#125; void build(int x, int l, int r, LL *a) &#123; if (l == r) &#123; seg[x] = (Node) &#123; a[l], a[l], a[l], a[l] &#125;; return; &#125; int mid = (l + r) &gt;&gt; 1; build(lson(x), l, mid, a), build(rson(x), mid + 1, r, a); pushUp(x); &#125; void update(int q, int l, int r, int x, LL p) &#123; if (l == r) &#123; seg[x] = (Node) &#123; p, p, p, p &#125;; return; &#125; int mid = (l + r) &gt;&gt; 1; if (q &lt;= mid) update(q, l, mid, lson(x), p); else update(q, mid + 1, r, rson(x), p); pushUp(x); &#125; Node query(int ql, int qr, int l, int r, int x) &#123; if (ql &lt;= l &amp;&amp; qr &gt;= r) return seg[x]; int mid = (l + r) &gt;&gt; 1; if (qr &lt;= mid) return query(ql, qr, l, mid, lson(x)); if (ql &gt; mid) return query(ql, qr, mid + 1, r, rson(x)); Node ans, lx = query(ql, qr, l, mid, lson(x)), ly = query(ql, qr, mid + 1, r, rson(x)); ans.sum = lx.sum + ly.sum; ans.res = max(max(lx.res, ly.res), lx.rsum + ly.lsum); ans.lsum = max(lx.lsum, lx.sum + ly.lsum); ans.rsum = max(ly.rsum, lx.rsum + ly.sum); return ans; &#125;&#125; tr;int n, q, l, r;bool opt;LL a[MAXN];int main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) read(a[i]); tr.build(1, 1, n, a); for (read(q); q; --q) &#123; read(opt), read(l), read(r); if (!opt) tr.update(l, 1, n, 1, r); else &#123; write(tr.query(l, r, 1, n, 1).res); putchar('\n'); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>SPOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SPOJ 1043」GSS1 - Can you answer these queries I]]></title>
    <url>%2Fproblems%2Fspoj-1043%2F</url>
    <content type="text"><![CDATA[Description给定一个长度为 $n\ (n \leq 50000, \mid a_i \mid \leq 15007)$ 的整数序列，对于 $m\ (m \leq 50000)$ 个询问 $l,r\ (1 \leq l \leq r \leq n)$，求区间 $[l,r]$ 的最大子段和。 Source[Luogu]SP1043 [SPOJ]GSS1 Solution 前置知识： 线段树 如果用朴素的最大子段和算法，时间复杂度为 $O(nm)$，一定会超时。 很容易想到用数据结构来维护。 我们建立一棵线段树，对于区间 $x$，有以下定义： $sum[x]$ 表示区间和； $lsum[x]$ 表示以该区间左端点为起点的最大子段和； $rsum[x]$ 表示以该区间右端点为起点的最大子段和； $res[x]$ 表示该区间内的最大子段和。 与普通的线段树不同，这道题维护的信息很多，我们先来分析该题最重要的 $\mathrm{pushUp}$ 与 $\mathrm{query}$ 操作。 $\mathrm{pushUp}$ 操作首先，是维护区间和，最基本的线段树操作，就不用多说了： \large{sum[x] = sum[lson(x)] + sum[rson(x)]}其次，假如我们知道一个区间的左右子区间信息，如何更新该区间的最大子段和？ 很显然，答案可能为 左区间的最大子段和 或 右区间的最大子段和 。 除此之外，合并区间后，答案也有可能为 左区间的右起最大子段和 + 右区间的左起最大子段和，如上图。 由此我们可以得到代码： \large{res[x]=\max\begin{Bmatrix}res[lson(x)],res[rson(x)],rsum[lson(x)]+lsum[rson(x)]\end{Bmatrix}}那如何更新该区间的 左起最大子段和 和 右起最大子段和 呢？ 区间左起最大子段和可以是 左区间的左起最大子段和 或 左区间的区间和 + 右区间的左起最大子段和，如上图。 右起最大子段和将上述操作反过来即可。 代码实现如下： \large{\begin{aligned} lsum[x]&=\max(lsum[lson],sum[lson]+lsum[rson])\\[2ex] rsum[x]&=\max(rsum[rson],rsum[lson]+sum[rsum]) \end{aligned}}$\mathrm{query}$ 操作 当答案来自两个不同的区间时（如图），我们需要对这两个区间答案进行合并，并不只是取最大值那样简单。 我们还需要进行类似 $\mathrm{pushUp}$ 的操作，已知左右区间的答案，更新该区间答案。 函数的返回值有很多，所以用结构体式线段树实现更方便。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 5e4 + 10;struct SegmentTree &#123; struct Node &#123; LL sum, lsum, rsum, res; &#125; seg[MAXN &lt;&lt; 2]; inline int lson(int x) &#123; return x &lt;&lt; 1; &#125; inline int rson(int x) &#123; return x &lt;&lt; 1 | 1; &#125; inline void pushUp(int x) &#123; seg[x].sum = seg[lson(x)].sum + seg[rson(x)].sum; seg[x].res = max(max(seg[lson(x)].res, seg[rson(x)].res), seg[lson(x)].rsum + seg[rson(x)].lsum); seg[x].lsum = max(seg[lson(x)].lsum, seg[lson(x)].sum + seg[rson(x)].lsum); seg[x].rsum = max(seg[rson(x)].rsum, seg[lson(x)].rsum + seg[rson(x)].sum); &#125; void build(int x, int l, int r, LL *a) &#123; if (l == r) &#123; seg[x] = (Node) &#123; a[l], a[l], a[l], a[l] &#125;; return; &#125; int mid = (l + r) &gt;&gt; 1; build(lson(x), l, mid, a), build(rson(x), mid + 1, r, a); pushUp(x); &#125; Node query(int ql, int qr, int l, int r, int x) &#123;//分成3种情况考虑 if (ql &lt;= l &amp;&amp; qr &gt;= r) return seg[x]; int mid = (l + r) &gt;&gt; 1; if (qr &lt;= mid) return query(ql, qr, l, mid, lson(x)); if (ql &gt; mid) return query(ql, qr, mid + 1, r, rson(x)); Node ans, lx = query(ql, qr, l, mid, lson(x)), ly = query(ql, qr, mid + 1, r, rson(x)); ans.sum = lx.sum + ly.sum; ans.res = max(max(lx.res, ly.res), lx.rsum + ly.lsum); ans.lsum = max(lx.lsum, lx.sum + ly.lsum); ans.rsum = max(ly.rsum, lx.rsum + ly.sum); return ans; &#125;&#125; tr;int n, q, l, r;LL a[MAXN];int main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) read(a[i]); tr.build(1, 1, n, a); for (read(q); q; --q) &#123; read(l), read(r); write(tr.query(l, r, 1, n, 1).res); putchar('\n'); &#125; return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>SPOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 1303」「CQOI2009」中位数图]]></title>
    <url>%2Fproblems%2Fbzoj-1303%2F</url>
    <content type="text"><![CDATA[Description给定长度为 $n\ (n \leq 10^5)$ 的排列，求有多少包含 $b\ (1 \leq b \leq n)$ 的奇数长度的序列中位数为 $b$ 。 Source[BZOJ]1303 Solution因为所求的是中位数，所以考虑改变原序列。把大于 $b$ 的数全部变为 $1$，小于 $b$ 的数变为 $-1$，等于 $b$ 则为 $0$ 。问题就变为求存在几个包含 $b$ 的区间和为 $0$ 。我们假设 $tmp$ 为 $b$ 的下标，原数组为 $x$，新数组为 $a$ 。 Sample Input127 45 7 2 4 3 1 6 Sample Output14 Example 对于样例，能使结果成立的 $4$ 个区间分别为 $[1,5]$，$[1,7]$，$[2,4]$，$[4,4]$ 。 接下来我们建造两个桶，分别计数 $tmp$ 左边的后缀和与右边的前缀和，假设左边的后缀和为 $l$，右边的前缀和为 $r$ 。$l[i]/r[i]$ 表示从点 $i$ 向右/向左 到点 $tmp$ 为止 (比 $b$ 大的数的数量 - 比 $b$ 小的数的数量) 出现的次数。还是拿样例来说： 通过观察上图，我们能够发现，左边的数 $x$ 可以与右边的每一个 $-x$ 进行匹配。通过乘法原理，该值即为 $l[x] \times r[-x]$，由题意可知 $-10^5 \le x \le 10^5$，遍历所有的 $x$ 即可，最终答案为： \sum\limits_{i=\min{x}}^{\max{x}}l[i] \times r[-i]值得注意的是，$l[0]$ 和 $r[0]$ 的初始值为 $1$，因为 $b$ 是需要被算入的。当然，桶的下标不能是负数，所以我在每次操作时都加上了一个很大的数，比如数据最大值 —— $10^5$，也可以用 $\mathrm{STL}$ 中的 $map$ 解决问题，时间复杂度为 $O(n)$ 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1e5;int n, b, tmp, sum, a[MAXN + 10], l[MAXN &lt;&lt; 1 | 1], r[MAXN &lt;&lt; 1 | 1];LL ans;int main() &#123; read(n), read(b); for (int x, i = 1; i &lt;= n; ++i) &#123; read(x); if (x == b) tmp = i; else a[i] = x &gt; b ? 1 : -1; &#125; ++l[MAXN], ++r[MAXN]; for (int i = tmp - 1; i &gt;= 1; --i) &#123; sum += a[i]; ++l[sum + MAXN]; &#125;//后缀和 sum = 0; for (int i = tmp + 1; i &lt;= n; ++i) &#123; sum += a[i]; ++r[sum + MAXN]; &#125;//前缀和 for (int i = -MAXN; i &lt;= MAXN; ++i) ans += (LL) l[i + MAXN] * (LL) r[-i + MAXN];//公式计算答案 write(ans); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>2009</tag>
        <tag>数论数学</tag>
        <tag>CQOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P1627」「CQOI2009」中位数图]]></title>
    <url>%2Fproblems%2Fluogu-p1627%2F</url>
    <content type="text"><![CDATA[Description给定长度为 $n\ (n \leq 10^5)$ 的排列，求有多少包含 $b\ (1 \leq b \leq n)$ 的奇数长度的序列中位数为 $b$ 。 Source[Luogu]P1627 Solution因为所求的是中位数，所以考虑改变原序列。把大于 $b$ 的数全部变为 $1$，小于 $b$ 的数变为 $-1$，等于 $b$ 则为 $0$ 。问题就变为求存在几个包含 $b$ 的区间和为 $0$ 。我们假设 $tmp$ 为 $b$ 的下标，原数组为 $x$，新数组为 $a$ 。 Sample Input127 45 7 2 4 3 1 6 Sample Output14 Example 对于样例，能使结果成立的 $4$ 个区间分别为 $[1,5]$，$[1,7]$，$[2,4]$，$[4,4]$ 。 接下来我们建造两个桶，分别计数 $tmp$ 左边的后缀和与右边的前缀和，假设左边的后缀和为 $l$，右边的前缀和为 $r$ 。$l[i]/r[i]$ 表示从点 $i$ 向右/向左 到点 $tmp$ 为止 (比 $b$ 大的数的数量 - 比 $b$ 小的数的数量) 出现的次数。还是拿样例来说： 通过观察上图，我们能够发现，左边的数 $x$ 可以与右边的每一个 $-x$ 进行匹配。通过乘法原理，该值即为 $l[x] \times r[-x]$，由题意可知 $-10^5 \le x \le 10^5$，遍历所有的 $x$ 即可，最终答案为： \sum\limits_{i=\min{x}}^{\max{x}}l[i] \times r[-i]值得注意的是，$l[0]$ 和 $r[0]$ 的初始值为 $1$，因为 $b$ 是需要被算入的。当然，桶的下标不能是负数，所以我在每次操作时都加上了一个很大的数，比如数据最大值 —— $10^5$，也可以用 $\mathrm{STL}$ 中的 $map$ 解决问题，时间复杂度为 $O(n)$ 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1e5;int n, b, tmp, sum, a[MAXN + 10], l[MAXN &lt;&lt; 1 | 1], r[MAXN &lt;&lt; 1 | 1];LL ans;int main() &#123; read(n), read(b); for (int x, i = 1; i &lt;= n; ++i) &#123; read(x); if (x == b) tmp = i; else a[i] = x &gt; b ? 1 : -1; &#125; ++l[MAXN], ++r[MAXN]; for (int i = tmp - 1; i &gt;= 1; --i) &#123; sum += a[i]; ++l[sum + MAXN]; &#125;//后缀和 sum = 0; for (int i = tmp + 1; i &lt;= n; ++i) &#123; sum += a[i]; ++r[sum + MAXN]; &#125;//前缀和 for (int i = -MAXN; i &lt;= MAXN; ++i) ans += (LL) l[i + MAXN] * (LL) r[-i + MAXN];//公式计算答案 write(ans); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>2009</tag>
        <tag>数论数学</tag>
        <tag>CQOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用距离算法详解]]></title>
    <url>%2Fnotes%2Fchang-yong-ju-li-suan-fa-xiang-jie%2F</url>
    <content type="text"><![CDATA[前言在计算距离时，我们一般都是求两点之间的直线距离，实际上距离算法并不只这一种，还有其他的距离算法在 $\mathrm{OI}$ 中也同样很重要。不同的距离算法都有明显的优缺点。本文主要讲解 三种 常见的距离算法，分别是 欧氏距离，曼哈顿距离，切比雪夫距离 。 一、欧氏距离（欧几里得度量）欧氏距离 是最易于理解的一种距离算法。在数学的平面直角坐标系中，设点 $A,B$ 的坐标分别为 $A(x_1,y_1),B(x_2,y_2)$，求点 $A,B$ 之间的距离，我们一般会使用如下公式： \left | AB \right | = \sqrt{\left ( x_2 - x_1 \right )^2 + \left ( y_2 - y_1 \right )^2}实际上这就是平面（二维空间）中两点欧氏距离的距离公式，除此之外，$P(x,y)$ 到原点的欧氏距离可以用公式表示为： \left | P \right | = \sqrt{x^2+y^2}举个例子，在下图中 $A,B$ 的坐标分别为 $A(6,5),B(2,2)$。 通过公式，我们很容易得到 $A,B$ 两点间的欧氏距离： \left | AB \right | = \sqrt{\left ( 2 - 6 \right )^2 + \left ( 2 - 5 \right )^2} = \sqrt{4^2+3^2} = 5那么，三维空间 中两点的欧氏距离公式呢？我们来观察下图。 我们很容易发现，在$\triangle ADC$中，$\angle ADC = 90^\circ$；在$\triangle ACB$中，$\angle ACB = 90^\circ$ 。 \begin{aligned} \therefore \left | AB\right | &=\sqrt{\left | AC\right | ^2+\left | BC\right | ^2}\\ &=\sqrt{\left | AD\right | ^2+\left | CD\right | ^2+\left | BC\right | ^2}\\ \end{aligned}由此可得，三维空间 中欧氏距离的距离公式为： \left | AB \right | = \sqrt{\left ( x_2 - x_1 \right )^2 + \left ( y_2 - y_1 \right )^2 + \left ( z_2 - z_1 \right )^2} \left | P\right | = \sqrt{x^2+y^2+z^2}以此类推，我们就得到了 $n$ 维空间 中欧氏距离的距离公式： \begin{aligned} d(x,y) &= \sqrt{\left ( x_1 - y_1 \right )^2 + \left ( x_2 - y_2 \right )^2 + \cdots +\left ( x_n - y_n \right )^2}\\ &= \sqrt{\sum\limits_{i = 1}^{n}(x_i - y_i)^2}\\ \end{aligned}欧氏距离 的一般模型： 在一个坐标系上，求从一个点到另一个点的最短距离。 欧氏距离 的缺点： 两个整点计算其欧氏距离时，往往答案是浮点型，会存在精度误差。 例题： [Luogu]P3958 Description 共 $T$ 组数据。在一个三维坐标系上，有 $n$ 个球体，坐标分别为 $(x_i, y_i, z_i)$，半径为 $r$ 。现在从 $z$ 轴的 $0$ 位置出发，所经过的位置一定要有球体覆盖，求能否到达 $z$ 轴的 $h$ 位置。 $(1 \leq n \leq 10^3,1 \leq h,r \leq 10^9,T \leq 20$，坐标的绝对值不超过 $10^9)$ Solution 考虑用 并查集 维护球体形成的连通块。 如何判断两个球体是否连通？ 这就要用到三维空间中的欧式距离公式： \left | AB \right | = \sqrt{\left ( x_2 - x_1 \right )^2 + \left ( y_2 - y_1 \right )^2 + \left ( z_2 - z_1 \right )^2}若两个球体球心之间的欧式距离 $|AB| \leq 2r$，则说明这两个球体相交或者相切，可以把它们合并到同一个连通块中。 对于每个连通块，如果与底面和顶面都相连，就能够到达，反之则不行。时间复杂度为 $O(n^2)$ 。 由于求欧式距离时存在精度误差，我们可以将不等式两边开平方，得到 \left | AB \right |^2 \leq 4r^2Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1e3;int t, n, h, r, x[MAXN + 5], y[MAXN + 5], z[MAXN + 5], d[MAXN + 5], u[MAXN + 5];inline LL dist(int i, int j) &#123;//三维空间内两点间欧式距离的平方 return (LL) (x[i] - x[j]) * (x[i] - x[j]) + (LL) (y[i] - y[j]) * (y[i] - y[j]) + (LL) (z[i] - z[j]) * (z[i] - z[j]);&#125;struct ufSet &#123; int fa[MAXN + 5]; ufSet(int n) &#123; for (int i = 1; i &lt;= n; ++i) fa[i] = i; &#125; int find(int x) &#123; return x != fa[x] ? fa[x] = find(fa[x]) : x; &#125; inline void merge(int x, int y) &#123; fa[find(x)] = find(y); &#125;&#125;;int main() &#123; for (read(t); t; --t) &#123; read(n), read(h), read(r); for (int i = 1; i &lt;= n; ++i) read(x[i]), read(y[i]), read(z[i]); ufSet s(n); memset(d, 0, sizeof (d)); memset(u, 0, sizeof (u)); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt; i; ++j) if (dist(i, j) &lt;= (LL) 4 * r * r) //为避免精度误差，这里对不等式两边开平方 s.merge(i, j);//合并到同一个连通块中 bool flag = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (z[i] - r &lt;= 0) d[s.find(i)] = 1;//与底面相连 if (z[i] + r &gt;= h) u[s.find(i)] = 1;//与顶面相连 if (d[s.find(i)] &amp;&amp; u[s.find(i)]) &#123;//如果一个连通块与底面和顶面都相连 flag = 1; break; &#125; &#125; puts(flag ? "Yes" : "No"); &#125; return 0;&#125; 二、曼哈顿距离在 二维空间 内，两个点之间的曼哈顿距离为它们横坐标之差的绝对值与纵坐标之差的绝对值之和。设点 $A(x_1,y_1),B(x_2,y_2)$，则 $A,B$ 之间的曼哈顿距离用公式可以表示为： d(A,B) = \left | x_1 - x_2\right | + \left | y_1 - y_2 \right |观察下图： 在 $A,B$ 间，$\color{yellow}{黄线}$，$\color{orange}{橙线}$ 都表示曼哈顿距离，而 $\color{red}{红线}$，$\color{blue}{蓝线}$ 表示 等价 的曼哈顿距离，$\color{green}{绿线}$ 表示欧氏距离。 同样的例子，在下图中 $A,B$ 的坐标分别为 $A(6,5),B(2,2)$ 。 通过公式，我们很容易得到 $A,B$ 两点间的曼哈顿距离： d(A,B) = \left | 6 - 2\right | + \left | 5 - 2\right | = 4 + 3 = 7$n$ 维空间 的曼哈顿距离公式： \begin{aligned} d(A,B) &= \left | x_1 - y_1\right | + \left | x_2 - y_2\right | + \cdots + \left | x_n - y_n\right | \\[2ex] &=\sum\limits_{i = 1}^{n}\left | x_i - y_i\right | \\ \end{aligned}除了公式之外，曼哈顿距离还具有以下 数学性质： 非负性 曼哈顿距离是一个非负数。 $d(i,j)\geq 0$ 统一性 点到自身的曼哈顿距离为 $0$。 $d(i,i) = 0$ 对称性 $A$ 到 $B$ 与 $B$ 到 $A$ 的曼哈顿距离相等，且是对称函数。 $d(i,j) = d(j,i)$ 三角不等式 从点 $i$ 到 $j$ 的直接距离不会大于途经的任何其它点 $k$ 的距离。 $d(i,j)\leq d(i,k)+d(k,j)$ 曼哈顿距离 的一般模型： 在国际象棋棋盘上，车从一个格子走到另一个格子的步数就是曼哈顿距离。 若网格图上的一个点只能到上下左右四个点，且到这四个点的距离都相同，则该网格图上两点的距离也为曼哈顿距离。 例题： [Luogu]P5098 Description 给定 $n$ 个点，每个点的坐标为 $(x,y)$，求曼哈顿距离的最大点对，输出这个最大值。 $(1 \leq n \leq 5 \times 10^4,-10^6 \leq x,y \leq 10^6)$ Solution 1 根据题意，对于式子 $\left | x_1-x_2\right| +\left | y_1-y_2\right| $，我们可以分成四种情况考虑： 第一种情况：$x_1 - x_2 \geq 0,y_1 - y_2 \geq 0$ \begin{aligned} &\left | x_1 - x_2 \right | + \left | y_1 - y_2\right |\\ =\ & x_1 - x_2 + y_1 - y_2\\ =\ & (x_1 + y_1) - (x_2 + y_2)\\ \end{aligned}第二种情况：$x_1 - x_2 &lt; 0,y_1 - y_2 \geq 0$ \begin{aligned} &\left | x_1 - x_2 \right | + \left | y_1 - y_2\right |\\ =\ & x_2 - x_1 + y_1 - y_2\\ =\ & (x_2 - y_2) - (x_1 - y_1)\\ \end{aligned}第三种情况：$x_1 - x_2 \geq 0,y_1 - y_2 &lt; 0$ \begin{aligned} &\left | x_1 - x_2 \right | + \left | y_1 - y_2\right |\\ =\ & x_1 - x_2 + y_2 - y_1\\ =\ & (x_1 - y_1) - (x_2 - y_2)\\ \end{aligned}第四种情况：$x_1 - x_2 &lt; 0,y_1 - y_2 &lt; 0$ \begin{aligned} &\left | x_1 - x_2 \right | + \left | y_1 - y_2\right |\\ =\ & x_2 - x_1 + y_2 - y_1 \\ =\ & (x_2 + y_2) -(x_1 + y_1)\\ \end{aligned}每种情况的答案要么只与 $x+y$ 的值有关，要么只与 $x-y$ 的值有关，所以最后的答案为 \max \begin{Bmatrix} \max \begin{Bmatrix} x_i + y_i \end{Bmatrix} - \min \begin{Bmatrix} x_i + y_i \end{Bmatrix},\max \begin{Bmatrix} x_i - y_i \end{Bmatrix} - \min \begin{Bmatrix} x_i - y_i \end{Bmatrix} \end{Bmatrix}Code 1 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;int n, x, y, minx = 0x7fffffff, maxx, miny = 0x7fffffff, maxy;int main() &#123; read(n); for (int i = 1; i &lt;= n; i++) &#123; read(x), read(y); minx = min(minx, x + y), maxx = max(maxx, x + y); miny = min(miny, x - y), maxy = max(maxy, x - y); &#125; write(max(maxx - minx, maxy - miny)); putchar('\n'); return 0;&#125; 三、切比雪夫距离在 二维空间 内，两个点之间的切比雪夫距离为它们横坐标之差的绝对值与纵坐标之差的绝对值的最大值。设点 $A(x_1,y_1),B(x_2,y_2)$，则 $A,B$ 之间的切比雪夫距离用公式可以表示为： d(A,B) = \max(\left | x_1 - x_2\right | , \left | y_1 - y_2\right | )仍然是这个例子，下图中 $A,B$ 的坐标分别为 $A(6,5),B(2,2)$。 d(A,B) = \max(\left | 6 - 2\right | , \left | 5 - 2\right | )=\max(4,3)=4$n$ 维空间 的切比雪夫距离公式： \begin{aligned} d(x,y) &= \max\begin{Bmatrix} \left | x_1 - y_1\right | ,\left | x_2 - y_2\right |,\ldots,\left | x_n - y_n\right |\end{Bmatrix}\\ &= \max\begin{Bmatrix} \left | x_i - y_i\right | \end{Bmatrix}\\ \end{aligned}切比雪夫距离 的一般模型： 在国际象棋棋盘上，国王与王后从一个格子走到另一个格子的步数都是切比雪夫距离。 若网格图上的一个点到周围 $8$ 个点的距离都相同，则该网格图上两点的距离也为切比雪夫距离。 四、曼哈顿距离与切比雪夫距离的相互转化首先，我们考虑画出平面直角坐标系上所有到原点的 曼哈顿距离 为 $1$ 的点。 通过公式，我们很容易得到方程 $\left | x\right| +\left | y\right| = 1$。 将绝对值展开，得到 $4$ 个 一次函数 ，分别是： y = x + 1\ (x \geq 0, y \geq 0) y = -x + 1\ (x \leq 0, y \geq 0) y = x - 1\ (x \geq 0, y \leq 0) y = -x - 1\ (x \leq 0, y \leq 0)将这 $4$ 个函数画到平面直角坐标系上，得到一个边长为 $\sqrt{2}$ 的正方形，如下图所示： 正方形边界上所有的点到原点的 曼哈顿距离 都是 $1$ 。 同理，我们再考虑画出平面直角坐标系上所有到原点的 切比雪夫距离 为 $1$ 的点。 通过公式，我们知道 $\max(\left |x\right | ,\left | y\right| )=1$。 我们将式子展开，也同样可以得到可以得到 $4$ 条 线段，分别是： y = 1\ (-1\leq x \leq 1) y = -1\ (-1\leq x \leq 1) x = 1\ (-1\leq y \leq 1) x = -1\ (-1\leq y \leq 1)画到平面直角坐标系上，可以得到一个边长为 $2$ 的正方形，如下图所示： 正方形边界上所有的点到原点的 切比雪夫距离 都是 $1$ 。 将这两幅图对比，我们会神奇地发现： 这 $2$ 个正方形是 相似图形 。 所以，曼哈顿距离 与 切比雪夫距离 之间会不会有联系呢？ 接下来我们简略证明一下： 假设 $A(x_1,y_1),B(x_2,y_2)$， $A,B$ 两点的 曼哈顿距离 为： \begin{aligned} d(A,B)&=\left | x_1 - x_2\right | + \left | y_1 - y_2\right | \\ &= \max\begin{Bmatrix} x_1 - x_2 + y_1 - y_2, x_1 - x_2 + y_2 - y_1,x_2 - x_1 + y_1 - y_2, x_2 - x_1 + y_2 - y_1\end{Bmatrix}\\ &（把绝对值拆开，能够得到四个值，这四个值中的最大值是两个 非负数 之和，即 曼哈顿距离）\\ &= \max\begin{Bmatrix}\left | (x_1 + y_1) - (x_2 + y_2)\right | , \left | (x_1 - y_2) - (x_2 - y_2)\right | \end{Bmatrix}\\ \end{aligned}我们很容易发现，这就是 $(x_1 + y_1,x_1 - y_1), (x_2 + y_2,x_2 - y_2)$ 两点之间的 切比雪夫距离。 所以将每一个点 $(x,y)$ 转化为 $(x + y, x - y)$，新坐标系下的 切比雪夫距离 即为原坐标系下的 曼哈顿距离。 同理，$A,B$ 两点的 切比雪夫距离 为： \begin{aligned} d(A,B)&=\max\begin{Bmatrix} \left | x_1 - x_2\right | ,\left | y_1 - y_2\right | \end{Bmatrix}\\ &=\max\begin{Bmatrix} x_1 - x_2 , x_2 - x_1 , y_1 - y_2 , y_2 - y_1 \end{Bmatrix}\\ &= \max\begin{Bmatrix} \frac{x_1 + y_1}{2}-\frac{x_2 + y_2}{2} + \frac{x_1 - y_1}{2}-\frac{x_2 - y_2}{2}, \frac{x_2 + y_2}{2}-\frac{x_1 + y_1}{2} + \frac{x_2 - y_2}{2}-\frac{x_1 - y_1}{2},\\ \frac{x_1 + y_1}{2}-\frac{x_2 + y_2}{2} + \frac{x_2 - y_2}{2}-\frac{x_1 - y_1}{2}, \frac{x_2 + y_2}{2}-\frac{x_1 + y_1}{2} + \frac{x_1 - y_1}{2}-\frac{x_2 - y_2}{2}\end{Bmatrix}\\ &= \left | \frac{x_1 + y_1}{2}-\frac{x_2 + y_2}{2}\right | +\left |\frac{x_1 - y_1}{2}-\frac{x_2 - y_2}{2}\right | \\ \end{aligned}而这就是 $\left(\frac{x_1 + y_1}{2},\frac{x_1 - y_1}{2}\right),\left (\frac{x_2 + y_2}{2},\frac{x_2 - y_2}{2}\right)$ 两点之间的 曼哈顿距离。 所以将每一个点 $(x,y)$ 转化为 $\left(\frac{x + y}{2},\frac{x - y}{2}\right)$，新坐标系下的 曼哈顿距离 即为原坐标系下的 切比雪夫距离。 结论： 将切比雪夫坐标系旋转 $45^\circ$，再缩小到原来的一半，即可得到曼哈顿坐标系。 将点 $(x,y)$ 的坐标变为 $(x + y, x - y)$， 原坐标系中的 曼哈顿距离 $=$ 新坐标系中的 切比雪夫距离 将点 $(x,y)$ 的坐标变为 $\left( \frac{x + y}{2},\frac{x - y}{2} \right)$， 原坐标系中的 切比雪夫距离 $=$ 新坐标系中的 曼哈顿距离 碰到求 切比雪夫距离 或 曼哈顿距离 的题目时，我们往往可以相互转化来求解。两种距离在不同的题目中有不同的优缺点，要学会做出正确的选择。 例题： [Luogu]P5098 Solution 2 我们考虑将题目所求的 曼哈顿距离 转化为 切比雪夫距离，即把每个点的坐标 $(x,y)$ 变为 $(x + y, x - y)$ 。 所求的答案就变为 $\max \begin{Bmatrix} \max\begin{Bmatrix} \left | x_i - x_j\right| ,\left | y_i - y_j\right| \end{Bmatrix} \end{Bmatrix}$ 。 在所有点中，横坐标之差的最大值和纵坐标之差的最大值都有可能成为答案，所以我们只需要预处理出 $x,y$ 的最大值和最小值即可。时间复杂度为 $O(n)$ 。 Code 2 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;int n, x, y, a, b, minx = 0x7fffffff, maxx, miny = 0x7fffffff, maxy;int main() &#123; read(n); for (int i = 1; i &lt;= n; i++) &#123; read(a), read(b); x = a + b, y = a - b; minx = min(minx, x), maxx = max(maxx, x); miny = min(miny, y), maxy = max(maxy, y); &#125; write(max(maxx - minx, maxy - miny)); putchar('\n'); return 0;&#125; [Luogu]P3964 Description 给定 $n$ 个点，每个点的坐标为 $(x_i,y_i)$，且点 $(x,y)$ 到它周围 $8$ 个点 $(x-1,y)(x+1,y),(x,y-1),(x,y+1).(x-1,y+1),(x-1,y-1),(x+1,y+1),(x+1,y-1)$ 的距离均为 $1$ 。现要找到一个点，使其它点到这个点的距离和最小，输出这个最小值。 $(0 \leq n \leq 10^5,-10^9 \leq x_i,y_i \leq 10^9)$ Solution 很容易看出这道题属于 切比雪夫距离 的一般模型。即对于两个点 $(x_1, y_1),(x_2,y_2)$，它们之间的距离为 \max(\left | x_1 - x_2\right | , \left | y_1 - y_2\right | )直接求 切比雪夫距离 似乎很困难？考虑把 切比雪夫距离 转化为 曼哈顿距离，即把每个点的坐标 $(x,y)$ 变为 $(\frac{x + y}{2}, \frac{x - y}{2})$ 。 枚举所选的点 $i$，我们只需要计算其它点到它的曼哈顿距离和即可。 如果某个点 $j$ 的横坐标 $x_j \leq x_i$，则它的对总距离的贡献为 $x_i - x_j$，反之则为 $x_j - x_i$ 。 这样就可以分两种情况讨论了。 设前 $k$ 个点的横坐标都 $\leq x_i$，那么所有点横坐标的贡献和为 kx_i - \sum\limits_{i = 1}^k x_i + \sum\limits_{i = n-k}^n x_i - (n - k)x_i对于 $\sum\limits_{i = 1}^k x_i$ 和 $\sum\limits_{i = n-k}^n x_i$，我们可以预处理出 $x$ 的前缀和后 $O(1)$ 求得。 怎么求 $k$ 呢？显然可以将横坐标排序后二分得到。 纵坐标 $y$ 的计算方法与上面一样。时间复杂度为 $O(n \log n)$ 。 切比雪夫距离 转成 曼哈顿距离 时要除以 $2$，为了避免出现小数，我们可以横坐标和纵坐标同时乘上 $2$，最后答案除以 $2$ 。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1; int len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1e5;int n, x[MAXN + 5], y[MAXN + 5], p[MAXN + 5], q[MAXN + 5];LL ans = 0x7fffffffffffffff, prex[MAXN + 5], prey[MAXN + 5];int main() &#123; read(n); for (int a, b, i = 1; i &lt;= n; ++i) &#123; read(a), read(b); x[i] = p[i] = a + b, y[i] = q[i] = a - b;//转曼哈顿距离，且乘上 2 &#125; sort(p + 1, p + n + 1), sort(q + 1, q + n + 1);//排序 for (int a, b, i = 1; i &lt;= n; ++i)//维护前缀和 prex[i] = prex[i - 1] + p[i], prey[i] = prey[i - 1] + q[i]; for (int posx, posy, i = 1; i &lt;= n; ++i) &#123; posx = lower_bound(p + 1, p + n + 1, x[i]) - p; posy = lower_bound(q + 1, q + n + 1, y[i]) - q; //二分找到 x[i] 和 y[i] 是所有点中第几个大的 LL sumx, sumy; sumx = (LL) posx * x[i] - prex[posx] + prex[n] - prex[posx] - (LL) (n - posx) * x[i];//计算横坐标贡献 sumy = (LL) posy * y[i] - prey[posy] + prey[n] - prey[posy] - (LL) (n - posy) * y[i];//计算纵坐标贡献 ans = min(ans, sumx + sumy); &#125; write(ans / 2);//答案不要忘记除回去 putchar('\n'); return 0;&#125; 练习 [Luogu]AT3557 [Luogu]P3439 [Luogu]P2906 [Luogu]P4648]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>数论数学</tag>
        <tag>距离</tag>
      </tags>
  </entry>
</search>
