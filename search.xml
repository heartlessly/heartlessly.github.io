<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[「AtCoder AGC012-D」Colorful Balls]]></title>
    <url>%2F2019%2F04%2F01%2FAT2364%2F</url>
    <content type="text"><![CDATA[Description现在有 $n$ 个球，第 $i$ 个球的颜色为 $c_i$，重量为 $w_i$ 。你可以交换球 $i$ 和球 $j$ 的位置，当且仅当 $c_i$ 与 $c_j$ 相等，$w_i+w_j \leq X$，或者 $c_i$ 与 $c_j$ 不等，$w_i+w_j \leq Y$，求可能产生多少种不同的颜色序列。答案对 $10^9+7$ 取模。 Source[Luogu]AT2364 [AtCoder]AGC012-D Solution首先可以发现一个性质：如果球 $i$ 可以和球 $j$ 换，球 $j$ 可以和球 $k$ 换，那球 $i$ 也可以和球 $k$ 换。原因很简单，假设原来排列是 $i\ j\ k$，可以先换 $i,\ j$ 得到 $j\ i\ k$，再换 $j,\ k$ 得到 $k\ i\ j$，最后交换 $i,\ j$ 就能得到 $k\ j\ i$，即交换了 $i,\ k$ 。通过这个性质，我们还能够发现 $i\ j\ k$ 的所有排列都可以通过交换得到，也就是说 $i\ j\ k\ ;\ i\ k\ j\ ;\ j\ i\ k\ ;\ j\ k\ i\ ;\ k\ i\ j\ ;\ k\ j\ i$ 都能够得到。这个规律可以推广到 $n$ 个球。 很容易想到建一个无向图来表示能否交换。如果球 $a$ 和球 $b$ 能够交换，我们就在 $a,\ b$ 之间连一条无向边，在同一个连通块内的球都可以互相交换，根据乘法原理，最后的答案就是每个连通块内颜色序列数的乘积。每个连通块的答案怎么算呢？因为球的颜色可能是相同的，所以我们要求 有重复元素的排列个数 。这里给出计算公式： 如果在 $n​$ 个元素中，有 $n_1​$ 个元素彼此相同，$n_2​$ 个元素彼此相同，……，$n_m​$ 个元素彼此相同，且 $\sum_{i=1}^{m}n_i=n​$，则这 $n​$ 个元素的不重复排列个数为：$$\frac{n!}{\prod_{i=1}^{m}(n_i!)}$$对于这道题来说，一共有 $n$ 种颜色（题目已知），假设某个连通块的大小为 $size$，颜色为 $i$ 的球的个数为 $col_i$，则该连通块的答案为：$$\frac{size!}{\prod_{i=1}^{n}(col_i!)}$$我们用并查集可以很好地维护与连通块有关的问题，考虑每一个球能否与 $1\sim n​$ 除自己外的其它球交换，如果可以，就把它们合并到一个连通块里。预处理 $1\sim n​$ 的阶乘与阶乘的逆元，分别计算出每一个连通块的答案，求它们的乘积即能得到结果，时间复杂度为 $O(n^2)​$，而 $n\leq 2 \times 10^5​$，这显然是会超时的，所以我们考虑如何优化。 Code12]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>AtCoder</tag>
        <tag>Luogu</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉查找树(BST)简介]]></title>
    <url>%2F2019%2F03%2F21%2F%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91BST%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[介绍二叉查找树(Binary Search Tree) 又称 二叉排序树(Binary Sort Tree) ，亦称 二叉搜索树，简写为 BST 。 二叉查找树具有以下性质： 如果左子树非空，那么左子树上的所有节点的值均小于等于根节点的值。 如果右子树非空，那么右子树上的所有节点的值均大于等于根节点的值。 二叉查找树的 左子树 与 右子树 也分别为二叉查找树。 通俗地讲：二叉查找树上点的权值，左儿子 &lt; 根节点 &lt; 右儿子 。 根据这个性质，我们很容易发现二叉查找树的中序遍历是一个单调不减的序列。 那么，二叉查找树有什么作用呢？ 对于一个长度为 $8​$ 的序列： $1,\ 15,\ 5,\ 3,\ 8,\ 10,\ 9,\ 12,\ 10​$，该如何找到这个序列第 $k​$ 大的数，并且支持插入与删除元素呢？如果我们将其排序再进行查询，时间复杂度为 $O(n \log n)​$，这显然不够优秀。因此我们考虑构造出一棵二叉查找树，如图。 插入假设我们要向上述序列插入一个数 $11​$，我们从根节点开始。 我们发现 $11 &gt; 9$，因此我们把 $11$ 放到 $9$ 的右儿子。 此时 $12$ 比 $11$ 大了，为了保持二叉搜索树的性质，我们把 $11$ 放到 $12​$ 的左儿子。 $11 &gt; 10$，本来应该让 $11$ 和 $10$ 的右儿子继续比较，可是 $10$ 没有右儿子，因此我们把 $11$ 插入到该位置。 小结：插入一个数时，从根节点开始，依次比较要插入的数和当前节点的值，如果大于当前节点，就放到该结点的右儿子，如果小于当前节点，就放到该结点的左儿子，重复上述操作，直到下放的位置没有结点。如果中途碰到与某个节点相等，我们再定义一个 $cnt$ 数组，表示当前节点值的个数，并且加上 $1$ 。这样我们就完成了一个数的插入过程。 删除类似插入的过程，还是依次比较要删除的数和当前节点的值，不断下放，当找到目标节点时，并不需要把该节点整个删掉，只需要给该节点值的个数减 $1$ 。对于节点 $x$，如果 $cnt[x] = 0$， 则表示当前位置没有节点。当一个位置没有节点时，这棵树依旧满足二叉查找树的性质。 查询前驱$x$ 的前驱定义为小于 $x$ 的最大的数。那么如何找 $x​$ 的前驱呢？ 这里以 $6$ 为例，从根节点开始。 从前驱的定义可知，$6$ 的前驱一定比 $6$ 小。而 $9 &gt; 6$，所以把 $6$ 放在 $9$ 的左儿子。 $8$ 还是比 $6$ 大，因此我们把 $6$ 放到 $8$ 的左儿子。 我们发现 $3 &lt; 6$，但是并不知道 $3$ 是不是小于 $6$ 的数中最大的，我们还要去找比 $3$ 大的数，因为这些数也有可能成为答案。所以记录当前答案为 $3$，把 $6$ 放在 $3$ 的右儿子。 $5$ 还是比 $6$ 小，更新当前答案为 $5$，而 $5$ 没有右儿子，所以最后答案 （$6$ 的前驱）就是 $5$ 。 小结：寻找 $x$ 的前驱时，从根节点开始，依次比较 $x$ 和当前节点的值。如果当前节点的值大于 $x$，则往该节点的左儿子找，直到出现小于 $x$ 的节点。此时我们记录当前答案为这个节点的值，往这个节点的右儿子找，如果途中遇到的节点的值小于 $x$，就更新当前答案，否则结束查询，当前答案就是 $x$ 的前驱。 后继$x​$ 的后继定义为大于 $x​$ 的最小的数。 与前驱的操作恰恰相反，依次比较 $x​$ 和当前节点的值。如果当前节点的值小于 $x​$，则往该节点的右儿子找，直到出现大于 $x​$ 的节点。此时我们记录当前答案为这个节点的值，往这个节点的左儿子找，如果途中遇到的节点的值大于 $x​$，就更新当前答案，否则结束查询，当前答案就是 $x​$ 的后继。 已知排名求值排名定义为比当前数小的数的个数 $+1​$，现在需要寻找排名为 $x​$ 的数。 我们新定义一个数组 $size$，对于一个节点 $x$，$size[x]$ 表示 $x$ 以及它的子树大小之和，需要递归预处理出每个节点的 $size$，当然，插入与删除操作时也要更新 $size$ 数组。假设我们要寻找排名为 $7$ 的数是多少，从根节点开始，如图（红色的数字即为节点的 $size$）。 $9​$ 的左儿子的 $size​$ 为 $4​$，所以 $9​$ 的排名为 $5​$，而要寻找的数的排名为 $7​$，所以该数一定比 $9​$ 大，因此我们到 $9​$ 的右子树找。 此时到了一棵新的子树上，因为排名为 $5$ 以及 $5$ 之前的节点都不要了，所以我们需要在该子树上找排名为 $2$ 的数。$12$ 的左儿子的 $size$ 为 $2$，因此 $12$ 在该子树上的排名为 $3$，排名为 $2$ 的数一定比 $12$ 小，应该到 $12$ 的左子树找。 现在所在的子树又少了 $2$ 个节点，但这 $2$ 个节点的排名都比 $2$ 大，所以仍然在新子树中找排名为 $2$ 的数。因为 $10$ 没有左儿子（即 $size$ 为 $0$），所以 $10$ 的排名为 $1$，而要查询的数排名为 $2$，大于 $10$，应该到 $10$ 的右子树找。 排名为 $1​$ 的节点已经不要了，因此要在新子树中找排名为 $1​$ 的节点。而 $11​$ 没有左儿子（即 $size​$ 为 $0​$），所以 $11​$ 的排名为 $1​$ 。最后的答案就是 $11​$ 。 小结：已知排名求值时，先预处理出每个节点的子树大小 $size$，从根节点开始，依次检查每个节点的排名，每个节点 $x$ 的排名为它 左儿子的 $size$ 加上 $cnt[x]$ (该节点值的数量) 。如果该节点的排名比要查询的排名小，则在该节点的右子树中查询 当前要查询的排名 - 该节点排名 的数。如果该节点排名更大，就在左子树中继续查询这个排名的数。如果排名相等，则该节点的值就是答案。 已知值求排名与已知排名求值的过程相似，以查询 $11$ 的排名为例，从根节点开始，初始没有数比 $11$ 小，所以 $11$ 的排名为 $1​$ 。 $9​$ 的排名为它左儿子的 $size​$ 加上它的 $cnt​$，也就是 $5​$，显然 $9 &lt; 11​$，所以 $11​$ 的排名变为 $1 + 5 = 6​$，并且往 $9​$ 的右子树找。 因为 $12 &gt; 11$，没有数比 $11$ 小，所以往 $12$ 的左子树找。 $10$ 比 $11$ 小，因为 $10$ 没有左儿子（左儿子 $size$ 为 $0$），所以 $10$ 在该子树中的排名为 $1$ 。$11$ 的排名更新为 $6 + 1 = 7$，并往 $10$ 的右子树找。 与目标节点重合，停止查询，$7$ 即为 $11$ 的排名。 小结：已知值求排名时，初始化已知值的排名为 $1$ 。从根节点开始，依次检查每个节点的值，如果该节点的值比已知值小，则排名更新为 它当前的排名 加上 该节点的排名，每个节点 $x$ 的排名为它 左儿子的 $size$ 加上 $cnt[x]$ (该节点值的数量) ，往该节点的右子树走。如果该节点的值比已知值大，则往该节点的左子树走。如果与已知值相等，则停止查询，当前排名就是这个值最终的排名。 总结普通的二叉查找树在数据随机的情况下所有操作的时间复杂度都是 $O(\log n)$ 的，但是在最劣情况下会变成一条链，时间复杂度为 $O(n)$，因此我们需要旋转，分裂等操作来维护二叉查找树，使其时间复杂度稳定为 $O(\log n)$，这种二叉查找树称作平衡二叉树，简称平衡树。平衡树的常见实现方法有 Treap , Splay , AVL , 替罪羊树 , 红黑树 等，这里不作介绍。]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伸展树(Splay)小结]]></title>
    <url>%2F2019%2F03%2F21%2F%E4%BC%B8%E5%B1%95%E6%A0%91Splay%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前置知识二叉查找树(BST) 线段树 简介伸展树(Splay Tree) 是平衡二叉树的一种，也属于二叉查找树，使用旋转保持平衡。它能在 $O(\log n)​$ 内完成插入、删除和查询操作，还具有很强的区间操作能力，所以也能作为 LCT 的辅助树，可以说是一种万能的平衡树。 原理咕咕咕]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
        <tag>Splay</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同余问题知识归纳]]></title>
    <url>%2F2019%2F03%2F18%2F%E5%90%8C%E4%BD%99%E9%97%AE%E9%A2%98%E7%9F%A5%E8%AF%86%E5%BD%92%E7%BA%B3%2F</url>
    <content type="text"><![CDATA[同余问题在数论中是最重要也是最基础的部分之一。 给定正整数 $m$ 与 整数 $a,b$，如果满足 $m\ |\ a - b$，或者说 $a\ \%\ m = b\ \%\ m$，则称 $a$ 与 $b$ 对模 $m$ 同余，记为 $a \equiv b \pmod m$，这个式子称作 同余式 。 e.g. $7 \equiv 1 \pmod 3​$ 同余式的性质自反性$a \equiv a \pmod m$ 对称性若 $a \equiv b \pmod m$，则 $b \equiv a \pmod m$ 。 传递性若 $a \equiv b \pmod m$，且 $b \equiv c \pmod m$，则 $a \equiv c \pmod m$ 。 同加性若 $a \equiv b \pmod m$，则 $a + c \equiv b + c \pmod m$ 。 同乘性若 $a \equiv b \pmod m$，则 $a \times c \equiv b \times c \pmod m$ 若 $a \equiv b \pmod m$，且 $c \equiv d \pmod m$，则 $a \times c \equiv b \times d \pmod m$ 同幂性若 $a \equiv b \pmod m​$，则 $a ^ n \equiv b ^ n \pmod m​$ 同除性注意，同余式不具有同除性， 咕咕咕]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>笔记</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SPOJ2713/BZOJ3211」GSS4 - Can you answer these queries Ⅳ/花神游历各国]]></title>
    <url>%2F2019%2F03%2F13%2FSPOJ2713%2F</url>
    <content type="text"><![CDATA[Description给定 $n$ 个数，已知： $$\sum_{i=1}^{n}a[i] \leq 10^{18}$$ $m$ 个操作： $0\ x\ y:$ 将区间 $[x,y]$ 内的每一个数开 平方根（下取整） 。 $1\ x\ y:$ 询问区间 $[x,y]$ 所有数的和。 Source[Luogu]SP2713 [Luogu]P4145 [BZOJ]3211 [SPOJ]GSS4 Solution因为要维护区间和，所以我们想到用线段树来维护。 但是会发现懒惰标记不能打，那该怎么办呢？ 考虑暴力修改： $a[i]$ 最大为 $10^{18}$。 $$\left \lfloor \sqrt{\sqrt{\sqrt{\sqrt{\sqrt{\sqrt{10^{18}}}}}}}\right \rfloor = 1$$ 换言之， $$\left \lfloor \sqrt[2^6]{10^{18}}\right \rfloor = 1$$ 一个数最多开 $6$ 次平方根就会变成 $1$ 。 因为 $\sqrt{1} = 1,\sqrt{0} = 0$， 我们只需要维护 区间和 与 区间最大值 即可， 当一个区间的最大值 $\leq 1$ 时，我们对这个区间的修改就是无用的。 而我们对一个数的开平方操作不会超过 $6$ 次，所以时间复杂度仍是 $O(n \log n)$ 。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 10, len = 1; while (y &lt;= x) &#123; y *= 10; ++len; &#125; while (len--) &#123; y /= 10; putchar(x / y + 48); x %= y; &#125;&#125;const int MAXN = 1e5 + 10;struct SegmentTree &#123; LL sum[MAXN &lt;&lt; 2], maxx[MAXN &lt;&lt; 2]; inline int lson(int x) &#123; return x &lt;&lt; 1; &#125; inline int rson(int x) &#123; return x &lt;&lt; 1 | 1; &#125; inline void pushUp(int x) &#123; sum[x] = sum[lson(x)] + sum[rson(x)]; maxx[x] = max(maxx[lson(x)], maxx[rson(x)]); &#125; void build(int x, int l, int r, LL *a) &#123; if (l == r) &#123; sum[x] = a[l]; maxx[x] = a[l]; return; &#125; int mid = (l + r) &gt;&gt; 1; build(lson(x), l, mid, a), build(rson(x), mid + 1, r, a); pushUp(x); &#125; void update(int ql, int qr, int l, int r, int x) &#123; if (maxx[x] &lt;= 1) return;//如果区间最大值小于等于1，就可以直接忽略这个区间的修改操作 if (l == r) &#123; sum[x] = sqrt(sum[x]); maxx[x] = sqrt(maxx[x]); return; &#125; int mid = (l + r) &gt;&gt; 1; if (ql &lt;= mid) update(ql, qr, l, mid, lson(x)); if (qr &gt; mid) update(ql, qr, mid + 1, r, rson(x)); pushUp(x); &#125; LL query(int ql, int qr, int l, int r, int x) &#123; if (ql &lt;= l &amp;&amp; qr &gt;= r) return sum[x]; int mid = (l + r) &gt;&gt; 1; LL res = 0; if (ql &lt;= mid) res += query(ql, qr, l, mid, lson(x)); if (qr &gt; mid) res += query(ql, qr, mid + 1, r, rson(x)); return res; &#125;&#125; tr;int n, m;LL a[MAXN];int main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) read(a[i]); tr.build(1, 1, n, a); read(m); for (int opt, l, r, i = 1; i &lt;= m; ++i) &#123; read(opt), read(l), read(r); if (l &gt; r) swap(l, r); if (opt == 1) &#123; write(tr.query(l, r, 1, n, 1)); putchar('\n'); &#125; else tr.update(l, r, 1, n, 1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>题解</tag>
        <tag>BZOJ</tag>
        <tag>线段树</tag>
        <tag>SPOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SPOJ1716」GSS3 - Can you answer these queries Ⅲ]]></title>
    <url>%2F2019%2F03%2F13%2FSPOJ1716%2F</url>
    <content type="text"><![CDATA[Description给定一个长度为 $n (n \leq 50000,|a[i]| \leq 10000)$ 的整数序列 和 $m$ 个操作： $0\ x\ y:$ 把 $a[x]$ 的值修改为 $y$ $|y \leq 10000|$。 $1\ x\ y:$ 询问区间 $[l,r]$ 的最大子段和。 Source[Luogu]SP1716 [SPOJ]GSS3 Solution仅仅是比 「SPOJ1043」GSS1 多了一个单点修改操作，暴力修改并且加上 $\mathrm{pushUp}$ 操作即可。 $\mathrm{pushUp}$ 操作 和 $\mathrm{query}$ 操作 的详细实现过程请看上一行链接。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 10, len = 1; while (y &lt;= x) &#123; y *= 10; ++len; &#125; while (len--) &#123; y /= 10; putchar(x / y + 48); x %= y; &#125;&#125;const int MAXN = 5e4 + 10;struct SegmentTree &#123; struct Node &#123; LL sum, lsum, rsum, res; &#125; seg[MAXN &lt;&lt; 2]; inline int lson(int x) &#123; return x &lt;&lt; 1; &#125; inline int rson(int x) &#123; return x &lt;&lt; 1 | 1; &#125; inline void pushUp(int x) &#123; seg[x].sum = seg[lson(x)].sum + seg[rson(x)].sum; seg[x].res = max(max(seg[lson(x)].res, seg[rson(x)].res), seg[lson(x)].rsum + seg[rson(x)].lsum); seg[x].lsum = max(seg[lson(x)].lsum, seg[lson(x)].sum + seg[rson(x)].lsum); seg[x].rsum = max(seg[rson(x)].rsum, seg[lson(x)].rsum + seg[rson(x)].sum); &#125; void build(int x, int l, int r, LL *a) &#123; if (l == r) &#123; seg[x] = (Node) &#123; a[l], a[l], a[l], a[l] &#125;; return; &#125; int mid = (l + r) &gt;&gt; 1; build(lson(x), l, mid, a), build(rson(x), mid + 1, r, a); pushUp(x); &#125; void update(int q, int l, int r, int x, LL p) &#123; if (l == r) &#123; seg[x] = (Node) &#123; p, p, p, p &#125;; return; &#125; int mid = (l + r) &gt;&gt; 1; if (q &lt;= mid) update(q, l, mid, lson(x), p); else update(q, mid + 1, r, rson(x), p); pushUp(x); &#125; Node query(int ql, int qr, int l, int r, int x) &#123; if (ql &lt;= l &amp;&amp; qr &gt;= r) return seg[x]; int mid = (l + r) &gt;&gt; 1; if (qr &lt;= mid) return query(ql, qr, l, mid, lson(x)); if (ql &gt; mid) return query(ql, qr, mid + 1, r, rson(x)); Node ans, lx = query(ql, qr, l, mid, lson(x)), ly = query(ql, qr, mid + 1, r, rson(x)); ans.sum = lx.sum + ly.sum; ans.res = max(max(lx.res, ly.res), lx.rsum + ly.lsum); ans.lsum = max(lx.lsum, lx.sum + ly.lsum); ans.rsum = max(ly.rsum, lx.rsum + ly.sum); return ans; &#125;&#125; tr;int n, q, l, r;bool opt;LL a[MAXN];int main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) read(a[i]); tr.build(1, 1, n, a); for (read(q); q; --q) &#123; read(opt), read(l), read(r); if (!opt) tr.update(l, 1, n, 1, r); else &#123; write(tr.query(l, r, 1, n, 1).res); putchar('\n'); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>题解</tag>
        <tag>线段树</tag>
        <tag>SPOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SPOJ1043」GSS1 - Can you answer these queries Ⅰ]]></title>
    <url>%2F2019%2F03%2F12%2FSPOJ1043%2F</url>
    <content type="text"><![CDATA[Description给定一个长度为 $n (n \leq 50000,|a[i]| \leq 15007)$ 的整数序列，对于 $m$ 个询问 $l,r$，求区间 $[l,r]$ 的最大子段和。 Source[Luogu]SP1043 [SPOJ]GSS1 Solution如果用朴素的最大子段和算法，时间复杂度为 $O(nm)$，一定会超时。 很容易想到用数据结构来维护。 我们建立一棵线段树，对于区间 $x$，有以下定义： $sum[x]$ 表示区间和； $lsum[x]$ 表示以该区间左端点为起点的最大子段和； $rsum[x]$ 表示以该区间右端点为起点的最大子段和； $res[x]$ 表示该区间内的最大子段和。 与普通的线段树不同，这道题维护的信息很多，我们先来分析该题最重要的 $\mathrm{pushUp}$ 与 $\mathrm{query}$ 操作。 $\mathrm{pushUp}$ 操作首先，是维护区间和，最基本的线段树操作，就不用多说了： $$sum[x] = sum[lson(x)] + sum[rson(x)]$$ 其次，假如我们知道一个区间的左右子区间信息，如何更新该区间的最大子段和？ 很显然，答案可能为 左区间的最大子段和 或 右区间的最大子段和 。 除此之外，合并区间后，答案也有可能为 左区间的右起最大子段和 + 右区间的左起最大子段和，如上图。 由此我们可以得到代码： $$res[x]=\max\begin{Bmatrix}res[lson(x)],res[rson(x)],rsum[lson(x)]+lsum[rson(x)]\end{Bmatrix}$$ 那如何更新该区间的 左起最大子段和 和 右起最大子段和 呢？ 区间左起最大子段和可以是 左区间的左起最大子段和 或 左区间的区间和 + 右区间的左起最大子段和，如上图。 右起最大子段和将上述操作反过来即可。 代码实现如下： $$lsum[x]=\max(lsum[lson],sum[lson]+lsum[rson])$$ $$rsum[x]=\max(rsum[rson],rsum[lson]+sum[rsum])$$ $\mathrm{query}$ 操作 当答案来自两个不同的区间时（如图），我们需要对这两个区间答案进行合并，并不只是取最大值那样简单。 我们还需要进行类似 $\mathrm{pushUp}$ 的操作，已知左右区间的答案，更新该区间答案。 函数的返回值有很多，所以用结构体式线段树实现更方便。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 10, len = 1; while (y &lt;= x) &#123; y *= 10; ++len; &#125; while (len--) &#123; y /= 10; putchar(x / y + 48); x %= y; &#125;&#125;const int MAXN = 5e4 + 10;struct SegmentTree &#123; struct Node &#123; LL sum, lsum, rsum, res; &#125; seg[MAXN &lt;&lt; 2]; inline int lson(int x) &#123; return x &lt;&lt; 1; &#125; inline int rson(int x) &#123; return x &lt;&lt; 1 | 1; &#125; inline void pushUp(int x) &#123; seg[x].sum = seg[lson(x)].sum + seg[rson(x)].sum; seg[x].res = max(max(seg[lson(x)].res, seg[rson(x)].res), seg[lson(x)].rsum + seg[rson(x)].lsum); seg[x].lsum = max(seg[lson(x)].lsum, seg[lson(x)].sum + seg[rson(x)].lsum); seg[x].rsum = max(seg[rson(x)].rsum, seg[lson(x)].rsum + seg[rson(x)].sum); &#125; void build(int x, int l, int r, LL *a) &#123; if (l == r) &#123; seg[x] = (Node) &#123; a[l], a[l], a[l], a[l] &#125;; return; &#125; int mid = (l + r) &gt;&gt; 1; build(lson(x), l, mid, a), build(rson(x), mid + 1, r, a); pushUp(x); &#125; Node query(int ql, int qr, int l, int r, int x) &#123;//分成3种情况考虑 if (ql &lt;= l &amp;&amp; qr &gt;= r) return seg[x]; int mid = (l + r) &gt;&gt; 1; if (qr &lt;= mid) return query(ql, qr, l, mid, lson(x)); if (ql &gt; mid) return query(ql, qr, mid + 1, r, rson(x)); Node ans, lx = query(ql, qr, l, mid, lson(x)), ly = query(ql, qr, mid + 1, r, rson(x)); ans.sum = lx.sum + ly.sum; ans.res = max(max(lx.res, ly.res), lx.rsum + ly.lsum); ans.lsum = max(lx.lsum, lx.sum + ly.lsum); ans.rsum = max(ly.rsum, lx.rsum + ly.sum); return ans; &#125;&#125; tr;int n, q, l, r;LL a[MAXN];int main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) read(a[i]); tr.build(1, 1, n, a); for (read(q); q; --q) &#123; read(l), read(r); write(tr.query(l, r, 1, n, 1).res); putchar('\n'); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>题解</tag>
        <tag>线段树</tag>
        <tag>SPOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ1303/Luogu1627」「CQOI2009」中位数图]]></title>
    <url>%2F2019%2F03%2F12%2FBZOJ1303%2F</url>
    <content type="text"><![CDATA[Description给定长度为 $n$ 的序列，求有多少包含 $b$ 的奇数长度的序列中位数为 $b$ 。 Source[BZOJ]1303 [Luogu]P1627 Solution因为所求的是中位数，所以考虑改变原序列。把大于 $b$ 的数全部变为 $1$，小于 $b$ 的数变为 $-1$，等于 $b$ 则为 $0$。问题就变为求存在几个包含 $b$ 的区间和为 $0$ 。我们假设 $tmp$ 为 $b$ 的下标，原数组为 $x$，新数组为 $a$ 。 Sample Input127 45 7 2 4 3 1 6 Sample Output14 Example 对于样例，能使结果成立的 $4$ 个区间分别为 $[1,5]$ , $[1,7]$ , $[2,4]$ , $[4,4]$。 接下来我们建造两个桶，分别计数 $tmp$ 左边的后缀和与右边的前缀和，假设左边的后缀和为 $l$，右边的前缀和为 $r$ 。$l[i]/r[i]$ 表示从点 $i$ 向右/向左 到点 $tmp$ 为止 (比 $b$ 大的数的数量 - 比 $b$ 小的数的数量) 出现的次数。还是拿样例来说： 通过观察上图，我们能够发现，左边的数 $x$ 可以与右边的每一个 $-x$ 进行匹配。通过乘法原理，该值即为 $l[x] \times r[-x]$，由题意可知 $-10^5 \le x \le 10^5$，遍历所有的 $x$ 即可，最终答案为： $$\sum_{i=\min{x}}^{\max{x}}l[i] \times r[-i]$$ 值得注意的是，$l[0]$ 和 $r[0]$ 的初始值为 $1$，因为 $b$ 是需要被算入的。当然，桶的下标不能是负数，所以我在每次操作时都加上了一个很大的数，比如数据最大值 —— $10^5$，也可以用 $\mathrm{STL}$ 中的 $map$ 解决问题，时间复杂度为 $O(n)$ 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 10, len = 1; while (y &lt;= x) &#123; y *= 10; ++len; &#125; while (len--) &#123; y /= 10; putchar(x / y + 48); x %= y; &#125;&#125;const int MAXN = 1e5;int n, b, tmp, sum, a[MAXN + 10], l[MAXN &lt;&lt; 1 | 1], r[MAXN &lt;&lt; 1 | 1];LL ans;int main() &#123; read(n), read(b); for (int x, i = 1; i &lt;= n; ++i) &#123; read(x); if (x == b) tmp = i; else a[i] = x &gt; b ? 1 : -1; &#125; ++l[MAXN], ++r[MAXN]; for (int i = tmp - 1; i &gt;= 1; --i) &#123; sum += a[i]; ++l[sum + MAXN]; &#125;//后缀和 sum = 0; for (int i = tmp + 1; i &lt;= n; ++i) &#123; sum += a[i]; ++r[sum + MAXN]; &#125;//前缀和 for (int i = -MAXN; i &lt;= MAXN; ++i) ans += (LL) l[i + MAXN] * (LL) r[-i + MAXN];//公式计算答案 write(ans); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>BZOJ</tag>
        <tag>CQOI</tag>
        <tag>2009</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用距离算法详解]]></title>
    <url>%2F2019%2F03%2F11%2F%E5%B8%B8%E7%94%A8%E8%B7%9D%E7%A6%BB%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[在计算距离时，我们一般都是求两点之间的直线距离，实际上距离算法并不只这一种，还有其他的距离算法在 $\mathrm{OI}$ 中也同样很重要。不同的距离算法都有明显的优缺点。本文主要讲解 三种 常见的距离算法，分别是 欧氏距离，曼哈顿距离，切比雪夫距离 。 一、欧氏距离（欧几里得度量）欧氏距离，是一个通常采用的距离定义，指在$m$维空间中两个点之间的真实距离，或者向量的自然长度（即该点到原点的距离）。在二维和三维空间中的欧氏距离就是两点之间的实际距离。—— 来源：百度百科 欧氏距离 是最易于理解的一种距离算法。在数学的平面直角坐标系中，设点 $A,B$ 的坐标分别为 $A(x_1,y_1),B(x_2,y_2)$，求点 $A,B$ 之间的距离，我们一般会使用如下公式： $$\left | AB \right | = \sqrt{\left ( x_2 - x_1 \right )^2 + \left ( y_2 - y_1 \right )^2}$$ 实际上这就是平面（二维空间）中两点欧氏距离的距离公式，除此之外，$P(x,y)$ 到原点的欧氏距离可以用公式表示为： $$|P| = \sqrt{x^2+y^2}$$ 举个栗子，在下图中 $A,B$ 的坐标分别为 $A(6,5),B(2,2)$。 通过公式，我们很容易得到 $A,B$ 两点间的欧氏距离： $$\left | AB \right | = \sqrt{\left ( 2 - 6 \right )^2 + \left ( 2 - 5 \right )^2} = \sqrt{4^2+3^2} = 5$$ 那么，三维空间 中两点的欧氏距离公式呢？我们来观察下图。 我们很容易发现，在$\triangle ADC$中，$\angle ADC = 90^\circ$；在$\triangle ACB$中，$\angle ACB = 90^\circ$。 $$\therefore |AB|=\sqrt{|AC|^2+|BC|^2}$$$$=\sqrt{|AD|^2+|CD|^2+|BC|^2}$$ 由此可得，三维空间 中欧氏距离的距离公式为： $$\left | AB \right | = \sqrt{\left ( x_2 - x_1 \right )^2 + \left ( y_2 - y_1 \right )^2 + \left ( z_2 - z_1 \right )^2}$$ $$|P| = \sqrt{x^2+y^2+z^2}$$ 例题：[Luogu]3958 以此类推，我们就得到了 $n$ 维空间 中欧氏距离的距离公式： $$d(x,y) = \sqrt{\left ( x_1 - y_1 \right )^2 + \left ( x_2 - y_2 \right )^2 + \cdot \cdot \cdot +\left ( x_n - y_n \right )^2}$$$$ = \sqrt{\sum_{i = 1}^{n}(x_i - y_i)^2}$$ 欧氏距离虽然很有用，但也有明显的缺点。两个整点计算其欧氏距离时，往往答案是浮点型，会存在一定误差。 二、曼哈顿距离曼哈顿距离 是种使用在几何度量空间的几何学用语，用以标明两个点在标准坐标系上的绝对轴距总和。曼哈顿距离不是距离不变量，当坐标轴变动时，点间的距离就会不同。—— 来源：百度百科 在 二维空间 内，两个点之间的曼哈顿距离为它们横坐标之差的绝对值与纵坐标之差的绝对值之和。设点 $A(x_1,y_1),B(x_2,y_2)​$，则 $A,B​$ 之间的曼哈顿距离用公式可以表示为： $$d(A,B) = |x_1 - x_2| + |y_1 - y_2|$$ 观察下图： 在 $A,B$ 间，$\color{yellow}{黄线}$，$\color{orange}{橙线}$ 都表示曼哈顿距离，而$\color{red}{红线}$，$\color{blue}{蓝线}$表示 等价 的曼哈顿距离，$\color{green}{绿线}$表示欧氏距离。 同样的栗子，在下图中 $A,B​$ 的坐标分别为 $A(6,5),B(2,2)​$。 通过公式，我们很容易得到 $A,B$ 两点间的曼哈顿距离：$$d(A,B) = |6 - 2| + |5 - 2| = 4 + 3 = 7$$ 经过推导，我们得到 $n$ 维空间 的曼哈顿距离公式为：$$d(A,B) = |x_1 - y_1| + |x_2 - y_2| + \cdot \cdot \cdot + |x_n - y_n|$$$$=\sum_{i = 1}^{n}|x_i - y_i|$$ 除了公式之外，曼哈顿距离还具有以下 数学性质： 非负性 曼哈顿距离是一个非负数。 $d(i,j)\geq 0$ 统一性 点到自身的曼哈顿距离为 $0$。 $d(i,i) = 0$ 对称性 $A$ 到 $B$ 与 $B$ 到 $A$ 的曼哈顿距离相等，且是对称函数。 $d(i,j) = d(j,i)$ 三角不等式 从点 $i$ 到 $j$ 的直接距离不会大于途经的任何其它点 $k$ 的距离。 $d(i,j)\leq d(i,k)+d(k,j)$ 例题：[Luogu]5098 解析： （不要被难度吓住，是假的） 根据题意，对于式子$|x_1-x_2|+|y_1-y_2|$，我们可以假设 $x_1 - x_2 \geq 0$，根据 $y_1 - y_2$ 的符号分成两种情况： $(y_1 - y_2 \geq 0)\rightarrow |x_1-x_2|+|y_1-y_2|=x_1 + y_1 - (x_2 + y_2)$ $(y_1 - y_2&lt; 0)\rightarrow |x_1-x_2|+|y_1-y_2|=x_1 - y_1 - (x_2 - y_2)$ 只要分别求出 $x+y, x-y$ 的最大值和最小值即能得出答案。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 10, len = 1; while (y &lt;= x) &#123; y *= 10; ++len; &#125; while (len--) &#123; y /= 10; putchar(x / y + 48); x %= y; &#125;&#125;int n, x, y, minx = 0x7fffffff, maxx, miny = 0x7fffffff, maxy;int main() &#123; read(n); for (int i = 1; i &lt;= n; i++) &#123; read(x), read(y); minx = min(minx, x + y), maxx = max(maxx, x + y); miny = min(miny, x - y), maxy = max(maxy, x - y); &#125; write(max(maxx - minx, maxy - miny)); putchar('\n'); return 0;&#125; 其实还有第二种做法，那就是把 曼哈顿距离 转化为 切比雪夫距离 求解，后面会讲到。 三、切比雪夫距离切比雪夫距离 是向量空间中的一种度量，二个点之间的距离定义是其各坐标数值差绝对值的最大值。—— 来源：百度百科 在 二维空间 内，两个点之间的切比雪夫距离为它们横坐标之差的绝对值与纵坐标之差的绝对值的最大值。设点 $A(x_1,y_1),B(x_2,y_2)$，则 $A,B$ 之间的切比雪夫距离用公式可以表示为： $$d(A,B) = max(|x_1 - x_2|, |y_1 - y_2|)$$ 仍然是这个栗子，下图中 $A,B$ 的坐标分别为 $A(6,5),B(2,2)$。 $$d(A,B) = \max(|6 - 2|, |5 - 2|)=\max(4,3)=4$$ $n$ 维空间 中切比雪夫距离的距离公式： $$d(x,y) = \max\begin{Bmatrix} |x_1 - y_1|,|x_2 - y_2|,\cdot \cdot \cdot,|x_n - y_n|\end{Bmatrix}$$$$ = \max\begin{Bmatrix} |x_i - y_i|\end{Bmatrix}(i \in n)$$ 四、（拓展）曼哈顿距离与切比雪夫距离的相互转化首先，我们考虑画出平面直角坐标系上所有到原点的 曼哈顿距离 为 $1$ 的点。 通过公式，我们很容易得到方程 $|x| + |y| = 1$。 将绝对值展开，得到 $4$ 个 一次函数 ，分别是： $$y = x + 1(x \geq 0, y \geq 0)$$ $$y = -x + 1(x \leq 0, y \geq 0)$$ $$y = x - 1(x \geq 0, y \leq 0)$$ $$y = -x - 1(x \leq 0, y \leq 0)$$ 将这 $4$ 个函数画到平面直角坐标系上，得到一个边长为 $\sqrt{2}$ 的正方形，如下图所示： 正方形边界上所有的点到原点的 曼哈顿距离 都是 $1$ 。 同理，我们再考虑画出平面直角坐标系上所有到原点的 切比雪夫距离 为 $1$ 的点。 通过公式，我们知道 $\max(|x|,|y|)=1$。 我们将式子展开，也同样可以得到可以得到 $4$ 条 线段，分别是： $$y = 1(-1\leq x \leq 1)$$ $$y = -1(-1\leq x \leq 1)$$ $$x = 1,(-1\leq y \leq 1)$$ $$x = -1,(-1\leq y \leq 1)$$ 画到平面直角坐标系上，可以得到一个边长为 $2$ 的正方形，如下图所示： 正方形边界上所有的点到原点的 切比雪夫距离 都是 $1$ 。 将这两幅图对比，我们会神奇地发现： 这 $2$ 个正方形是 相似图形 。 所以，曼哈顿距离 与 切比雪夫距离 之间会不会有联系呢？ 接下来我们简略证明一下： 假设 $A(x_1,y_1),B(x_2,y_2)$， $A,B$ 两点的 曼哈顿距离 为：$$d(A,B)=|x_1 - x_2| + |y_1 - y_2|$$$$=|x_1 - x_2| + |y_1 - y_2|$$$$= \max\begin{Bmatrix} x_1 - x_2 + y_1 - y_2, x_1 - x_2 + y_2 - y_1,x_2 - x_1 + y_1 - y_2, x_2 - x_1 + y_2 - y_1\end{Bmatrix} $$ （ 把绝对值拆开，能够得到四个值，这四个值中的最大值是两个 非负数 之和，即 曼哈顿距离 ）$$= \max\begin{Bmatrix}|(x_1 + y_1) - (x_2 + y_2)|, |(x_1 - y_2) - (x_2 - y_2)|\end{Bmatrix}$$ 我们很容易发现，这就是 $(x_1 + y_1,x_1 - y_1), (x_2 + y_2,x_2 - y_2)$ 两点之间的 切比雪夫距离。 所以将每一个点 $(x,y)$ 转化为 $(x + y, x - y)$，新坐标系下的 切比雪夫距离 即为原坐标系下的 曼哈顿距离。 同理，$A,B$ 两点的 切比雪夫距离 为：$$d(A,B)=\max\begin{Bmatrix} |x_1 - x_2|,|y_1 - y_2|\end{Bmatrix} $$$$=\max\begin{Bmatrix} |\frac{x_1 + y_1}{2}-\frac{x_2 + y_2}{2}|+|\frac{x_1 - y_1}{2}-\frac{x_2 - y_2}{2}|\end{Bmatrix} $$ 而这就是 $(\frac{x_1 + y_1}{2},\frac{x_1 - y_1}{2}), (\frac{x_2 + y_2}{2},\frac{x_2 - y_2}{2})$ 两点之间的 曼哈顿距离。 所以将每一个点 $(x,y)$ 转化为 $(\frac{x + y}{2},\frac{x - y}{2})$，新坐标系下的 曼哈顿距离 即为原坐标系下的 切比雪夫距离。 结论： 将切比雪夫坐标系旋转 $45^\circ$，再缩小到原来的一半，即可得到曼哈顿坐标系。 将点 $(x,y)$ 的坐标变为 $(x + y, x - y)$， 原坐标系中的 曼哈顿距离 $=$ 新坐标系中的 切比雪夫距离 将点 $(x,y)$ 的坐标变为 $(\frac{x + y}{2},\frac{x - y}{2})$， 原坐标系中的 切比雪夫距离 $=$ 新坐标系中的 曼哈顿距离 碰到求 切比雪夫距离 或 曼哈顿距离 的题目时，我们往往可以相互转化来求解。两种距离在不同的题目中有不同的优缺点，应该灵活运用。 例题： [Luogu]4648（曼哈顿距离转切比雪夫距离） [Luogu]3964（切比雪夫距离转曼哈顿距离） 最后给出 [Luogu]5098 的第二种解法： 我们考虑将题目所求的 曼哈顿距离 转化为 切比雪夫距离，即把每个点的坐标 $(x,y)$ 变为 $(x + y, x - y)$。 所求的答案就变为 $\max_{\forall i,j\in n}\begin{Bmatrix} \max\begin{Bmatrix} |x_i - x_j|,|y_i - y_j|\end{Bmatrix}\end{Bmatrix}$ 现要使得横坐标之差和纵坐标之差最大，只需要预处理出 $x,y$ 的最大值和最小值即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 10, len = 1; while (y &lt;= x) &#123; y *= 10; ++len; &#125; while (len--) &#123; y /= 10; putchar(x / y + 48); x %= y; &#125;&#125;int n, x, y, a, b, minx = 0x7fffffff, maxx, miny = 0x7fffffff, maxy;int main() &#123; read(n); for (int i = 1; i &lt;= n; i++) &#123; read(a), read(b); x = a + b, y = a - b; minx = min(minx, x), maxx = max(maxx, x); miny = min(miny, y), maxy = max(maxy, y); &#125; write(max(maxx - minx, maxy - miny)); putchar('\n'); return 0;&#125; 对比两份代码，我们又能够发现，两种不同的思路，写出来的代码却是完全等价的，是不是很神奇呢？当然，更高深的东西需要大家另行研究。]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>数学</tag>
        <tag>笔记</tag>
        <tag>距离</tag>
      </tags>
  </entry>
</search>
