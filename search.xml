<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[「Codeforces 24D」Broken robot]]></title>
    <url>%2F2019%2F04%2F08%2FCF24D%2F</url>
    <content type="text"><![CDATA[Description现在有一个机器人，最初站在 $n \times m\ (1 \leq n,m\leq 1000)​$ 矩阵中的 $(x,y)\ (1 \leq x \leq n, 1\leq y \leq m)​$ 位置。每次它会等概率的选择 原地不动，向左移动，向右移动，向下移动 四种操作。当然，机器人在第 $1​$ 列时不会选择向左移动，第 $m​$ 列时不会选择向右移动。求机器人到达第 $n​$ 行的期望步数，至少精确到 $10^{-4}​$ 。 Source[Luogu]CF24D [Codeforces]24D Solution求期望步数，很容易想到 期望DP 。我们用 $f_{i,j}$ 表示从 $(i,j)$ 走到最后一行的期望步数，那么初始状态就是 $f_{n,i} = 0\ (1 \leq i \leq m)$（从最后一行走到最后一行的期望步数为 $0$），要求的答案就是 $f_{x,y}$（根据状态即能得到），状态转移方程如下（分 $3​$ 种情况讨论）： f_{i,j}=\left\{\begin{matrix} \frac{1}{3}\left ( f_{i,j} + f_{i,j+1} + f_{i+1,j} \right )+1& (j=1)\\ \frac{1}{4}\left ( f_{i,j} + f_{i,j+1} + f_{i,j-1} + f_{i+1,j} \right )+1& (1< j< m) \\ \frac{1}{3}\left ( f_{i,j} + f_{i,j-1} + f_{i+1,j} \right )+1& (j=m) \\ \end{matrix}\right.值得注意的是：$m = 1​$ 时比较特殊，因为不能向左和向右移动，此时 f_{i,j}=\frac{1}{2} \left( f_{i,j} + f_{i+1,j} \right) + 1这个方程是倒推的，并且有后效性，所以不能直接转移。在求 $f_{i,j}​$ 时，$f_{i+1,j}​$ 是 已知 的，而 $f_{i,j-1},f_{i,j},f_{i,j+1}​$ 都是 未知 的，我们把未知量移到左边，把已知量移到右边，可以得到： \left\{\begin{matrix} -\frac{2}{3}f_{i,j}+\frac{1}{3}f_{i,j+1}=-\frac{1}{3}f_{i+1,j}-1 & (j=1)\\ \frac{1}{4}f_{i,j-1}-\frac{3}{4}f_{i,j}+\frac{1}{4}f_{i,j+1}=-\frac{1}{4}f_{i+1,j}-1& (1 < j < m)\\ \frac{1}{3}f_{i,j-1}-\frac{2}{3}f_{i,j}=-\frac{1}{3}f_{i+1,j}-1 & (j=m)\\ \end{matrix}\right.同理，$m = 1​$ 时， -\frac{1}{2}f_{i,j} = -\frac{1}{2}f_{i+1,j} - 1我们会发现一共有 $m​$ 个未知数和 $m​$ 个方程，很容易想到 高斯消元 求解未知量 $f_{i,1} \sim f_{i,m}\ (1 \leq i &lt; n)​$ 。 比如说，当 $m = 5​$ 时，所构成的矩阵就是： \begin{bmatrix} -\frac{2}{3} & \color{blue}{\frac{1}{3}} & 0 & 0 & 0\\ \color{red}{\frac{1}{4}} & -\frac{3}{4} & \color{blue}{\frac{1}{4}} & 0 & 0\\ 0 & \color{red}{\frac{1}{4}} & -\frac{3}{4} & \color{blue}{\frac{1}{4}} & 0\\ 0 & 0 & \color{red}{\frac{1}{4}} & -\frac{3}{4} & \color{blue}{\frac{1}{4}}\\ 0 & 0 & 0 & \color{red}{\frac{1}{3}} & -\frac{2}{3}\\ \end{bmatrix} =\begin{bmatrix} -\frac{1}{3}f_{i+1,j}-1\\ -\frac{1}{4}f_{i+1,j}-1\\ -\frac{1}{4}f_{i+1,j}-1\\ -\frac{1}{4}f_{i+1,j}-1\\ -\frac{1}{3}f_{i+1,j}-1\\ \end{bmatrix}本来 高斯消元 的时间复杂度应该是 $O(n^3)​$ 的。但是观察矩阵能够发现，其实这是一个稀疏矩阵，未知数全部集中在对角线上，$0​$ 的地方不需要消元，我们需要消元的只有 $m - 1​$ 个数（上图 $\color{red}{红色}​$ 的数字），回带时原方程中也只需要消去 $m - 1​$ 个数（上图 $\color{blue}{蓝色}​$ 的数字），所以本题中 高斯消元 时间复杂度为 $O(m)​$ 。总时间复杂度为 $O(nm)​$ 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;using namespace std;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); x = f ? -x : x;&#125;const int MAXN = 1000;int n, m, x, y;double a[MAXN + 5][MAXN + 5], f[MAXN + 5][MAXN + 5];inline void Gauss() &#123; for (int i = 1; i &lt; m; ++i) &#123; double t = a[i][i]; a[i][i] = 1; a[i][i + 1] /= t; a[i][m + 1] /= t; t = a[i + 1][i]; a[i + 1][i] = 0; a[i + 1][i + 1] -= t * a[i][i + 1]; a[i + 1][m + 1] -= t * a[i][m + 1]; &#125;//消元，消去下一行方程开头的未知数 a[m][m + 1] /= a[m][m]; a[m][m] = 1;//求出最后一个未知数的解 for (int i = m - 1; i; --i) a[i][m + 1] -= a[i + 1][m + 1] * a[i][i + 1];//回带，消去下一行方程末尾的未知数&#125;int main() &#123; freopen("eat.in", "r", stdin); freopen("eat.out", "w", stdout); read(n), read(m), read(x), read(y); for (int i = n - 1; i &gt;= x; --i) &#123; if (m == 1) &#123; a[1][1] = -1.0 / 2; a[1][m + 1] = -f[i + 1][1] / 2.0 - 1;//特判 m = 1 &#125; else &#123; a[1][1] = -2.0 / 3; a[1][2] = 1.0 / 3; a[1][m + 1] = -f[i + 1][1] / 3.0 - 1.0; for (int j = 2; j &lt; m; ++j) &#123; a[j][j] = -3.0 / 4; a[j][j - 1] = a[j][j + 1] = 1.0 / 4; a[j][m + 1] = -f[i + 1][j] / 4.0 - 1; &#125; a[m][m] = -2.0 / 3; a[m][m - 1] = 1.0 / 3; a[m][m + 1] = -f[i + 1][m] / 3.0 - 1; &#125;//构造矩阵 Gauss();//高斯消元 for (int j = 1; j &lt;= m; ++j) f[i][j] = a[j][m + 1];//赋值求出的解 &#125; printf("%.10lf\n", f[x][y]); return 0;&#125;]]></content>
      <tags>
        <tag>数论数学</tag>
        <tag>题解</tag>
        <tag>高斯消元</tag>
        <tag>概率期望</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见积性函数]]></title>
    <url>%2F2019%2F04%2F05%2Fchang-jian-ji-xing-han-shu%2F</url>
    <content type="text"><![CDATA[定义积性函数 指对于 任意互质的整数 $a$ 和 $b$ 有性质 $f(ab)=f(a)\times f(b)$ 的数论函数。 完全积性函数 指对于 任意整数 $a$ 和 $b$ 有性质 $f(ab)=f(a)\times f(b)$ 的数论函数。 很显然 完全积性函数 是 积性函数 的一个子集。 积性函数欧拉函数定义：欧拉函数，属于 积性函数，但不是完全积性函数。常用 $\varphi$ 表示，读作 fai 。 $\varphi(n)$ 定义为小于等于 $n$ 的正整数中与 $n$ 互质的数的个数。 公式：若 $p_1 , p_2 ,\ldots, p_m$ 为 $x$ 的所有 互不相同 的质因数，$n$ 是一个不为 $0$ 的整数，则 \begin{aligned} \varphi(n)&=n\times\left ( 1-\frac{1}{p_1}\right )\times \left ( 1-\frac{1}{p_2}\right )\times \cdots \times \left ( 1-\frac{1}{p_m}\right )\\ &=n\prod\limits_{i=1}^{m}\left ( 1-\frac{1}{p_i}\right )\\ \end{aligned}性质 &amp; 证明：性质 1： 若 $n , m​$ 互质，则 $\varphi(nm)=\varphi(n) \times \varphi(m)​$ 。 证明： 积性函数特有性质。 性质 2： 若 $n​$ 为 质数，则 $\varphi(n)=n-1​$ 。 证明： 所有小于 $n$ 的正整数都与 $n$ 互质，一共 $n - 1$ 个。 性质 3： 若 $n​$ 为 奇数，则 $\varphi(2n)=\varphi(n)​$ 。 证明： 显然 $n$ 与 $2$ 互质，且 $\varphi(2) = 1$，所以根据 性质 1，可得 \begin{aligned} \varphi(2n)&=\varphi(2) \times \varphi(n)\\ &=1\times \varphi(n)\\ &=\varphi(n) \end{aligned}性质 4： 若 $p$ 为质数，$n = p^k$，则 \varphi(n)=p^k-p^{k-1}证明： 由 $n=p^k$，得 $n$ 的质因数只有 $p$，再通过公式，可知 \begin{aligned} \varphi(n)&=n\times\left(1-\frac{1}{p}\right)\\ &=p^k \times \left(1-\frac{1}{p}\right)\\ &= p^k - p^{k-1} \end{aligned}性质 5： 若 $n &gt; 2​$，则 $\varphi(n)​$ 为偶数。 若 $n &gt; 1$，则小于等于 $n$ 且与 $n$ 互质的数的和为 \frac{n \times \varphi(n)}{2}证明： 首先需要知道：若 $n$ 与 $m$ 互质 $(n &gt; m)$，则 $n$ 与 $n - m$ 互质。 \begin{aligned} &\gcd(n,m)=1\\ &\gcd(n,m)=\gcd(n,n-m)\\ \end{aligned}显然与 $n​$ 互质的数都是成对出现的，且相加的和为 $n​$，只有在 $\gcd(n,\frac{n}{2})=1​$ 时例外，但这种情况只会在 $n \leq 2​$ 时出现，所以 $\varphi(n)\ (n &gt; 2)​$ 为偶数得证。小于等于 $n​$ 的数中，与 $n​$ 互质的数的个数为 $\varphi(n)​$，所以一共有 $\frac{\varphi(n)}{2}​$ 对，总和为 $\frac{n \times \varphi(n)}{2}​$。 程序：如何求出 $\varphi(n)​$ ？ 根据欧拉函数的公式我们能够得到以下代码： 123456789inline int getPhi(int n) &#123; int res = n; for (int i = 2; i &lt;= n; ++i)//枚举因数 if (n % i == 0) &#123; res -= res / i; for (; n % i == 0; n /= i);//将质因数 i 除完 &#125; return res;&#125; 在最坏情况下（$n​$ 是质数），该代码的时间复杂度为 $O(n)​$，这显然不够优秀，考虑如何优化。 任何一个整数 $n$ 都不可能存在 $2$ 个大于 $\sqrt n$ 的质因子，所以我们枚举因数时只需要遍历到 $O(\sqrt n)$ 即可，如果将小于 $\sqrt n$ 的质因子除完后，剩下的数不为 $1$，说明还有 $1$ 个大于 $\sqrt n$ 的质因子，最后要算进去。这种做法的时间复杂度为 $O(\sqrt n)$ 。 优化后的代码如下： 12345678910inline int getPhi(int n) &#123; int res = n; for (int i = 2; i * i &lt;= n; ++i) if (n % i == 0) &#123; res -= res / i; for (; n % i == 0; n /= i); &#125; if (n &gt; 1) res -= res / n; return res;&#125; 如果需要求 $\varphi(1)\sim \varphi(n)$ 的值，用上述方法逐个求的时间复杂度为 $O(n\sqrt n)$，有没有更快的做法呢？ 莫比乌斯函数定义：莫比乌斯函数，属于 积性函数，但不是完全积性函数。常用 $\mu$ 表示，读作 miu 。 莫比乌斯函数的定义域是全体自然数 $n$ 。 若 $n = 1$，则 $\mu(1)=1$； 若 $n$ 存在大于 $1$ 的平方因子，则 $\mu(n)=0$（平方因子即 $4 , 9 , 25$ 等）； 若 $n$ 是偶数个互不相同的质数之积，则 $\mu(n)=1$； 若 $n$ 是奇数个互不相同的质数之积，则 $\mu(n)=-1$ 。 公式： \mu(n)=\left\{\begin{matrix} 1& n=1\\ (-1)^m& n=p_1\times p_2 \times \cdots \times p_m = \prod\limits_{i=1}^{m}p_i(\forall p_i \neq p_j)\\ 0& others\\ \end{matrix}\right.性质 &amp; 证明：性质 1： 若 $n , m$ 互质，则 $\mu(nm)=\mu(n) \times \mu(m)$ 。 证明： 积性函数特有性质。 性质 2： 若 $n \neq 1$，则 $n$ 所有因子的莫比乌斯函数值的和为 $0$，即 \sum\limits_{d\mid n}\mu(d)=\left\{\begin{matrix} 1& n=1\\ 0& n>1 \end{matrix}\right.证明： 除数函数定义：除数函数，属于 积性函数，但不是完全积性函数。常用 $\sigma$ 表示，读作 sigma 。 $\sigma_x(n)$ 定义为 $n$ 的正约数的 $x$ 次幂之和，即 \sigma_x(n)=\sum\limits_{d\mid n}d^x公式：若 $p_1 , p_2 ,\ldots, p_m$ 为 $x$ 的所有质因数，$n$ 和 $x$ 都是 自然数 。 \begin{aligned} \sigma_x(n) &= (1 + p_1^x+p_1^{2x}+\cdots+p_1^{a_1x})\\ &\times (1 + p_2^x+p_2^{2x}+\cdots+p_2^{a_2x})\\ &\times (1 + p_3^x+p_3^{2x}+\cdots+p_3^{a_3x})\\ &\times \cdots \cdots\\ &\times (1 + p_m^x+p_m^{2x}+\cdots+p_m^{a_mx})\\ &=\prod\limits_{i=1}^{m}\sum\limits_{j=0}^{a_i}p_i^{jx}\\ &=\prod\limits_{i=1}^{m}\frac{p_i^{(a_i+1)x}-1}{p_i^x-1}\\ \end{aligned}性质 &amp; 证明：性质 1： 特殊地，$\sigma_0(n)$ 可以表示 $n$ 的正约数个数，$\sigma_1(n)$ 可以表示 $n​$ 的正约数之和。 证明： 根据定义即能得到该结论。 性质 2： 若 $n , m​$ 互质，且 $x​$ 是自然数，则 $\sigma_x(nm)=\sigma_x(n) \times \sigma_x(m)​$ 。 证明： 积性函数特有性质。 完全积性函数]]></content>
      <tags>
        <tag>数论数学</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的质数相关定理]]></title>
    <url>%2F2019%2F04%2F04%2Fchang-yong-de-zhi-shu-xiang-guan-ding-li%2F</url>
    <content type="text"><![CDATA[许多与质数相关的定理都是数论的基础，想要学好数论，必须掌握这些定理并且能够熟练运用。 唯一分解定理（算数基本定理）任何一个大于 $1$ 的自然数都可以表示为有限个（包括 $1$ 个）质数的乘积。 \begin{aligned} n &= p_1^{a_1} \times p_2^{a_2} \times p_3^{a_3} \times \cdots \times p_m^{a_m}\\ &= \prod\limits_{i=1}^{m}p_i^{a_i}\\ \end{aligned}其中 $p_i (1 \leq i \leq m)$ 为质数，且都是 $n$ 的质因子。 当 $p_1 &lt; p_2 &lt; \cdot \cdot \cdot &lt; p_m$ 时，该式又称为 $n$ 的 标准分解式 。 约数个数定理若 $n = \prod\limits_{i=1}^{m}p_i^{a_i}$，则 $n$ 的约数个数可以表示为： \begin{aligned} \sigma_0(n) &= (a_1 + 1) \times (a_2+1) \times \cdots \times (a_m+1)\\ &=\prod\limits_{i=1}^{m}(a_i+1)\\ \end{aligned} $\sigma$ 是 除数函数 。具体内容请见 常见积性函数 - 除数函数 。 证明： 对于这个 $n​$，显然 $p_i^{a_i}(1 \leq i \leq m)​$ 的约数有： p_i^0,p_i^1,p_i^2,\ldots,p_i^{a_i}一共 $a_i+1$ 个。而 $n$ 的约数肯定是 $p_1^{a_1},p_2^{a_2},p_3^{a_3},\cdots,p_m^{a_m}$ 每一个数各选出一个约数的乘积。 根据 乘法原理，一共有 (a_1 + 1) \times (a_2+1) \times \cdots \times (a_m+1) =\prod\limits_{i=1}^{m}(a_i+1)种选法，即 $n​$ 的约数个数。 约数和定理若 $n = \prod\limits_{i=1}^{m}p_i^{a_i}$，则 $n$ 的所有正约数之和可以表示为： \begin{aligned} \sigma_1(n) &= (p_1^0 + p_1^1+p_1^2+\cdots+p_1^{a_1})\\ &\times (p_2^0 + p_2^1+p_2^2+\cdots+p_2^{a_2})\\ &\times (p_3^0 + p_3^1+p_3^2+\cdots+p_3^{a_3})\\ &\times \cdots \cdots\\ &\times (p_m^0 + p_m^1+p_m^2+\cdots+p_m^{a_m})\\ &= \prod\limits_{i=1}^{m}\sum\limits_{j=0}^{a_i}p_i^j\\ \end{aligned}其实 $\sum\limits_{j=0}^{a_i}p_i^j$ 是一个公比为 $p_i$ 的 等比数列 的和，因此该式子也能表示为： \sigma_1(n) = \prod\limits_{i=1}^{m}\frac{p_i^{a_i+1}-1}{p_i-1} $\sigma$ 是 除数函数 。具体内容请见 常见积性函数 - 除数函数 。 证明： 咕 威尔逊定理若 $p$ 为质数，则 (p-1)! \equiv -1\pmod p威尔逊定理的 逆定理 也成立，即： 对于某一个正整数 $p$，若 $(p-1)! \equiv -1\pmod p$，则 $p$ 一定是一个质数。 证明： 咕 二次探测定理若 $p​$ 是质数，$x​$ 是小于 $p​$ 的正整数，且 $x^2 \equiv 1\pmod p​$，则 x_1=1\ ,\ x_2=p-1证明： 根据同余式的性质，两边同时减去 $1$，得到 x^2 - 1 \equiv 0\pmod p左边显然可以用 平方差公式 因式分解，得到 (x+1)(x-1)\equiv 0\pmod p这个式子等价于 p\mid (x+1)(x-1)显然 $p$ 的因子来自 $x + 1$ 和 $x - 1$，但是因为 $p$ 是一个质数，所以 $p$ 的因子只有 $1$ 和 $p$，因此一定满足 $p\mid x+1$ 或 $p\mid x-1$ 。又因为 $0 &lt; x &lt; p$，所以 $x$ 的值为 $1$ 或 $p - 1$ 。 二次探测定理的 逆定理 也成立，即： $x​$ 是小于 $p​$ 的正整数，若 $x^2 \equiv 1\pmod p​$，且 $x\neq 1 , x\neq p-1​$，则这个 $p​$ 一定不是质数。 费马小定理若 $a​$ 为正整数，$p​$ 为质数，且 $a​$ 与 $p​$ 互质，则 a^{p-1}\equiv 1\pmod p证明： 咕 欧拉定理若 $a$ 和 $p$ 都是正整数，且 $a$ 与 $p$ 互质，则 a^{\varphi(p)} \equiv 1\pmod p $\varphi$ 是 欧拉函数 。具体内容请见 常见积性函数 - 欧拉函数 。 推论： 若正整数 $a$ 与 $p$ 互质，则对于任意正整数 $b$，有 a^b \equiv a^{b \mod\varphi(p)} \pmod p证明： 咕]]></content>
      <tags>
        <tag>数论数学</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ1607」「USACO2008 Dec」Patting Heads 轻拍牛头]]></title>
    <url>%2F2019%2F04%2F02%2FBZOJ1607%2F</url>
    <content type="text"><![CDATA[Descripion给定 $n\ (1 \leq n \leq 10^5)$ 个正整数 $a_i\ (1 \leq a_i \leq 10^6)$ 。对于每一个数 $a_i$，求有多少个数 $j\ (1 \leq j \leq n)$ 满足 $a_i \mid a_j$ 且 $i \neq j$ 。 Source[Luogu]P2926 [BZOJ]1607 Solution看完题目很容易想到 $O(n^2)​$ 的暴力算法，枚举所有 $i​$ 和 $j​$，显然会超时。但我们发现 $a_i​$ 并不大，所以考虑另一种方法。 我们用一个桶 $cnt​$ 记录 $a_i​$ 出现的次数，$ans_i​$ 表示 $a_i=i​$ 时的答案，枚举 $i=1 \sim \max \begin{Bmatrix}a_i\end{Bmatrix}​$ ，接着枚举 $i​$ 以及 $i​$ 的倍数，凡是等于 $i​$ 或是 $i​$ 的倍数的数，答案都应该加上 $i​$ 出现的次数。同时因为会把自己算进去，所以答案要减 $1​$ 。时间复杂度为 $O(n\log\log n)​$，类似 埃拉托斯特尼筛法 。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1, len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1e5, MAXM = 1e6;int n, maxn, a[MAXN + 5], cnt[MAXM + 5], ans[MAXM + 5];int main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); ++cnt[a[i]]; maxn = max(maxn, a[i]); &#125; for (int i = 1; i &lt;= maxn; ++i) &#123; if (!cnt[i]) continue;//小优化：判断 i 是否出现过 for (int j = i; j &lt;= maxn; j += i)//枚举 i 以及 i 的倍数 ans[j] += cnt[i];//如果 i | j，则让 ans[j] 增加 i 出现的次数 &#125; for (int i = 1; i &lt;= n; ++i) &#123; write(ans[a[i]] - 1);//因为 a[i] | a[i]，多算了一次自己，要减 1 putchar('\n'); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数论数学</tag>
        <tag>BZOJ</tag>
        <tag>Luogu</tag>
        <tag>题解</tag>
        <tag>USACO</tag>
        <tag>2008</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ2721」「Violet 5」樱花]]></title>
    <url>%2F2019%2F04%2F02%2FBZOJ2721%2F</url>
    <content type="text"><![CDATA[Descripion求不定方程 \frac{1}{x} + \frac{1}{y} = \frac{1}{n!}\ (1 \leq n \leq 10^6)正整数解 $(x, y) $ 的数目，答案对 $10^9+7$ 取模。 Source[BZOJ]2721 [Luogu]P1445 Solution题目所给的方程一看就知道不能直接做，必须化简。 我们先把等式左边通分，得到 \frac{x+y}{xy}=\frac{1}{n!}对角相乘，得到 xy=(x+y)n!移项 xy-(x+y)n!=0根据等式的性质，两边同时加上 $(n!)^2$，得到 xy-(x+y)n!+(n!)^2=(n!)^2这时我们发现等式左边可以因式分解了，式子变为 (x-n!)(y-n!)=(n!)^2即使到了这一步，还是看不出什么，我们考虑换元。假设 $a=x-n!$，$b=y-n!$，则能得到 ab=(n!)^2很显然 $n!​$ 是确定的，$a,b​$ 有多少不同的正整数解， $x,y​$ 就有多少不同的值能使等式成立，而 $a,b​$ 都是 $(n!)^2​$ 的因数，所以问题就变为求 $(n!)^2​$ 的因数个数。根据 唯一分解定理： n!=p_1^{a_1} \times p_2^{a_2} \times \cdot \cdot \cdot \times p_m^{a_m}其中 $m$ 表示 $n!$ 分解出的不同质数的个数，$p_i$ 表示 $n!$ 分解出的质数，$a_i$ 表示质因子 $p_i$ 的个数，那么 (n!)^2=p_1^{2a_1} \times p_2^{2a_2} \times \cdot \cdot \cdot \times p_m^{2a_m}$(n!)^2​$ 的因数个数就等于 $\prod\limits_{i=1}^{m}(2a_i+1)​$ 。 这个东西怎么求呢？ 我们先用 线性筛法（欧拉筛）求出 $1\sim n​$ 内的质数，并记录下每个数的最小质因子（线性筛中的合数只会被它的最小质因子筛去）。因为我们要求 $n!​$ 的质因数，所以枚举 $1 \sim n​$ 每一个数，依次分解它们，得到它们有哪些质因数。具体方法：每次除以它本身的最小质因子，直到这个数变成 $1​$ 为止。例如求 $18​$ 的因数：$18​$ 的最小质因子是 $2​$，就将 $a_2 +1​$，$18​$ 除以 $2​$ 变为 $9​$；再考虑 $9​$，$9​$ 的最小质因子是 $3​$，将 $a_3 +1​$，$9​$ 除以 $3​$ 变为 $3​$；$3​$ 的最小质因子是 $3​$，所以将 $a_3 + 1​$，$3​$ 除以 $3​$ 变为 $1​$，停止计算 。此时我们已经可以知道：$18=2^{a_2=1}\times 3^{a_3=2} ​$。按上述操作处理，就能算出 $n!​$ 的质因数分布，根据公式就能得到答案。同时因为最小的质数是 $2​$，每次除以它的最小质因子时，最大也会变为原来的 $\frac{1}{2}​$，所以时间复杂度为 $O(n\log n)​$ 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1, len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1e6;const LL MOD = 1e9 + 7;int n, cnt, a[MAXN + 5], prime[MAXN + 5], minPrime[MAXN + 5];//minPrime[i]表示 i 的最小质因子 LL ans = 1;inline void getPrime(int n) &#123; for (int i = 2; i &lt;= n; ++i) &#123; if (!minPrime[i]) &#123; minPrime[i] = i;//质数的最小质因子是它本身 prime[++cnt] = i; &#125; for (int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n; ++j) &#123; minPrime[i * prime[j]] = prime[j];//线性筛中的合数只会被最小质因子筛去 if (i % prime[j] == 0) break; &#125; &#125; &#125;int main() &#123; read(n); getPrime(n);//线性筛质数 for (int i = 1; i &lt;= n; ++i) for (int j = i; j &gt; 1; j /= minPrime[j]) ++a[minPrime[j]];//质因子计数 for (int i = 1; i &lt;= cnt; ++i) ans = ans * (LL) (a[prime[i]] &lt;&lt; 1 | 1) % MOD;//用公式求得答案 write(ans); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数论数学</tag>
        <tag>BZOJ</tag>
        <tag>Luogu</tag>
        <tag>题解</tag>
        <tag>筛法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 242E」XOR on Segment]]></title>
    <url>%2F2019%2F04%2F01%2FCF242E%2F</url>
    <content type="text"><![CDATA[Description给定 $n\ (1 \leq n \leq 10^5)$ 个数 $a_i\ (0 \leq a_i \leq 10^6)$，现在有 $m\ (1 \leq m \leq 5 \times 10^4)$ 个操作（操作有 $2$ 种）: $1 l r:$ 求 $\sum\limits_{i=l}^{r}a_i\ (1 \leq l \leq r \leq n)$； $2 l r x:$ 区间 $[l,r]\ (1 \leq l \leq r \leq n)$ 内的数对 $x\ (1 \leq x \leq 10^6)$ 异或。 Source[Luogu]CF242E [Codeforces]242E Solution因为是区间修改和区间查询，且异或具有结合律：$(a \oplus b) \oplus c = a \oplus (b \oplus c)​$，我们很容易想到用线段树来维护。可是似乎打不了懒标记，怎么办？先考虑 $a_i​$ 只有 $0​$ 和 $1​$ 两个值的情况，当对一条线段区间反转的时候，我们只需要让这条线段的懒标记异或 $1​$，这个区间 $1​$ 的个数变为 区间长度 - 原来区间 $1​$ 的个数。标记下放时，如果这条线段的懒标记为 $1​$，则将这条线段的左右区间反转（做上述反转操作），并清空这条线段的懒标记。 显然只有 $0​$ 和 $1​$ 时用线段树维护很简单，现在我们需要让这些数转化为 $0​$ 和 $1​$ 进行操作，这不就是把它们转化成 二进制 吗？相当于建了 $\log \max\begin{Bmatrix}a_i\end{Bmatrix}​$ 棵线段树，分别维护 $a_i​$ 在二进制下的每一位，以及每一位的区间和。对于即将异或的数 $x​$，先找到要修改的区间 $[l,r]​$，再把 $x​$ 二进制拆分，如果 $x​$ 在二进制下某一位是 $1​$，我们就对这一位所在的线段树区间 $[l,r]​$ 反转。查询时，同样先找到要查询的区间 $[l,r]​$，把二进制下每一位所在的 线段树区间 $[l,r]​$ 的和 × 二进制下这一位对应的值 加起来就是答案。因为每一次修改或查询都要在线段树内二进制拆分，所以时间复杂度为 $O(n\log^2n)​$ 。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1, len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1e5, MAX_LOG = 21;int n, m, a[MAXN + 5];struct SegmentTree &#123; LL lazy[MAXN &lt;&lt; 2 | 3], sum[MAX_LOG + 1][MAXN &lt;&lt; 2 | 3]; //sum[i][x]表示二进制下第 i 位第 x 条线段的和 inline int lson(int x) &#123; return x &lt;&lt; 1; &#125; inline int rson(int x) &#123; return x &lt;&lt; 1 | 1; &#125; inline void pushUp(LL x) &#123; for (int i = 0; i &lt;= MAX_LOG; ++i) sum[i][x] = sum[i][lson(x)] + sum[i][rson(x)];//维护二进制下每一位 &#125; void build(int *a, int x = 1, int l = 1, int r = n) &#123; if (l == r) &#123; for (register int i = 0; i &lt;= MAX_LOG; ++i) sum[i][x] = (a[l] &gt;&gt; i) &amp; 1;//二进制拆分 return; &#125; int mid = (l + r) &gt;&gt; 1; build(a, lson(x), l, mid), build(a, rson(x), mid + 1, r); pushUp(x); &#125; inline void modify(int x, int l, int r, LL p) &#123; lazy[x] ^= p;//异或满足结合律 (a ^ b) ^ c = a ^ (b ^ c) for (int i = 0; i &lt;= MAX_LOG; ++i) if ((p &gt;&gt; i) &amp; 1)//如果第 i 位为 1 sum[i][x] = r - l + 1 - sum[i][x];//区间内 1 的个数取反 &#125; inline void pushDown(int x, int l, int r) &#123; LL mid = (l + r) &gt;&gt; 1; modify(lson(x), l, mid, lazy[x]), modify(rson(x), mid + 1, r, lazy[x]); lazy[x] = 0; &#125; void update(int ql, int qr, LL p, int l = 1, int r = n, int x = 1) &#123; if (ql &lt;= l &amp;&amp; qr &gt;= r) &#123; modify(x, l, r, p); return; &#125; if (lazy[x]) pushDown(x, l, r); LL mid = (l + r) &gt;&gt; 1; if (ql &lt;= mid) update(ql, qr, p, l, mid, lson(x)); if (qr &gt; mid) update(ql, qr, p, mid + 1, r, rson(x)); pushUp(x); &#125; LL query(int ql, int qr, int l = 1, int r = n, int x = 1) &#123; if (ql &lt;= l &amp;&amp; qr &gt;= r) &#123; LL res = 0; for (int i = 0; i &lt;= MAX_LOG; ++i) res += sum[i][x] &lt;&lt; i;//二进制下第 i 位对应 2 的 i 次方，累加 return res; &#125; if (lazy[x]) pushDown(x, l, r); LL res = 0, mid = (l + r) &gt;&gt; 1; if (ql &lt;= mid) res += query(ql, qr, l, mid, lson(x)); if (qr &gt; mid) res += query(ql, qr, mid + 1, r, rson(x)); return res; &#125;&#125; tr;int main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) read(a[i]); tr.build(a); read(m); for (int i = 1; i &lt;= m; ++i) &#123; int opt, l, r; LL x; read(opt); if (opt == 1) &#123; read(l), read(r); write(tr.query(l, r)); putchar('\n'); &#125; else &#123; read(l), read(r), read(x); tr.update(l, r, x); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>题解</tag>
        <tag>线段树</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AtCoder AGC012-D」Colorful Balls]]></title>
    <url>%2F2019%2F04%2F01%2FAT2364%2F</url>
    <content type="text"><![CDATA[Description现在有 $N\ (1 \leq N \leq 2 \times 10^5)$ 个球，第 $i$ 个球的颜色为 $c_i\ (1 \leq c_i \leq N)$，重量为 $w_i\ (1 \leq w_i \leq 10^9)$ 。你可以交换球 $i$ 和球 $j$ 的位置，当且仅当 $c_i$ 与 $c_j$ 相等，$w_i+w_j \leq X\ (1\leq X \leq 10^9)$，或者 $c_i$ 与 $c_j$ 不等，$w_i+w_j \leq Y\ (1\leq Y \leq 10^9)$，求可能产生多少种不同的颜色序列。答案对 $10^9+7$ 取模。 Source[Luogu]AT2364 [AtCoder]AGC012-D Solution首先可以发现一个性质：如果球 $i$ 可以和球 $j$ 换，球 $j$ 可以和球 $k$ 换，那球 $i$ 也可以和球 $k$ 换。原因很简单，假设原来排列是 $i j k$，可以先换 $i, j$ 得到 $j i k$，再换 $j, k$ 得到 $k i j$，最后交换 $i, j$ 就能得到 $k j i$，即交换了 $i, k$ 。通过这个性质，我们还能够发现 $i j k$ 的所有排列都可以通过交换得到，也就是说，$i j k ; i k j ; j i k ; j k i ; k i j ; k j i$ 都能够得到。这个规律可以推广到 $n$ 个球。 很容易想到建一个无向图来表示能否交换。如果球 $a​$ 和球 $b​$ 能够交换，我们就在 $a, b​$ 之间连一条无向边，在同一个连通块内的球都可以互相交换，根据乘法原理，最后的答案就是每个连通块内颜色序列数的乘积。每个连通块的答案怎么算呢？因为球的颜色可能是相同的，所以我们要求 有重复元素的排列个数 。这里给出计算公式： 如果在 $n​$ 个元素中，有 $n_1​$ 个元素彼此相同，$n_2​$ 个元素彼此相同，……，$n_m​$ 个元素彼此相同，且 $\sum\limits_{i=1}^{m}n_i=n​$，则这 $n​$ 个元素的不重复排列个数为： \frac{n!}{\prod\limits_{i=1}^{m}(n_i!)}对于这道题来说，一共有 $n​$ 种颜色（题目已知），假设某个连通块的大小为 $size​$，颜色为 $i​$ 的球的个数为 $col_i​$，则该连通块的答案为： \frac{size!}{\prod\limits_{i=1}^{n}(col_i!)}我们用并查集可以很好地维护与连通块有关的问题，考虑每一个球能否与 $1\sim n​$ 除自己外的其它球交换，如果可以，就把它们合并到一个连通块里。预处理 $1\sim n​$ 的阶乘与阶乘的逆元，分别计算出每一个连通块的答案，求它们的乘积即能得到结果，时间复杂度为 $O(n^2)​$，而 $n\leq 2 \times 10^5​$，这显然是会超时的，所以我们考虑如何优化能够尽量缩减图的边数但又不影响图的连通性。 Code12]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉查找树(BST)简介]]></title>
    <url>%2F2019%2F03%2F21%2Fer-cha-cha-zhao-shu-bst-jian-jie%2F</url>
    <content type="text"><![CDATA[介绍二叉查找树(Binary Search Tree) 又称 二叉排序树(Binary Sort Tree) ，亦称 二叉搜索树，简写为 BST 。 二叉查找树具有以下性质： 如果左子树非空，那么左子树上的所有节点的值均小于等于根节点的值。 如果右子树非空，那么右子树上的所有节点的值均大于等于根节点的值。 二叉查找树的 左子树 与 右子树 也分别为二叉查找树。 通俗地讲：二叉查找树上点的权值，左儿子 &lt; 根节点 &lt; 右儿子 。 根据这个性质，我们很容易发现二叉查找树的中序遍历是一个单调不减的序列。 那么，二叉查找树有什么作用呢？ 对于一个长度为 $8​$ 的序列： $1, 15, 5, 3, 8, 10, 9, 12, 10​$，该如何找到这个序列第 $k​$ 大的数，并且支持插入与删除元素呢？如果我们将其排序再进行查询，时间复杂度为 $O(n \log n)​$，这显然不够优秀。因此我们考虑构造出一棵二叉查找树，如图。 插入假设我们要向上述序列插入一个数 $11​$，我们从根节点开始。 我们发现 $11 &gt; 9$，因此我们把 $11$ 放到 $9$ 的右儿子。 此时 $12$ 比 $11$ 大了，为了保持二叉搜索树的性质，我们把 $11$ 放到 $12​$ 的左儿子。 $11 &gt; 10$，本来应该让 $11$ 和 $10$ 的右儿子继续比较，可是 $10$ 没有右儿子，因此我们把 $11$ 插入到该位置。 小结：插入一个数时，从根节点开始，依次比较要插入的数和当前节点的值，如果大于当前节点，就放到该结点的右儿子，如果小于当前节点，就放到该结点的左儿子，重复上述操作，直到下放的位置没有结点。如果中途碰到与某个节点相等，我们再定义一个 $cnt$ 数组，表示当前节点值的个数，并且加上 $1$ 。这样我们就完成了一个数的插入过程。 删除类似插入的过程，还是依次比较要删除的数和当前节点的值，不断下放，当找到目标节点时，并不需要把该节点整个删掉，只需要给该节点值的个数减 $1$ 。对于节点 $x$，如果 $cnt[x] = 0$， 则表示当前位置没有节点。当一个位置没有节点时，这棵树依旧满足二叉查找树的性质。 查询前驱$x$ 的前驱定义为小于 $x$ 的最大的数。那么如何找 $x​$ 的前驱呢？ 这里以 $6$ 为例，从根节点开始。 从前驱的定义可知，$6$ 的前驱一定比 $6$ 小。而 $9 &gt; 6$，所以把 $6$ 放在 $9$ 的左儿子。 $8$ 还是比 $6$ 大，因此我们把 $6$ 放到 $8$ 的左儿子。 我们发现 $3 &lt; 6$，但是并不知道 $3$ 是不是小于 $6$ 的数中最大的，我们还要去找比 $3$ 大的数，因为这些数也有可能成为答案。所以记录当前答案为 $3$，把 $6$ 放在 $3$ 的右儿子。 $5$ 还是比 $6$ 小，更新当前答案为 $5$，而 $5$ 没有右儿子，所以最后答案 （$6$ 的前驱）就是 $5$ 。 小结：寻找 $x$ 的前驱时，从根节点开始，依次比较 $x$ 和当前节点的值。如果当前节点的值大于 $x$，则往该节点的左儿子找，直到出现小于 $x$ 的节点。此时我们记录当前答案为这个节点的值，往这个节点的右儿子找，如果途中遇到的节点的值小于 $x$，就更新当前答案，否则结束查询，当前答案就是 $x$ 的前驱。 后继$x​$ 的后继定义为大于 $x​$ 的最小的数。 与前驱的操作恰恰相反，依次比较 $x​$ 和当前节点的值。如果当前节点的值小于 $x​$，则往该节点的右儿子找，直到出现大于 $x​$ 的节点。此时我们记录当前答案为这个节点的值，往这个节点的左儿子找，如果途中遇到的节点的值大于 $x​$，就更新当前答案，否则结束查询，当前答案就是 $x​$ 的后继。 已知排名求值排名定义为比当前数小的数的个数 $+1​$，现在需要寻找排名为 $x​$ 的数。 我们新定义一个数组 $size$，对于一个节点 $x$，$size[x]$ 表示 $x$ 以及它的子树大小之和，需要递归预处理出每个节点的 $size$，当然，插入与删除操作时也要更新 $size$ 数组。假设我们要寻找排名为 $7$ 的数是多少，从根节点开始，如图（红色的数字即为节点的 $size$）。 $9​$ 的左儿子的 $size​$ 为 $4​$，所以 $9​$ 的排名为 $5​$，而要寻找的数的排名为 $7​$，所以该数一定比 $9​$ 大，因此我们到 $9​$ 的右子树找。 此时到了一棵新的子树上，因为排名为 $5$ 以及 $5$ 之前的节点都不要了，所以我们需要在该子树上找排名为 $2$ 的数。$12$ 的左儿子的 $size$ 为 $2$，因此 $12$ 在该子树上的排名为 $3$，排名为 $2$ 的数一定比 $12$ 小，应该到 $12$ 的左子树找。 现在所在的子树又少了 $2$ 个节点，但这 $2$ 个节点的排名都比 $2$ 大，所以仍然在新子树中找排名为 $2$ 的数。因为 $10$ 没有左儿子（即 $size$ 为 $0$），所以 $10$ 的排名为 $1$，而要查询的数排名为 $2$，大于 $10$，应该到 $10$ 的右子树找。 排名为 $1​$ 的节点已经不要了，因此要在新子树中找排名为 $1​$ 的节点。而 $11​$ 没有左儿子（即 $size​$ 为 $0​$），所以 $11​$ 的排名为 $1​$ 。最后的答案就是 $11​$ 。 小结：已知排名求值时，先预处理出每个节点的子树大小 $size$，从根节点开始，依次检查每个节点的排名，每个节点 $x$ 的排名为它 左儿子的 $size$ 加上 $cnt[x]$ (该节点值的数量) 。如果该节点的排名比要查询的排名小，则在该节点的右子树中查询 当前要查询的排名 - 该节点排名 的数。如果该节点排名更大，就在左子树中继续查询这个排名的数。如果排名相等，则该节点的值就是答案。 已知值求排名与已知排名求值的过程相似，以查询 $11$ 的排名为例，从根节点开始，初始没有数比 $11$ 小，所以 $11$ 的排名为 $1​$ 。 $9​$ 的排名为它左儿子的 $size​$ 加上它的 $cnt​$，也就是 $5​$，显然 $9 &lt; 11​$，所以 $11​$ 的排名变为 $1 + 5 = 6​$，并且往 $9​$ 的右子树找。 因为 $12 &gt; 11$，没有数比 $11$ 小，所以往 $12$ 的左子树找。 $10$ 比 $11$ 小，因为 $10$ 没有左儿子（左儿子 $size$ 为 $0$），所以 $10$ 在该子树中的排名为 $1$ 。$11$ 的排名更新为 $6 + 1 = 7$，并往 $10$ 的右子树找。 与目标节点重合，停止查询，$7$ 即为 $11$ 的排名。 小结：已知值求排名时，初始化已知值的排名为 $1$ 。从根节点开始，依次检查每个节点的值，如果该节点的值比已知值小，则排名更新为 它当前的排名 加上 该节点的排名，每个节点 $x$ 的排名为它 左儿子的 $size$ 加上 $cnt[x]$ (该节点值的数量) ，往该节点的右子树走。如果该节点的值比已知值大，则往该节点的左子树走。如果与已知值相等，则停止查询，当前排名就是这个值最终的排名。 总结普通的二叉查找树在数据随机的情况下所有操作的时间复杂度都是 $O(\log n)$ 的，但是在最劣情况下会变成一条链，时间复杂度为 $O(n)$，因此我们需要旋转，分裂等操作来维护二叉查找树，使其时间复杂度稳定为 $O(\log n)$，这种二叉查找树称作平衡二叉树，简称平衡树。平衡树的常见实现方法有 Treap , Splay , AVL , 替罪羊树 , 红黑树 等，这里不作介绍。]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伸展树(Splay)小结]]></title>
    <url>%2F2019%2F03%2F21%2Fshen-zhan-shu-splay-xiao-jie%2F</url>
    <content type="text"><![CDATA[前置知识二叉查找树(BST) 线段树 简介伸展树(Splay Tree) 是平衡二叉树的一种，也属于二叉查找树，使用旋转保持平衡。它能在 $O(\log n)​$ 内完成插入、删除和查询操作，还具有很强的区间操作能力，所以也能作为 LCT 的辅助树，可以说是一种万能的平衡树。 原理咕咕咕]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>平衡树</tag>
        <tag>Splay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SPOJ2713」GSS4 - Can you answer these queries Ⅳ]]></title>
    <url>%2F2019%2F03%2F13%2FSPOJ2713%2F</url>
    <content type="text"><![CDATA[Description给定 $n\ (n \leq 10^5)​$ 个数，已知 $\sum\limits_{i=1}^{n}a_i \leq 10^{18}​$。 $m\ (m \leq 10^5)$ 个操作（操作有 $2$ 种）： 0 x y：将区间 $[x,y]\ (1 \leq x,y \leq n)$ 内的每一个数开 平方根（下取整） 。 1 x y：询问区间 $[x,y]\ (1 \leq x,y \leq n)$ 所有数的和（不保证 $x \leq y$，若 $x &gt; y$，则交换 $x,y$）。 Source[Luogu]SP2713 [Luogu]P4145 [BZOJ]3211 [SPOJ]GSS4 Solution因为要维护区间和，所以我们想到用线段树来维护。 但是会发现懒惰标记不能打，那该怎么办呢？ 考虑暴力修改： $a[i]$ 最大为 $10^{18}$。 \left \lfloor \sqrt{\sqrt{\sqrt{\sqrt{\sqrt{\sqrt{10^{18}}}}}}}\right \rfloor = 1换言之， \left \lfloor \sqrt[2^6]{10^{18}}\right \rfloor = 1一个数最多开 $6$ 次平方根就会变成 $1$ 。 因为 $\sqrt{1} = 1,\sqrt{0} = 0$， 我们只需要维护 区间和 与 区间最大值 即可， 当一个区间的最大值 $\leq 1$ 时，我们对这个区间的修改就是无用的，因为无论怎么修改这个数仍是它本身。 而我们对一个数的开平方操作不会超过 $6$ 次，所以时间复杂度仍是 $O(n \log n)$ 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1, len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1e5 + 10;struct SegmentTree &#123; LL sum[MAXN &lt;&lt; 2], maxx[MAXN &lt;&lt; 2]; inline int lson(int x) &#123; return x &lt;&lt; 1; &#125; inline int rson(int x) &#123; return x &lt;&lt; 1 | 1; &#125; inline void pushUp(int x) &#123; sum[x] = sum[lson(x)] + sum[rson(x)]; maxx[x] = max(maxx[lson(x)], maxx[rson(x)]); &#125; void build(int x, int l, int r, LL *a) &#123; if (l == r) &#123; sum[x] = a[l]; maxx[x] = a[l]; return; &#125; int mid = (l + r) &gt;&gt; 1; build(lson(x), l, mid, a), build(rson(x), mid + 1, r, a); pushUp(x); &#125; void update(int ql, int qr, int l, int r, int x) &#123; if (maxx[x] &lt;= 1) return;//如果区间最大值小于等于1，就可以直接忽略这个区间的修改操作 if (l == r) &#123; sum[x] = sqrt(sum[x]); maxx[x] = sqrt(maxx[x]); return; &#125; int mid = (l + r) &gt;&gt; 1; if (ql &lt;= mid) update(ql, qr, l, mid, lson(x)); if (qr &gt; mid) update(ql, qr, mid + 1, r, rson(x)); pushUp(x); &#125; LL query(int ql, int qr, int l, int r, int x) &#123; if (ql &lt;= l &amp;&amp; qr &gt;= r) return sum[x]; int mid = (l + r) &gt;&gt; 1; LL res = 0; if (ql &lt;= mid) res += query(ql, qr, l, mid, lson(x)); if (qr &gt; mid) res += query(ql, qr, mid + 1, r, rson(x)); return res; &#125;&#125; tr;int n, m;LL a[MAXN];int main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) read(a[i]); tr.build(1, 1, n, a); read(m); for (int opt, l, r, i = 1; i &lt;= m; ++i) &#123; read(opt), read(l), read(r); if (l &gt; r) swap(l, r); if (opt == 1) &#123; write(tr.query(l, r, 1, n, 1)); putchar('\n'); &#125; else tr.update(l, r, 1, n, 1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>Luogu</tag>
        <tag>题解</tag>
        <tag>线段树</tag>
        <tag>SPOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SPOJ1716」GSS3 - Can you answer these queries Ⅲ]]></title>
    <url>%2F2019%2F03%2F13%2FSPOJ1716%2F</url>
    <content type="text"><![CDATA[Description给定一个长度为 $n\ (n \leq 50000, \mid a_i \mid \leq 10000)​$ 的整数序列 和 $m\ (m \leq 50000)​$ 个操作（操作有 $2​$ 种）： 0 x y：把 $a_x\ (1 \leq x \leq n)​$ 的值修改为 $y\ (\mid y \mid \leq 10000)​$。 1 x y： 询问区间 $[x,y]\ (1 \leq x \leq y \leq n)$ 的最大子段和。 Source[Luogu]SP1716 [SPOJ]GSS3 Solution仅仅是比 「SPOJ1043」GSS1 多了一个单点修改操作，暴力修改并且加上 $\mathrm{pushUp}$ 操作即可。 $\mathrm{pushUp}$ 操作 和 $\mathrm{query}​$ 操作 的详细实现过程请看上一行链接。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1, len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 5e4 + 10;struct SegmentTree &#123; struct Node &#123; LL sum, lsum, rsum, res; &#125; seg[MAXN &lt;&lt; 2]; inline int lson(int x) &#123; return x &lt;&lt; 1; &#125; inline int rson(int x) &#123; return x &lt;&lt; 1 | 1; &#125; inline void pushUp(int x) &#123; seg[x].sum = seg[lson(x)].sum + seg[rson(x)].sum; seg[x].res = max(max(seg[lson(x)].res, seg[rson(x)].res), seg[lson(x)].rsum + seg[rson(x)].lsum); seg[x].lsum = max(seg[lson(x)].lsum, seg[lson(x)].sum + seg[rson(x)].lsum); seg[x].rsum = max(seg[rson(x)].rsum, seg[lson(x)].rsum + seg[rson(x)].sum); &#125; void build(int x, int l, int r, LL *a) &#123; if (l == r) &#123; seg[x] = (Node) &#123; a[l], a[l], a[l], a[l] &#125;; return; &#125; int mid = (l + r) &gt;&gt; 1; build(lson(x), l, mid, a), build(rson(x), mid + 1, r, a); pushUp(x); &#125; void update(int q, int l, int r, int x, LL p) &#123; if (l == r) &#123; seg[x] = (Node) &#123; p, p, p, p &#125;; return; &#125; int mid = (l + r) &gt;&gt; 1; if (q &lt;= mid) update(q, l, mid, lson(x), p); else update(q, mid + 1, r, rson(x), p); pushUp(x); &#125; Node query(int ql, int qr, int l, int r, int x) &#123; if (ql &lt;= l &amp;&amp; qr &gt;= r) return seg[x]; int mid = (l + r) &gt;&gt; 1; if (qr &lt;= mid) return query(ql, qr, l, mid, lson(x)); if (ql &gt; mid) return query(ql, qr, mid + 1, r, rson(x)); Node ans, lx = query(ql, qr, l, mid, lson(x)), ly = query(ql, qr, mid + 1, r, rson(x)); ans.sum = lx.sum + ly.sum; ans.res = max(max(lx.res, ly.res), lx.rsum + ly.lsum); ans.lsum = max(lx.lsum, lx.sum + ly.lsum); ans.rsum = max(ly.rsum, lx.rsum + ly.sum); return ans; &#125;&#125; tr;int n, q, l, r;bool opt;LL a[MAXN];int main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) read(a[i]); tr.build(1, 1, n, a); for (read(q); q; --q) &#123; read(opt), read(l), read(r); if (!opt) tr.update(l, 1, n, 1, r); else &#123; write(tr.query(l, r, 1, n, 1).res); putchar('\n'); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>题解</tag>
        <tag>线段树</tag>
        <tag>SPOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SPOJ1043」GSS1 - Can you answer these queries Ⅰ]]></title>
    <url>%2F2019%2F03%2F12%2FSPOJ1043%2F</url>
    <content type="text"><![CDATA[Description给定一个长度为 $n\ (n \leq 50000, \mid a_i \mid \leq 15007)$ 的整数序列，对于 $m\ (m \leq 50000)$ 个询问 $l,r\ (1 \leq l \leq r \leq n)$，求区间 $[l,r]$ 的最大子段和。 Source[Luogu]SP1043 [SPOJ]GSS1 Solution如果用朴素的最大子段和算法，时间复杂度为 $O(nm)$，一定会超时。 很容易想到用数据结构来维护。 我们建立一棵线段树，对于区间 $x$，有以下定义： $sum[x]$ 表示区间和； $lsum[x]$ 表示以该区间左端点为起点的最大子段和； $rsum[x]$ 表示以该区间右端点为起点的最大子段和； $res[x]$ 表示该区间内的最大子段和。 与普通的线段树不同，这道题维护的信息很多，我们先来分析该题最重要的 $\mathrm{pushUp}$ 与 $\mathrm{query}$ 操作。 $\mathrm{pushUp}$ 操作首先，是维护区间和，最基本的线段树操作，就不用多说了： sum[x] = sum[lson(x)] + sum[rson(x)]其次，假如我们知道一个区间的左右子区间信息，如何更新该区间的最大子段和？ 很显然，答案可能为 左区间的最大子段和 或 右区间的最大子段和 。 除此之外，合并区间后，答案也有可能为 左区间的右起最大子段和 + 右区间的左起最大子段和，如上图。 由此我们可以得到代码： res[x]=\max\begin{Bmatrix}res[lson(x)],res[rson(x)],rsum[lson(x)]+lsum[rson(x)]\end{Bmatrix}那如何更新该区间的 左起最大子段和 和 右起最大子段和 呢？ 区间左起最大子段和可以是 左区间的左起最大子段和 或 左区间的区间和 + 右区间的左起最大子段和，如上图。 右起最大子段和将上述操作反过来即可。 代码实现如下： lsum[x]=\max(lsum[lson],sum[lson]+lsum[rson])rsum[x]=\max(rsum[rson],rsum[lson]+sum[rsum])$\mathrm{query}$ 操作 当答案来自两个不同的区间时（如图），我们需要对这两个区间答案进行合并，并不只是取最大值那样简单。 我们还需要进行类似 $\mathrm{pushUp}$ 的操作，已知左右区间的答案，更新该区间答案。 函数的返回值有很多，所以用结构体式线段树实现更方便。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1, len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 5e4 + 10;struct SegmentTree &#123; struct Node &#123; LL sum, lsum, rsum, res; &#125; seg[MAXN &lt;&lt; 2]; inline int lson(int x) &#123; return x &lt;&lt; 1; &#125; inline int rson(int x) &#123; return x &lt;&lt; 1 | 1; &#125; inline void pushUp(int x) &#123; seg[x].sum = seg[lson(x)].sum + seg[rson(x)].sum; seg[x].res = max(max(seg[lson(x)].res, seg[rson(x)].res), seg[lson(x)].rsum + seg[rson(x)].lsum); seg[x].lsum = max(seg[lson(x)].lsum, seg[lson(x)].sum + seg[rson(x)].lsum); seg[x].rsum = max(seg[rson(x)].rsum, seg[lson(x)].rsum + seg[rson(x)].sum); &#125; void build(int x, int l, int r, LL *a) &#123; if (l == r) &#123; seg[x] = (Node) &#123; a[l], a[l], a[l], a[l] &#125;; return; &#125; int mid = (l + r) &gt;&gt; 1; build(lson(x), l, mid, a), build(rson(x), mid + 1, r, a); pushUp(x); &#125; Node query(int ql, int qr, int l, int r, int x) &#123;//分成3种情况考虑 if (ql &lt;= l &amp;&amp; qr &gt;= r) return seg[x]; int mid = (l + r) &gt;&gt; 1; if (qr &lt;= mid) return query(ql, qr, l, mid, lson(x)); if (ql &gt; mid) return query(ql, qr, mid + 1, r, rson(x)); Node ans, lx = query(ql, qr, l, mid, lson(x)), ly = query(ql, qr, mid + 1, r, rson(x)); ans.sum = lx.sum + ly.sum; ans.res = max(max(lx.res, ly.res), lx.rsum + ly.lsum); ans.lsum = max(lx.lsum, lx.sum + ly.lsum); ans.rsum = max(ly.rsum, lx.rsum + ly.sum); return ans; &#125;&#125; tr;int n, q, l, r;LL a[MAXN];int main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) read(a[i]); tr.build(1, 1, n, a); for (read(q); q; --q) &#123; read(l), read(r); write(tr.query(l, r, 1, n, 1).res); putchar('\n'); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>题解</tag>
        <tag>线段树</tag>
        <tag>SPOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ1303」「CQOI2009」中位数图]]></title>
    <url>%2F2019%2F03%2F12%2FBZOJ1303%2F</url>
    <content type="text"><![CDATA[Description给定长度为 $n\ (n \leq 10^5)$ 的排列，求有多少包含 $b\ (1 \leq b \leq n)$ 的奇数长度的序列中位数为 $b$ 。 Source[Luogu]P1627 [BZOJ]1303 Solution因为所求的是中位数，所以考虑改变原序列。把大于 $b$ 的数全部变为 $1$，小于 $b$ 的数变为 $-1$，等于 $b$ 则为 $0$ 。问题就变为求存在几个包含 $b$ 的区间和为 $0$ 。我们假设 $tmp$ 为 $b$ 的下标，原数组为 $x$，新数组为 $a​$ 。 Sample Input127 45 7 2 4 3 1 6 Sample Output14 Example 对于样例，能使结果成立的 $4$ 个区间分别为 $[1,5]$，$[1,7]$，$[2,4]$，$[4,4]$ 。 接下来我们建造两个桶，分别计数 $tmp​$ 左边的后缀和与右边的前缀和，假设左边的后缀和为 $l​$，右边的前缀和为 $r​$ 。$l[i]/r[i]​$ 表示从点 $i​$ 向右/向左 到点 $tmp​$ 为止 (比 $b​$ 大的数的数量 - 比 $b​$ 小的数的数量) 出现的次数。还是拿样例来说： 通过观察上图，我们能够发现，左边的数 $x​$ 可以与右边的每一个 $-x​$ 进行匹配。通过乘法原理，该值即为 $l[x] \times r[-x]​$，由题意可知 $-10^5 \le x \le 10^5​$，遍历所有的 $x​$ 即可，最终答案为： \sum\limits_{i=\min{x}}^{\max{x}}l[i] \times r[-i]值得注意的是，$l[0]$ 和 $r[0]$ 的初始值为 $1$，因为 $b$ 是需要被算入的。当然，桶的下标不能是负数，所以我在每次操作时都加上了一个很大的数，比如数据最大值 —— $10^5$，也可以用 $\mathrm{STL}$ 中的 $map$ 解决问题，时间复杂度为 $O(n)$ 。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1, len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;const int MAXN = 1e5;int n, b, tmp, sum, a[MAXN + 10], l[MAXN &lt;&lt; 1 | 1], r[MAXN &lt;&lt; 1 | 1];LL ans;int main() &#123; read(n), read(b); for (int x, i = 1; i &lt;= n; ++i) &#123; read(x); if (x == b) tmp = i; else a[i] = x &gt; b ? 1 : -1; &#125; ++l[MAXN], ++r[MAXN]; for (int i = tmp - 1; i &gt;= 1; --i) &#123; sum += a[i]; ++l[sum + MAXN]; &#125;//后缀和 sum = 0; for (int i = tmp + 1; i &lt;= n; ++i) &#123; sum += a[i]; ++r[sum + MAXN]; &#125;//前缀和 for (int i = -MAXN; i &lt;= MAXN; ++i) ans += (LL) l[i + MAXN] * (LL) r[-i + MAXN];//公式计算答案 write(ans); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数论数学</tag>
        <tag>BZOJ</tag>
        <tag>Luogu</tag>
        <tag>CQOI</tag>
        <tag>2009</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用距离算法详解]]></title>
    <url>%2F2019%2F03%2F11%2Fchang-yong-ju-li-suan-fa-xiang-jie%2F</url>
    <content type="text"><![CDATA[在计算距离时，我们一般都是求两点之间的直线距离，实际上距离算法并不只这一种，还有其他的距离算法在 $\mathrm{OI}$ 中也同样很重要。不同的距离算法都有明显的优缺点。本文主要讲解 三种 常见的距离算法，分别是 欧氏距离，曼哈顿距离，切比雪夫距离 。 一、欧氏距离（欧几里得度量）欧氏距离，是一个通常采用的距离定义，指在 $m​$ 维空间中两个点之间的真实距离，或者向量的自然长度（即该点到原点的距离）。在二维和三维空间中的欧氏距离就是两点之间的实际距离。—— 来源：百度百科 欧氏距离 是最易于理解的一种距离算法。在数学的平面直角坐标系中，设点 $A,B$ 的坐标分别为 $A(x_1,y_1),B(x_2,y_2)$，求点 $A,B$ 之间的距离，我们一般会使用如下公式： \mid AB \mid = \sqrt{\left ( x_2 - x_1 \right )^2 + \left ( y_2 - y_1 \right )^2}实际上这就是平面（二维空间）中两点欧氏距离的距离公式，除此之外，$P(x,y)$ 到原点的欧氏距离可以用公式表示为： \mid P\mid = \sqrt{x^2+y^2}举个栗子，在下图中 $A,B​$ 的坐标分别为 $A(6,5),B(2,2)​$。 通过公式，我们很容易得到 $A,B​$ 两点间的欧氏距离： \mid AB \mid = \sqrt{\left ( 2 - 6 \right )^2 + \left ( 2 - 5 \right )^2} = \sqrt{4^2+3^2} = 5那么，三维空间 中两点的欧氏距离公式呢？我们来观察下图。 我们很容易发现，在$\triangle ADC$中，$\angle ADC = 90^\circ$；在$\triangle ACB$中，$\angle ACB = 90^\circ$ 。 \begin{aligned} \therefore \mid AB\mid &=\sqrt{\mid AC\mid ^2+\mid BC\mid ^2}\\ &=\sqrt{\mid AD\mid ^2+\mid CD\mid ^2+\mid BC\mid ^2}\\ \end{aligned}由此可得，三维空间 中欧氏距离的距离公式为： \mid AB \mid = \sqrt{\left ( x_2 - x_1 \right )^2 + \left ( y_2 - y_1 \right )^2 + \left ( z_2 - z_1 \right )^2} \mid P\mid = \sqrt{x^2+y^2+z^2}例题：[Luogu]P3958 以此类推，我们就得到了 $n$ 维空间 中欧氏距离的距离公式： \begin{aligned} d(x,y) &= \sqrt{\left ( x_1 - y_1 \right )^2 + \left ( x_2 - y_2 \right )^2 + \cdots +\left ( x_n - y_n \right )^2}\\ &= \sqrt{\sum\limits_{i = 1}^{n}(x_i - y_i)^2}\\ \end{aligned}欧氏距离虽然很有用，但也有明显的缺点。两个整点计算其欧氏距离时，往往答案是浮点型，会存在一定误差。 二、曼哈顿距离曼哈顿距离 是种使用在几何度量空间的几何学用语，用以标明两个点在标准坐标系上的绝对轴距总和。曼哈顿距离不是距离不变量，当坐标轴变动时，点间的距离就会不同。—— 来源：百度百科 在 二维空间 内，两个点之间的曼哈顿距离为它们横坐标之差的绝对值与纵坐标之差的绝对值之和。设点 $A(x_1,y_1),B(x_2,y_2)$，则 $A,B$ 之间的曼哈顿距离用公式可以表示为： d(A,B) = \mid x_1 - x_2\mid + \mid y_1 - y_2\mid观察下图： 在 $A,B​$ 间，$\color{yellow}{黄线}​$，$\color{orange}{橙线}​$ 都表示曼哈顿距离，而$\color{red}{红线}​$，$\color{blue}{蓝线}​$表示 等价 的曼哈顿距离，$\color{green}{绿线}​$表示欧氏距离。 同样的栗子，在下图中 $A,B?$ 的坐标分别为 $A(6,5),B(2,2)$ 。 通过公式，我们很容易得到 $A,B$ 两点间的曼哈顿距离： d(A,B) = \mid 6 - 2\mid + \mid 5 - 2\mid = 4 + 3 = 7经过推导，我们得到 $n$ 维空间 的曼哈顿距离公式为： \begin{aligned} d(A,B) &= \mid x_1 - y_1\mid + \mid x_2 - y_2\mid + \cdot \cdot \cdot + \mid x_n - y_n\mid \\ &=\sum\limits_{i = 1}^{n}\mid x_i - y_i\mid \\ \end{aligned}除了公式之外，曼哈顿距离还具有以下 数学性质： 非负性 曼哈顿距离是一个非负数。 $d(i,j)\geq 0$ 统一性 点到自身的曼哈顿距离为 $0$。 $d(i,i) = 0$ 对称性 $A$ 到 $B$ 与 $B$ 到 $A$ 的曼哈顿距离相等，且是对称函数。 $d(i,j) = d(j,i)$ 三角不等式 从点 $i$ 到 $j$ 的直接距离不会大于途经的任何其它点 $k$ 的距离。 $d(i,j)\leq d(i,k)+d(k,j)$ 例题：[Luogu]P5098 解析： （不要被难度吓住，是假的） 根据题意，对于式子 $\mid x_1-x_2\mid +\mid y_1-y_2\mid $，我们可以假设 $x_1 - x_2 \geq 0$，根据 $y_1 - y_2$ 的符号分成两种情况： $(y_1 - y_2 \geq 0)\rightarrow \mid x_1-x_2\mid +\mid y_1-y_2\mid =x_1 + y_1 - (x_2 + y_2)​$ $(y_1 - y_2&lt; 0)\rightarrow \mid x_1-x_2\mid +\mid y_1-y_2\mid =x_1 - y_1 - (x_2 - y_2)$ 只要分别求出 $x+y, x-y?$ 的最大值和最小值即能得出答案。 Code 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1, len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;int n, x, y, minx = 0x7fffffff, maxx, miny = 0x7fffffff, maxy;int main() &#123; read(n); for (int i = 1; i &lt;= n; i++) &#123; read(x), read(y); minx = min(minx, x + y), maxx = max(maxx, x + y); miny = min(miny, x - y), maxy = max(maxy, x - y); &#125; write(max(maxx - minx, maxy - miny)); putchar('\n'); return 0;&#125; 其实还有第二种做法，那就是把 曼哈顿距离 转化为 切比雪夫距离 求解，后面会讲到。 三、切比雪夫距离切比雪夫距离 是向量空间中的一种度量，二个点之间的距离定义是其各坐标数值差绝对值的最大值。—— 来源：百度百科 在 二维空间 内，两个点之间的切比雪夫距离为它们横坐标之差的绝对值与纵坐标之差的绝对值的最大值。设点 $A(x_1,y_1),B(x_2,y_2)$，则 $A,B$ 之间的切比雪夫距离用公式可以表示为： d(A,B) = max(\mid x_1 - x_2\mid , \mid y_1 - y_2\mid )仍然是这个栗子，下图中 $A,B$ 的坐标分别为 $A(6,5),B(2,2)$。 d(A,B) = \max(\mid 6 - 2\mid , \mid 5 - 2\mid )=\max(4,3)=4 $n$ 维空间 中切比雪夫距离的距离公式： \begin{aligned} d(x,y) &= \max\begin{Bmatrix} \mid x_1 - y_1\mid ,\mid x_2 - y_2\mid ,\ldots,\mid x_n - y_n\mid \end{Bmatrix}\\ &= \max\begin{Bmatrix} \mid x_i - y_i\mid \end{Bmatrix}(i \in n)\\ \end{aligned} 四、（拓展）曼哈顿距离与切比雪夫距离的相互转化首先，我们考虑画出平面直角坐标系上所有到原点的 曼哈顿距离 为 $1$ 的点。 通过公式，我们很容易得到方程 $\mid x\mid + \mid y\mid = 1​$。 将绝对值展开，得到 $4​$ 个 一次函数 ，分别是： y = x + 1(x \geq 0, y \geq 0) y = -x + 1(x \leq 0, y \geq 0) y = x - 1(x \geq 0, y \leq 0) y = -x - 1(x \leq 0, y \leq 0)将这 $4?$ 个函数画到平面直角坐标系上，得到一个边长为 $\sqrt{2}$ 的正方形，如下图所示： 正方形边界上所有的点到原点的 曼哈顿距离 都是 $1$ 。 同理，我们再考虑画出平面直角坐标系上所有到原点的 切比雪夫距离 为 $1$ 的点。 通过公式，我们知道 $\max(\mid x\mid ,\mid y\mid )=1$。 我们将式子展开，也同样可以得到可以得到 $4$ 条 线段，分别是： y = 1(-1\leq x \leq 1) y = -1(-1\leq x \leq 1) x = 1,(-1\leq y \leq 1) x = -1,(-1\leq y \leq 1)画到平面直角坐标系上，可以得到一个边长为 $2$ 的正方形，如下图所示： 正方形边界上所有的点到原点的 切比雪夫距离 都是 $1$ 。 将这两幅图对比，我们会神奇地发现： 这 $2$ 个正方形是 相似图形 。 所以，曼哈顿距离 与 切比雪夫距离 之间会不会有联系呢？ 接下来我们简略证明一下： 假设 $A(x_1,y_1),B(x_2,y_2)$， $A,B$ 两点的 曼哈顿距离 为： \begin{aligned} d(A,B)&=\mid x_1 - x_2\mid + \mid y_1 - y_2\mid \\ &= \max\begin{Bmatrix} x_1 - x_2 + y_1 - y_2, x_1 - x_2 + y_2 - y_1,x_2 - x_1 + y_1 - y_2, x_2 - x_1 + y_2 - y_1\end{Bmatrix}\\ &（把绝对值拆开，能够得到四个值，这四个值中的最大值是两个 非负数 之和，即 曼哈顿距离）\\ &= \max\begin{Bmatrix}\mid (x_1 + y_1) - (x_2 + y_2)\mid , \mid (x_1 - y_2) - (x_2 - y_2)\mid \end{Bmatrix}\\ \end{aligned}我们很容易发现，这就是 $(x_1 + y_1,x_1 - y_1), (x_2 + y_2,x_2 - y_2)?$ 两点之间的 切比雪夫距离。 所以将每一个点 $(x,y)$ 转化为 $(x + y, x - y)$，新坐标系下的 切比雪夫距离 即为原坐标系下的 曼哈顿距离。 同理，$A,B?$ 两点的 切比雪夫距离 为： \begin{aligned} d(A,B)&=\max\begin{Bmatrix} \mid x_1 - x_2\mid ,\mid y_1 - y_2\mid \end{Bmatrix}\\ &=\max\begin{Bmatrix} \mid \frac{x_1 + y_1}{2}-\frac{x_2 + y_2}{2}\mid +\mid \frac{x_1 - y_1}{2}-\frac{x_2 - y_2}{2}\mid \end{Bmatrix}\\ \end{aligned}而这就是 $(\frac{x_1 + y_1}{2},\frac{x_1 - y_1}{2}), (\frac{x_2 + y_2}{2},\frac{x_2 - y_2}{2})$ 两点之间的 曼哈顿距离。 所以将每一个点 $(x,y)$ 转化为 $(\frac{x + y}{2},\frac{x - y}{2})$，新坐标系下的 曼哈顿距离 即为原坐标系下的 切比雪夫距离。 结论： 将切比雪夫坐标系旋转 $45^\circ$，再缩小到原来的一半，即可得到曼哈顿坐标系。 将点 $(x,y)$ 的坐标变为 $(x + y, x - y)$， 原坐标系中的 曼哈顿距离 $=$ 新坐标系中的 切比雪夫距离 将点 $(x,y)$ 的坐标变为 $(\frac{x + y}{2},\frac{x - y}{2})$， 原坐标系中的 切比雪夫距离 $=$ 新坐标系中的 曼哈顿距离 碰到求 切比雪夫距离 或 曼哈顿距离 的题目时，我们往往可以相互转化来求解。两种距离在不同的题目中有不同的优缺点，应该灵活运用。 例题： [Luogu]P4648（曼哈顿距离转切比雪夫距离） [Luogu]P3964（切比雪夫距离转曼哈顿距离） 最后给出 [Luogu]P5098 的第二种解法： 我们考虑将题目所求的 曼哈顿距离 转化为 切比雪夫距离，即把每个点的坐标 $(x,y)$ 变为 $(x + y, x - y)$。 所求的答案就变为 $\max_{\forall i,j\in n}\begin{Bmatrix} \max\begin{Bmatrix} \mid x_i - x_j\mid ,\mid y_i - y_j\mid \end{Bmatrix}\end{Bmatrix}$ 现要使得横坐标之差和纵坐标之差最大，只需要预处理出 $x,y$ 的最大值和最小值即可。 Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 1, len = 1; for (; y &lt;= x / 10; y *= 10) ++len; for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);&#125;int n, x, y, a, b, minx = 0x7fffffff, maxx, miny = 0x7fffffff, maxy;int main() &#123; read(n); for (int i = 1; i &lt;= n; i++) &#123; read(a), read(b); x = a + b, y = a - b; minx = min(minx, x), maxx = max(maxx, x); miny = min(miny, y), maxy = max(maxy, y); &#125; write(max(maxx - minx, maxy - miny)); putchar('\n'); return 0;&#125; 对比两份代码，我们又能够发现，两种不同的思路，写出来的代码却是完全等价的，是不是很神奇呢？当然，更高深的东西需要大家另行研究。]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数论数学</tag>
        <tag>Luogu</tag>
        <tag>笔记</tag>
        <tag>距离</tag>
      </tags>
  </entry>
</search>
