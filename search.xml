<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[「SPOJ2713/BZOJ3211」GSS4 - Can you answer these queries Ⅳ/花神游历各国]]></title>
    <url>%2F2019%2F03%2F13%2F%5BSPOJ2713BZOJ3211%5DGSS4%2F</url>
    <content type="text"><![CDATA[Description:给定 $n$ 个数，已知： $$\sum_{i=1}^{n}a[i] \leq 10^{18}$$ $m$ 个操作： $0\ x\ y:$ 将区间 $[x,y]$ 内的每一个数开 平方根（下取整） 。 $1\ x\ y:$ 询问区间 $[x,y]$ 所有数的和。 Source:[Luogu]SP2713 [Luogu]P4145 [BZOJ]3211 [SPOJ]2713 Solution:因为要维护区间和，所以我们想到用线段树来维护。 但是会发现懒惰标记不能打，那该怎么办呢？ 考虑暴力修改： $a[i]$ 最大为 $10^{18}$。 $$\left \lfloor \sqrt{\sqrt{\sqrt{\sqrt{\sqrt{\sqrt{10^{18}}}}}}}\right \rfloor = 1$$ 换言之， $$\left \lfloor \sqrt[2^6]{10^{18}}\right \rfloor = 1$$ 一个数最多开 $6$ 次平方根就会变成 $1$ 。 因为 $\sqrt{1} = 1,\sqrt{0} = 0$， 我们只需要维护 区间和 与 区间最大值 即可， 当一个区间的最大值 $\leq 1$ 时，我们对这个区间的修改就是无用的。 而我们对一个数的开平方操作不会超过 $6​$ 次，所以时间复杂度仍是 $O(n\ log\ n)​$ 。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 10, len = 1; while (y &lt;= x) &#123; y *= 10; ++len; &#125; while (len--) &#123; y /= 10; putchar(x / y + 48); x %= y; &#125;&#125;const int MAXN = 1e5 + 10;struct SegmentTree &#123; LL sum[MAXN &lt;&lt; 2], maxx[MAXN &lt;&lt; 2]; inline int lson(int x) &#123; return x &lt;&lt; 1; &#125; inline int rson(int x) &#123; return x &lt;&lt; 1 | 1; &#125; inline void pushUp(int x) &#123; sum[x] = sum[lson(x)] + sum[rson(x)]; maxx[x] = max(maxx[lson(x)], maxx[rson(x)]); &#125; void build(int x, int l, int r, LL *a) &#123; if (l == r) &#123; sum[x] = a[l]; maxx[x] = a[l]; return; &#125; int mid = l + r &gt;&gt; 1; build(lson(x), l, mid, a), build(rson(x), mid + 1, r, a); pushUp(x); &#125; void update(int ql, int qr, int l, int r, int x) &#123; if (maxx[x] &lt;= 1) return;//如果区间最大值小于等于1，就可以直接忽略这个区间的修改操作 if (l == r) &#123; sum[x] = sqrt(sum[x]); maxx[x] = sqrt(maxx[x]); return; &#125; int mid = l + r &gt;&gt; 1; if (ql &lt;= mid) update(ql, qr, l, mid, lson(x)); if (qr &gt; mid) update(ql, qr, mid + 1, r, rson(x)); pushUp(x); &#125; LL query(int ql, int qr, int l, int r, int x)&#123; if (ql &lt;= l &amp;&amp; qr &gt;= r) return sum[x]; int mid = l + r &gt;&gt; 1; LL res = 0; if (ql &lt;= mid) res += query(ql, qr, l, mid, lson(x)); if (qr &gt; mid) res += query(ql, qr, mid + 1, r, rson(x)); return res; &#125;&#125; tr;int n, m;LL a[MAXN];int main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) read(a[i]); tr.build(1, 1, n, a); read(m); for (int opt, l, r, i = 1; i &lt;= m; ++i) &#123; read(opt), read(l), read(r); if (l &gt; r) swap(l, r); if (opt == 1) &#123; write(tr.query(l, r, 1, n, 1)); putchar('\n'); &#125; else tr.update(l, r, 1, n, 1); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>SPOJ</tag>
        <tag>Luogu</tag>
        <tag>题解</tag>
        <tag>BZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SPOJ1716」GSS3 - Can you answer these queries Ⅲ]]></title>
    <url>%2F2019%2F03%2F13%2F%5BSPOJ1716%5DGSS3%2F</url>
    <content type="text"><![CDATA[Description:给定一个长度为 $n (n \leq 50000,|a[i]| \leq 10000)$ 的整数序列 和 $m$ 个操作： $0\ x\ y:$ 把 $a[x]$ 的值修改为 $y$ $|y \leq 10000|$。 $1\ x\ y:$ 询问区间 $[l,r]$ 的最大子段和。 Source:[Luogu]SP1716 SPOJ1716 Solution:仅仅是比 「SPOJ1043」GSS1 多了一个单点修改操作，暴力修改并且加上 $\mathrm{pushUp}$ 操作即可。 $\mathrm{pushUp}$ 操作 和 $\mathrm{query}​$ 操作 的详细实现过程请看上一行链接。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 10, len = 1; while (y &lt;= x) &#123; y *= 10; ++len; &#125; while (len--) &#123; y /= 10; putchar(x / y + 48); x %= y; &#125;&#125;const int MAXN = 5e4 + 10;struct SegmentTree &#123; struct Node &#123; LL sum, lsum, rsum, res; &#125; seg[MAXN &lt;&lt; 2]; inline int lson(int x) &#123; return x &lt;&lt; 1; &#125; inline int rson(int x) &#123; return x &lt;&lt; 1 | 1; &#125; inline void pushUp(int x) &#123; seg[x].sum = seg[lson(x)].sum + seg[rson(x)].sum; seg[x].res = max(max(seg[lson(x)].res, seg[rson(x)].res), seg[lson(x)].rsum + seg[rson(x)].lsum); seg[x].lsum = max(seg[lson(x)].lsum, seg[lson(x)].sum + seg[rson(x)].lsum); seg[x].rsum = max(seg[rson(x)].rsum, seg[lson(x)].rsum + seg[rson(x)].sum); &#125; void build(int x, int l, int r, LL a[]) &#123; if (l == r) &#123; seg[x] = (Node) &#123; a[l], a[l], a[l], a[l] &#125;; return; &#125; int mid = l + r &gt;&gt; 1; build(lson(x), l, mid, a), build(rson(x), mid + 1, r, a); pushUp(x); &#125; void update(int q, int l, int r, int x, LL p) &#123; if (l == r) &#123; seg[x] = (Node) &#123; p, p, p, p &#125;; return; &#125; int mid = l + r &gt;&gt; 1; if (q &lt;= mid) update(q, l, mid, lson(x), p); else update(q, mid + 1, r, rson(x), p); pushUp(x); &#125; Node query(int ql, int qr, int l, int r, int x) &#123; if (ql &lt;= l &amp;&amp; qr &gt;= r) return seg[x]; int mid = l + r &gt;&gt; 1; if (qr &lt;= mid) return query(ql, qr, l, mid, lson(x)); if (ql &gt; mid) return query(ql, qr, mid + 1, r, rson(x)); Node ans, lx = query(ql, qr, l, mid, lson(x)), ly = query(ql, qr, mid + 1, r, rson(x)); ans.sum = lx.sum + ly.sum; ans.res = max(max(lx.res, ly.res), lx.rsum + ly.lsum); ans.lsum = max(lx.lsum, lx.sum + ly.lsum); ans.rsum = max(ly.rsum, lx.rsum + ly.sum); return ans; &#125;&#125; tr;int n, q, l, r;bool opt;LL a[MAXN];int main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) read(a[i]); tr.build(1, 1, n, a); for (read(q); q; --q) &#123; read(opt), read(l), read(r); if (!opt) tr.update(l, 1, n, 1, r); else &#123; write(tr.query(l, r, 1, n, 1).res); putchar('\n'); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>SPOJ</tag>
        <tag>Luogu</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SPOJ1043」GSS1 - Can you answer these queries Ⅰ]]></title>
    <url>%2F2019%2F03%2F12%2F%5BSPOJ1043%5DGSS1%2F</url>
    <content type="text"><![CDATA[Description:给定一个长度为 $n (n \leq 50000,|a[i]| \leq 15007)$ 的整数序列，对于 $m$ 个询问 $l,r$，求区间 $[l,r]$ 的最大子段和。 Source:[Luogu]SP1043 [SPOJ]1043 Solution:如果用朴素的最大子段和算法，时间复杂度为 $O(nm)$，一定会超时。 很容易想到用数据结构来维护。 我们建立一棵线段树，对于区间 $x$，有以下定义： $sum[x]$ 表示区间和； $lsum[x]$ 表示以该区间左端点为起点的最大子段和； $rsum[x]$ 表示以该区间右端点为起点的最大子段和； $res[x]$ 表示该区间内的最大子段和。 与普通的线段树不同，这道题维护的信息很多，我们先来分析该题最重要的 $\mathrm{pushUp}$ 与 $\mathrm{query}$ 操作。 $\mathrm{pushUp}$ 操作：首先，是维护区间和，最基本的线段树操作，就不用多说了： $$sum[x] = sum[lson(x)] + sum[rson(x)]$$ 其次，假如我们知道一个区间的左右子区间信息，如何更新该区间的最大子段和？ 很显然，答案可能为 左区间的最大子段和 或 右区间的最大子段和 。 除此之外，合并区间后，答案也有可能为 左区间的右起最大子段和 + 右区间的左起最大子段和，如上图。 由此我们可以得到代码： $$res[x]=\max\begin{Bmatrix}res[lson(x)],res[rson(x)],rsum[lson(x)]+lsum[rson(x)]\end{Bmatrix}$$ 那如何更新该区间的 左起最大子段和 和 右起最大子段和 呢？ 区间左起最大子段和可以是 左区间的左起最大子段和 或 左区间的区间和 + 右区间的左起最大子段和，如上图。 右起最大子段和将上述操作反过来即可。 代码实现如下： $$lsum[x]=\max(lsum[lson],sum[lson]+lsum[rson])$$ $$rsum[x]=\max(rsum[rson],rsum[lson]+sum[rsum])$$ $\mathrm{query}$ 操作： 当答案来自两个不同的区间时（如图），我们需要对这两个区间答案进行合并，并不只是取最大值那样简单。 我们还需要进行类似 $\mathrm{pushUp}$ 的操作，已知左右区间的答案，更新该区间答案。 函数的返回值有很多，所以用结构体式线段树实现更方便。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); x = f ? -x : x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 10, len = 1; while (y &lt;= x) &#123; y *= 10; ++len; &#125; while (len--) &#123; y /= 10; putchar(x / y + 48); x %= y; &#125;&#125;const int MAXN = 5e4 + 10;struct SegmentTree &#123; struct Node &#123; LL sum, lsum, rsum, res; &#125; seg[MAXN &lt;&lt; 2]; inline int lson(int x) &#123; return x &lt;&lt; 1; &#125; inline int rson(int x) &#123; return x &lt;&lt; 1 | 1; &#125; inline void pushUp(int x) &#123; seg[x].sum = seg[lson(x)].sum + seg[rson(x)].sum; seg[x].res = max(max(seg[lson(x)].res, seg[rson(x)].res), seg[lson(x)].rsum + seg[rson(x)].lsum); seg[x].lsum = max(seg[lson(x)].lsum, seg[lson(x)].sum + seg[rson(x)].lsum); seg[x].rsum = max(seg[rson(x)].rsum, seg[lson(x)].rsum + seg[rson(x)].sum); &#125; void build(int x, int l, int r, LL a[]) &#123; if (l == r) &#123; seg[x] = (Node) &#123; a[l], a[l], a[l], a[l] &#125;; return; &#125; int mid = l + r &gt;&gt; 1; build(lson(x), l, mid, a), build(rson(x), mid + 1, r, a); pushUp(x); &#125; Node query(int ql, int qr, int l, int r, int x) &#123;//分成3种情况考虑 if (ql &lt;= l &amp;&amp; qr &gt;= r) return seg[x]; int mid = l + r &gt;&gt; 1; if (qr &lt;= mid) return query(ql, qr, l, mid, lson(x)); if (ql &gt; mid) return query(ql, qr, mid + 1, r, rson(x)); Node ans, lx = query(ql, qr, l, mid, lson(x)), ly = query(ql, qr, mid + 1, r, rson(x)); ans.sum = lx.sum + ly.sum; ans.res = max(max(lx.res, ly.res), lx.rsum + ly.lsum); ans.lsum = max(lx.lsum, lx.sum + ly.lsum); ans.rsum = max(ly.rsum, lx.rsum + ly.sum); return ans; &#125;&#125; tr;int n, q, l, r;LL a[MAXN];int main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) read(a[i]); tr.build(1, 1, n, a); for (read(q); q; --q) &#123; read(l), read(r); write(tr.query(l, r, 1, n, 1).res); putchar('\n'); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>SPOJ</tag>
        <tag>Luogu</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ1303/Luogu1627」「CQOI2009」中位数图]]></title>
    <url>%2F2019%2F03%2F12%2F%5BBZOJ1303Luogu1627%5D%5BCQOI2009%5D%E4%B8%AD%E4%BD%8D%E6%95%B0%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[Description:给定长度为 $n$ 的序列，求有多少包含 $b$ 的奇数长度的序列中位数为 $b$ 。 Source:[BZOJ]1303 [Luogu]P1627 Solution:因为所求的是中位数，所以考虑改变原序列。把大于 $b$ 的数全部变为 $1$，小于 $b$ 的数变为 $-1$，等于 $b$ 则为 $0$。问题就变为求存在几个包含 $b$ 的区间和为 $0$ 。我们假设 $tmp$ 为 $b$ 的下标，原数组为 $x$，新数组为 $a$ 。 Sample Input:127 45 7 2 4 3 1 6 Sample Output:14 Example: 对于样例，能使结果成立的 $4$ 个区间分别为 $[1,5]$ , $[1,7]$ , $[2,4]$ , $[4,4]$。 接下来我们建造两个桶，分别计数 $tmp$ 左边的后缀和与右边的前缀和，假设左边的后缀和为 $l$，右边的前缀和为 $r$ 。$l[i]/r[i]$ 表示从点 $i$ 向右/向左 到点 $tmp$ 为止 (比 $b$ 大的数的数量 - 比 $b$ 小的数的数量) 出现的次数。还是拿样例来说： 通过观察上图，我们能够发现，左边的数 $x$ 可以与右边的每一个 $-x$ 进行匹配。通过乘法原理，该值即为 $l[x] \times r[-x]$，由题意可知 $-10^5 \le x \le 10^5$，遍历所有的 $x$ 即可，最终答案为： $$\sum_{i=\min{x}}^{\max{x}}l[i] \times r[-i]$$ 值得注意的是，$l[0]$ 和 $r[0]$ 的初始值为 $1$，因为 $b$ 是需要被算入的。当然，桶的下标不能是负数，所以我在每次操作时都加上了一个很大的数，比如数据最大值 —— $10^5$，也可以用 $\mathrm{STL}$ 中的 $map$ 解决问题，时间复杂度为 $O(n)$ 。 Code1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); x = f ? -x : x;&#125;const int MAXN = 1e5;LL n, b, x, tmp, sum, ans, a[MAXN + 10], l[MAXN &lt;&lt; 2], r[MAXN &lt;&lt; 2];int main() &#123; read(n), read(b); for (LL i = 1; i &lt;= n; i++) &#123; read(x); if (x == b) tmp = i; else a[i] = x &gt; b ? 1 : -1; &#125;//初始化 l[MAXN] = 1, r[MAXN] = 1; for (LL i = tmp - 1; i &gt;= 1; i--) &#123; sum += a[i]; l[sum + MAXN]++; &#125;//后缀和统计 sum = 0; for (LL i = tmp + 1; i &lt;= n; i++) &#123; sum += a[i]; r[sum + MAXN]++; &#125;//前缀和统计 for (LL i = 0; i &lt;= (MAXN &lt;&lt; 1); i++) &#123; if (l[i] &amp;&amp; r[(MAXN &lt;&lt; 1) - i]) ans += l[i] * r[(MAXN &lt;&lt; 1) - i]; &#125;//累加答案 printf("%lld\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>Luogu</tag>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>BZOJ</tag>
        <tag>CQOI</tag>
        <tag>2009</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用距离算法详解]]></title>
    <url>%2F2019%2F03%2F11%2F%E5%B8%B8%E7%94%A8%E8%B7%9D%E7%A6%BB%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[在计算距离时，我们一般都是求两点之间的直线距离，实际上距离算法并不只这一种，还有其他的距离算法在 $\mathrm{OI}$ 中也同样很重要。不同的距离算法都有明显的优缺点。本文主要讲解 三种 常见的距离算法，分别是 欧氏距离，曼哈顿距离，切比雪夫距离 。 一、欧氏距离（欧几里得度量）欧氏距离，是一个通常采用的距离定义，指在$m$维空间中两个点之间的真实距离，或者向量的自然长度（即该点到原点的距离）。在二维和三维空间中的欧氏距离就是两点之间的实际距离。—— 来源：百度百科 欧氏距离 是最易于理解的一种距离算法。在数学的平面直角坐标系中，设点 $A,B$ 的坐标分别为 $A(x_1,y_1),B(x_2,y_2)$，求点 $A,B$ 之间的距离，我们一般会使用如下公式： $$\left | AB \right | = \sqrt{\left ( x_2 - x_1 \right )^2 + \left ( y_2 - y_1 \right )^2}$$ 实际上这就是平面（二维空间）中两点欧氏距离的距离公式，除此之外，$P(x,y)$ 到原点的欧氏距离可以用公式表示为： $$|P| = \sqrt{x^2+y^2}$$ 举个栗子，在下图中 $A,B$ 的坐标分别为 $A(6,5),B(2,2)$。 通过公式，我们很容易得到 $A,B$ 两点间的欧氏距离： $$\left | AB \right | = \sqrt{\left ( 2 - 6 \right )^2 + \left ( 2 - 5 \right )^2} = \sqrt{4^2+3^2} = 5$$ 那么，三维空间 中两点的欧氏距离公式呢？我们来观察下图。 我们很容易发现，在$\triangle ADC$中，$\angle ADC = 90^\circ$；在$\triangle ACB$中，$\angle ACB = 90^\circ$。 $$\therefore |AB|=\sqrt{|AC|^2+|BC|^2}$$$$=\sqrt{|AD|^2+|CD|^2+|BC|^2}$$ 由此可得，三维空间 中欧氏距离的距离公式为： $$\left | AB \right | = \sqrt{\left ( x_2 - x_1 \right )^2 + \left ( y_2 - y_1 \right )^2 + \left ( z_2 - z_1 \right )^2}$$ $$|P| = \sqrt{x^2+y^2+z^2}$$ 例题：[Luogu]3958 以此类推，我们就得到了 $n$ 维空间 中欧氏距离的距离公式： $$d(x,y) = \sqrt{\left ( x_1 - y_1 \right )^2 + \left ( x_2 - y_2 \right )^2 + \cdot \cdot \cdot +\left ( x_n - y_n \right )^2}$$$$ = \sqrt{\sum_{i = 1}^{n}(x_i - y_i)^2}$$ 欧氏距离虽然很有用，但也有明显的缺点。两个整点计算其欧氏距离时，往往答案是浮点型，会存在一定误差。 二、曼哈顿距离曼哈顿距离 是种使用在几何度量空间的几何学用语，用以标明两个点在标准坐标系上的绝对轴距总和。曼哈顿距离不是距离不变量，当坐标轴变动时，点间的距离就会不同。—— 来源：百度百科 在 二维空间 内，两个点之间的曼哈顿距离为它们横坐标之差的绝对值与纵坐标之差的绝对值之和。设点 $A(x_1,y_1),B(x_2,y_2)$，则 $A,B$ 之间的曼哈顿距离用公式可以表示为： $$d(A,B) = |x_1 - x_2| + |y_1 - y_2|$$ 观察下图： 在 $A,B$ 间，$\color{yellow}{黄线}$，$\color{orange}{橙线}$ 都表示曼哈顿距离，而$\color{red}{红线}$，$\color{blue}{蓝线}$表示 等价 的曼哈顿距离，$\color{green}{绿线}$表示欧氏距离。 同样的栗子，在下图中 $A,B​$ 的坐标分别为 $A(6,5),B(2,2)​$。 通过公式，我们很容易得到 $A,B$ 两点间的曼哈顿距离：$$d(A,B) = |6 - 2| + |5 - 2| = 4 + 3 = 7$$ 经过推导，我们得到 $n$ 维空间 的曼哈顿距离公式为：$$d(A,B) = |x_1 - y_1| + |x_2 - y_2| + \cdot \cdot \cdot + |x_n - y_n|$$$$=\sum_{i = 1}^{n}|x_i - y_i|$$ 除了公式之外，曼哈顿距离还具有以下 数学性质： 非负性 曼哈顿距离是一个非负数。 $d(i,j)\geq 0$ 统一性 点到自身的曼哈顿距离为 $0$。 $d(i,i) = 0$ 对称性 $A$ 到 $B$ 与 $B$ 到 $A$ 的曼哈顿距离相等，且是对称函数。 $d(i,j) = d(j,i)$ 三角不等式 从点 $i$ 到 $j$ 的直接距离不会大于途经的任何其它点 $k$ 的距离。 $d(i,j)\leq d(i,k)+d(k,j)$ 例题：[Luogu]5098 解析： （不要被难度吓住，是假的） 根据题意，对于式子$|x_1-x_2|+|y_1-y_2|$，我们可以假设 $x_1 - x_2 \geq 0$，根据 $y_1 - y_2$ 的符号分成两种情况： $(y_1 - y_2 \geq 0)\rightarrow |x_1-x_2|+|y_1-y_2|=x_1 + y_1 - (x_2 + y_2)$ $(y_1 - y_2&lt; 0)\rightarrow |x_1-x_2|+|y_1-y_2|=x_1 - y_1 - (x_2 - y_2)$ 只要分别求出 $x+y, x-y$ 的最大值和最小值即能得出答案。 Code12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); x = f ? -x : x;&#125;int n, x, y, minx = 0x7fffffff, maxx, miny = 0x7fffffff, maxy;int main() &#123; read(n); for (int i = 1; i &lt;= n; i++) &#123; read(x), read(y); minx = min(minx, x + y), maxx = max(maxx, x + y); miny = min(miny, x - y), maxy = max(maxy, x - y); &#125; printf("%d\n", max(maxx - minx, maxy - miny)); return 0;&#125; 其实还有第二种做法，那就是把 曼哈顿距离 转化为 切比雪夫距离 求解，后面会讲到。 三、切比雪夫距离切比雪夫距离 是向量空间中的一种度量，二个点之间的距离定义是其各坐标数值差绝对值的最大值。—— 来源：百度百科 在 二维空间 内，两个点之间的切比雪夫距离为它们横坐标之差的绝对值与纵坐标之差的绝对值的最大值。设点 $A(x_1,y_1),B(x_2,y_2)$，则 $A,B$ 之间的切比雪夫距离用公式可以表示为： $$d(A,B) = max(|x_1 - x_2|, |y_1 - y_2|)$$ 仍然是这个栗子，下图中 $A,B$ 的坐标分别为 $A(6,5),B(2,2)$。 $$d(A,B) = \max(|6 - 2|, |5 - 2|)=\max(4,3)=4$$ $n$ 维空间 中切比雪夫距离的距离公式： $$d(x,y) = \max\begin{Bmatrix} |x_1 - y_1|,|x_2 - y_2|,\cdot \cdot \cdot,|x_n - y_n|\end{Bmatrix}$$$$ = \max\begin{Bmatrix} |x_i - y_i|\end{Bmatrix}(i \in n)$$ 四、（拓展）曼哈顿距离与切比雪夫距离的相互转化首先，我们考虑画出平面直角坐标系上所有到原点的 曼哈顿距离 为 $1$ 的点。 通过公式，我们很容易得到方程 $|x| + |y| = 1$。 将绝对值展开，得到 $4$ 个 一次函数 ，分别是： $$y = x + 1(x \geq 0, y \geq 0)$$ $$y = -x + 1(x \leq 0, y \geq 0)$$ $$y = x - 1(x \geq 0, y \leq 0)$$ $$y = -x - 1(x \leq 0, y \leq 0)$$ 将这 $4$ 个函数画到平面直角坐标系上，得到一个边长为 $\sqrt{2}$ 的正方形，如下图所示： 正方形边界上所有的点到原点的 曼哈顿距离 都是 $1$ 。 同理，我们再考虑画出平面直角坐标系上所有到原点的 切比雪夫距离 为 $1$ 的点。 通过公式，我们知道 $\max(|x|,|y|)=1$。 我们将式子展开，也同样可以得到可以得到 $4$ 条 线段，分别是： $$y = 1(-1\leq x \leq 1)$$ $$y = -1(-1\leq x \leq 1)$$ $$x = 1,(-1\leq y \leq 1)$$ $$x = -1,(-1\leq y \leq 1)$$ 画到平面直角坐标系上，可以得到一个边长为 $2$ 的正方形，如下图所示： 正方形边界上所有的点到原点的 切比雪夫距离 都是 $1$ 。 将这两幅图对比，我们会神奇地发现： 这 $2$ 个正方形是 相似图形 。 所以，曼哈顿距离 与 切比雪夫距离 之间会不会有联系呢？ 接下来我们简略证明一下： 假设 $A(x_1,y_1),B(x_2,y_2)$， $A,B$ 两点的 曼哈顿距离 为：$$d(A,B)=|x_1 - x_2| + |y_1 - y_2|$$$$=|x_1 - x_2| + |y_1 - y_2|$$$$= \max\begin{Bmatrix} x_1 - x_2 + y_1 - y_2, x_1 - x_2 + y_2 - y_1,x_2 - x_1 + y_1 - y_2, x_2 - x_1 + y_2 - y_1\end{Bmatrix} $$ （ 把绝对值拆开，能够得到四个值，这四个值中的最大值是两个 非负数 之和，即 曼哈顿距离 ）$$= \max\begin{Bmatrix}|(x_1 + y_1) - (x_2 + y_2)|, |(x_1 - y_2) - (x_2 - y_2)|\end{Bmatrix}$$ 我们很容易发现，这就是 $(x_1 + y_1,x_1 - y_1), (x_2 + y_2,x_2 - y_2)$ 两点之间的 切比雪夫距离。 所以将每一个点 $(x,y)$ 转化为 $(x + y, x - y)$，新坐标系下的 切比雪夫距离 即为原坐标系下的 曼哈顿距离。 同理，$A,B$ 两点的 切比雪夫距离 为：$$d(A,B)=\max\begin{Bmatrix} |x_1 - x_2|,|y_1 - y_2|\end{Bmatrix} $$$$=\max\begin{Bmatrix} |\frac{x_1 + y_1}{2}-\frac{x_2 + y_2}{2}|+|\frac{x_1 - y_1}{2}-\frac{x_2 - y_2}{2}|\end{Bmatrix} $$ 而这就是 $(\frac{x_1 + y_1}{2},\frac{x_1 - y_1}{2}), (\frac{x_2 + y_2}{2},\frac{x_2 - y_2}{2})$ 两点之间的 曼哈顿距离。 所以将每一个点 $(x,y)$ 转化为 $(\frac{x + y}{2},\frac{x - y}{2})$，新坐标系下的 曼哈顿距离 即为原坐标系下的 切比雪夫距离。 结论： 将切比雪夫坐标系旋转 $45^\circ$，再缩小到原来的一半，即可得到曼哈顿坐标系。 将点 $(x,y)$ 的坐标变为 $(x + y, x - y)$， 原坐标系中的 曼哈顿距离 $=$ 新坐标系中的 切比雪夫距离 将点 $(x,y)$ 的坐标变为 $(\frac{x + y}{2},\frac{x - y}{2})$， 原坐标系中的 切比雪夫距离 $=$ 新坐标系中的 曼哈顿距离 碰到求 切比雪夫距离 或 曼哈顿距离 的题目时，我们往往可以相互转化来求解。两种距离在不同的题目中有不同的优缺点，应该灵活运用。 例题： [Luogu]4648（曼哈顿距离转切比雪夫距离） [Luogu]3964（切比雪夫距离转曼哈顿距离） 最后给出 [Luogu]5098 的第二种解法： 我们考虑将题目所求的 曼哈顿距离 转化为 切比雪夫距离，即把每个点的坐标 $(x,y)$ 变为 $(x + y, x - y)$。 所求的答案就变为 $\max_{i,j\in n}\begin{Bmatrix} \max\begin{Bmatrix} |x_i - x_j|,|y_i - y_j|\end{Bmatrix}\end{Bmatrix}$ 现要使得横坐标之差和纵坐标之差最大，只需要预处理出 $x,y$ 的最大值和最小值即可。 Code1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); x = f ? -x : x;&#125;int n, x, y, a, b, minx = 0x7fffffff, maxx, miny = 0x7fffffff, maxy;int main() &#123; read(n); for (int i = 1; i &lt;= n; i++) &#123; read(a), read(b); x = a + b, y = a - b; minx = min(minx, x), maxx = max(maxx, x); miny = min(miny, y), maxy = max(maxy, y); &#125; printf("%d\n", max(maxx - minx, maxy - miny)); return 0;&#125; 对比两份代码，我们又能够发现，两种不同的思路，写出来的代码却是完全等价的，是不是很神奇呢？当然，更高深的东西需要大家另行研究。]]></content>
      <tags>
        <tag>Luogu</tag>
        <tag>数学</tag>
        <tag>距离</tag>
      </tags>
  </entry>
</search>
